#!/usr/bin/env bash
set -euo pipefail

HAXE_BIN="${HAXE_BIN:-haxe}"

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)"
TOOL_DIR="$ROOT/tools/hxhx-macro-host"
BOOTSTRAP_DIR="$TOOL_DIR/bootstrap_out"

# Stage4 / Gate bring-up note:
#
# We want `hxhx` to be able to spawn a macro host without requiring a "stage0" Haxe
# compiler on PATH. To support that, this repo can carry a *bootstrap* OCaml snapshot
# of the macro host output (generated by our OCaml backend once, then committed).
#
# Default policy:
# - If the bootstrap snapshot exists *and* no dynamic entrypoints/classpaths are requested,
#   build the host with dune from the snapshot (stage0-free).
# - Otherwise, fall back to stage0 `haxe` + `reflaxe.ocaml` to generate fresh OCaml output.
#
# Escape hatch:
# - Set `HXHX_MACRO_HOST_FORCE_STAGE0=1` to always use stage0 generation.
#
# Stage3 note:
# - When dynamic entrypoints are requested (`HXHX_MACRO_HOST_ENTRYPOINTS` and/or extra classpaths),
#   we *prefer* to build the macro host via `hxhx --hxhx-stage3` (stage0-free), falling back to
#   stage0 `haxe` only if required.

is_true() {
  local v="${1:-}"
  [[ "$v" == "1" || "$v" == "true" || "$v" == "yes" ]]
}

if ! command -v dune >/dev/null 2>&1 || ! command -v ocamlc >/dev/null 2>&1; then
  echo "Skipping hxhx macro host build: dune/ocamlc not found on PATH."
  exit 0
fi

if [ ! -d "$TOOL_DIR" ]; then
  echo "Missing tool directory: $TOOL_DIR" >&2
  exit 1
fi

if [ -d "$BOOTSTRAP_DIR" ] \
  && ! is_true "${HXHX_MACRO_HOST_FORCE_STAGE0:-}" \
  && [ -z "${HXHX_MACRO_HOST_ENTRYPOINTS:-}" ] \
  && [ -z "${HXHX_MACRO_HOST_EXTRA_CP:-}" ]; then
  (
    cd "$BOOTSTRAP_DIR"
    dune build --display=quiet ./out.exe
  )
  BIN="$BOOTSTRAP_DIR/_build/default/out.exe"
  if [ ! -f "$BIN" ]; then
    echo "Missing built bootstrap executable: $BIN" >&2
    exit 1
  fi
  echo "$BIN"
  exit 0
fi

# Prefer stage0-free Stage3 builds for dynamic macro host compilation.
#
# IMPORTANT
# - The Stage3-built macro host (`hxhxmacrohost.Stage3Main`) is only protocol-correct for
#   `hxhx --hxhx-macro-selftest` today. It intentionally does **not** implement `macro.run`.
# - When stage0 `haxe` is available, dynamic macro host builds should default to stage0 so the
#   Stage4 host (`hxhxmacrohost.Main`) can serve `macro.run` and entrypoints.
#
# Use Stage3 in dynamic mode when:
# - `HXHX_MACRO_HOST_PREFER_HXHX=1` is set explicitly, or
# - stage0 `haxe` is missing/disabled (stage0-free gating).
PREFER_HXHX="${HXHX_MACRO_HOST_PREFER_HXHX:-0}"
has_hxhx() {
  # `build-hxhx.sh` is stage0-free by default (uses packages/hxhx/bootstrap_out when available).
  "$ROOT/scripts/hxhx/build-hxhx.sh" >/dev/null 2>&1
}

normalize_cp() {
  local cp="$1"
  if [ -z "$cp" ]; then
    return 0
  fi
  # Treat relative classpaths as repo-root relative, because this script `cd`s
  # into `tools/hxhx-macro-host` before invoking the Haxe compiler.
  if [[ "$cp" != /* ]]; then
    cp="$ROOT/$cp"
  fi
  echo "$cp"
}

resolve_std_root() {
  # Stage3 compilation needs a real Haxe std root (macro host imports `haxe.macro.*`).
  if [ -n "${HAXE_STD_PATH:-}" ] && [ -d "${HAXE_STD_PATH}" ]; then
    echo "${HAXE_STD_PATH}"
    return 0
  fi
  if [ -d "$ROOT/vendor/haxe/std" ]; then
    echo "$ROOT/vendor/haxe/std"
    return 0
  fi
  if [ -n "${HAXE_UPSTREAM_DIR:-}" ] && [ -d "${HAXE_UPSTREAM_DIR}/std" ]; then
    echo "${HAXE_UPSTREAM_DIR}/std"
    return 0
  fi
  echo ""
}

escape_hx_string() {
  local s="$1"
  # Escape for inclusion inside a Haxe string literal.
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  echo "$s"
}

trim_ws() {
  # Trim leading/trailing whitespace without interpreting quotes.
  echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

(
  cd "$TOOL_DIR"
  rm -rf out
  mkdir -p out
  extra=()
  gen_cp=""
  if [ -n "${HXHX_MACRO_HOST_ENTRYPOINTS:-}" ]; then
    gen_cp="$TOOL_DIR/out/_gen_hx"
    mkdir -p "$gen_cp/hxhxmacrohost"
    gen_file="$gen_cp/hxhxmacrohost/EntryPointsGen.hx"

    # Generate a tiny registry that avoids reflection.
    #
    # `HXHX_MACRO_HOST_ENTRYPOINTS` is a `;`-separated list of exact expression strings to dispatch,
    # e.g.: `hxhxmacros.ExternalMacros.external();some.pack.M.foo()`
    #
    # For bring-up we only support:
    # - `pack.Class.method()` (no args)
    # - `pack.Class.method(\"...\")` (one String literal arg)
    {
      echo "package hxhxmacrohost;"
      echo ""
      echo "class EntryPointsGen {"
      echo "  public static function run(expr:String):Null<String> {"
      echo "    if (expr == null) return null;"
      echo "    final e = StringTools.trim(expr);"
      echo "    return switch (e) {"

      IFS=';' read -r -a entries <<<"${HXHX_MACRO_HOST_ENTRYPOINTS}"
      for raw in "${entries[@]}"; do
        entry="$(trim_ws "$raw")"
        if [ -z "$entry" ]; then
          continue
        fi

        # Expect `pack.Class.method(...)`.
        if [[ "$entry" != *")" ]]; then
          echo "      // Skipping unsupported entry (expected call expression): $entry"
          continue
        fi

        call_prefix="${entry%%(*}"
        args_inside="${entry#*(}"
        args_inside="${args_inside%)}"

        cls="${call_prefix%.*}"
        meth="${call_prefix##*.}"
        if [ -z "$cls" ] || [ -z "$meth" ] || [ "$cls" = "$call_prefix" ]; then
          echo "      // Skipping malformed entry: $entry"
          continue
        fi

        args_inside="$(trim_ws "$args_inside")"
        call_args=""
        if [ -n "$args_inside" ]; then
          # Bring-up rung: only support a single String literal argument.
          #
          # Examples:
          # - foo.Bar.baz(\"ok\")
          # - foo.Bar.baz('ok')  (accepted by Haxe for string literals)
          if [[ ( "$args_inside" == \"*\" && "$args_inside" == *\" ) || ( "$args_inside" == \'*\' && "$args_inside" == *\' ) ]]; then
            call_args="$args_inside"
          else
            echo "      // Skipping unsupported entry (expected 0 args or 1 string literal arg): $entry"
            continue
          fi
        fi

        entry_escaped="$(escape_hx_string "$entry")"

        # Emit case.
        #
        # We dispatch exact strings for auditability and call the entrypoint directly:
        # `untyped pack.Class.method(...)`.
        #
        # Why `untyped` (bring-up tradeoff)
        # - We need one dispatcher that can call entrypoints with unknown return types:
        #     - `Void` (initializers like `init()`)
        #     - `String` (macro.run summaries)
        #     - `Array<Field>` (build macros)
        # - Using `untyped` lets us store the return into `Dynamic` without needing to know
        #   the static return type.
        #
        # Why not `Reflect.callMethod(Reflect.field(...))` yet
        # - Our current portable runtime represents *anonymous structures* as `HxAnon`, but Haxe
        #   class values (`Type`) are not anonymous objects. `Reflect.field(SomeClass,"x")`
        #   therefore resolves through `HxAnon.get` and returns null, causing the macro host to
        #   crash when attempting to call the function.
        # - We may add a dedicated "Type field" reflection surface later; until then, prefer
        #   direct calls.
        #
        # Return value policy:
        # - If the entrypoint returns a `String`, propagate it (useful for macro.run summaries
        #   and for `macro.expandExpr` which returns expression text).
        # - Otherwise return `"ok"` (for `Void` entrypoints and non-string results).
        if [ -n "$call_args" ]; then
          echo "      case \"${entry_escaped}\": { final r:Dynamic = untyped ${cls}.${meth}(${call_args}); hxhxmacrohost.BuildMacroSupport.afterEntrypoint(r); Std.isOfType(r, String) ? (cast r) : \"ok\"; }"
        else
          echo "      case \"${entry_escaped}\": { final r:Dynamic = untyped ${cls}.${meth}(); hxhxmacrohost.BuildMacroSupport.afterEntrypoint(r); Std.isOfType(r, String) ? (cast r) : \"ok\"; }"
        fi
      done

      echo "      case _: null;"
      echo "    }"
      echo "  }"
      echo "}"
    } >"$gen_file"

    extra+=("-cp" "$gen_cp" "-D" "hxhx_entrypoints")
  fi

  if [ -n "${HXHX_MACRO_HOST_EXTRA_CP:-}" ]; then
    IFS=':' read -r -a cps <<<"${HXHX_MACRO_HOST_EXTRA_CP}"
    for cp in "${cps[@]}"; do
      cp="$(normalize_cp "$cp")"
      if [ -n "$cp" ]; then
        extra+=("-cp" "$cp")
      fi
    done
  fi

  if [ -n "${HXHX_MACRO_HOST_DEFINES:-}" ]; then
    IFS=':' read -r -a defs <<<"${HXHX_MACRO_HOST_DEFINES}"
    for d in "${defs[@]}"; do
      d="$(trim_ws "$d")"
      if [ -n "$d" ]; then
        extra+=("-D" "$d")
      fi
    done
  fi

  # Optional/experimental: attempt stage0-free build via `hxhx --hxhx-stage3`.
  #
  # Why
  # - Gate1/Gate2 acceptance require macro host bring-up to be stage0-free.
  # - The macro host is just another Haxe program; Stage3 can compile it with the same bootstrap emitter.
  #
  # How
  # - Use `--hxhx-no-run` to avoid hanging (macro host is a long-lived server process).
  #
  # Status
  # - This is still bring-up code (it does not execute arbitrary user macros yet), but it is
  #   protocol-correct for `hxhx --hxhx-macro-selftest`.
  HAVE_STAGE0=0
  if command -v "$HAXE_BIN" >/dev/null 2>&1; then
    HAVE_STAGE0=1
  fi

  WANT_STAGE3=0
  if ! is_true "${HXHX_MACRO_HOST_FORCE_STAGE0:-}"; then
    if is_true "$PREFER_HXHX" || [ "$HAVE_STAGE0" -eq 0 ]; then
      WANT_STAGE3=1
    fi
  fi

  if [ "$WANT_STAGE3" -eq 1 ]; then
    HXHX_BIN="$("$ROOT/scripts/hxhx/build-hxhx.sh")"
    STD_ROOT="$(resolve_std_root)"
    if [ -z "$STD_ROOT" ]; then
      echo "hxhx(stage3) macro host build requires a Haxe std root." >&2
      echo "Set HAXE_STD_PATH=/path/to/haxe/std or provide an untracked checkout at vendor/haxe." >&2
      if [ "$HAVE_STAGE0" -eq 0 ]; then
        echo "Missing stage0 Haxe compiler and std root; cannot build macro host." >&2
        exit 1
      fi
      # Fall back to stage0 if available.
    else
    # NOTE: do not reuse `build.hxml` here.
    #
    # Why
    # - `build.hxml` is for stage0 `haxe` + `reflaxe.ocaml` and includes `-lib reflaxe.ocaml`.
    # - Stage3 bring-up already *is* an OCaml codegen path; requiring haxelib resolution here would
    #   reintroduce avoidable stage0-like dependency edges.
    #
    # What
    # - Compile the macro host as a normal Haxe program from its source classpaths.
    cmd=(
      "$HXHX_BIN"
      --hxhx-stage3
      --hxhx-no-run
      --hxhx-emit-full-bodies
      --hxhx-out out
      --std "$STD_ROOT"
      -cp src
      -cp overrides
      -main hxhxmacrohost.Stage3Main
    )
    if [ "${#extra[@]}" -gt 0 ]; then
      cmd+=("${extra[@]}")
    fi
    echo "Building macro host via hxhx(stage3)..." >&2
    if "${cmd[@]}" 1>&2; then
      exit 0
    fi
    if [ "$HAVE_STAGE0" -eq 0 ]; then
      echo "hxhx(stage3) macro host build failed and no stage0 Haxe compiler is available." >&2
      exit 1
    fi
    echo "hxhx(stage3) macro host build failed; falling back to stage0 (if available)." >&2
    # Clean stage3 artifacts before stage0 generation so stale shims don't poison the dune build.
    rm -rf out
    mkdir -p out
    fi
  fi

  if ! command -v "$HAXE_BIN" >/dev/null 2>&1; then
    echo "Missing Haxe compiler on PATH (expected '$HAXE_BIN')." >&2
    echo "This macro host build requires stage0 `haxe` when dynamic entrypoints/classpaths are used." >&2
    echo "Set HAXE_STD_PATH=/path/to/haxe/std and retry to use stage0-free Stage3 builds." >&2
    exit 1
  fi

  cmd=("$HAXE_BIN" build.hxml -D ocaml_build=native)
  if [ "${#extra[@]}" -gt 0 ]; then
    cmd+=("${extra[@]}")
  fi
  "${cmd[@]}" 1>&2
)

BIN_STAGE3="$TOOL_DIR/out/out.exe"
if [ -f "$BIN_STAGE3" ]; then
  echo "$BIN_STAGE3"
  exit 0
fi

BIN_STAGE0="$TOOL_DIR/out/_build/default/out.exe"
if [ -f "$BIN_STAGE0" ]; then
  echo "$BIN_STAGE0"
  exit 0
fi

echo "Missing built executable (expected stage3 '$BIN_STAGE3' or stage0 '$BIN_STAGE0')." >&2
exit 1

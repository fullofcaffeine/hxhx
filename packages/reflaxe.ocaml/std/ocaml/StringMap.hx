package ocaml;

/**
 * OCaml-native persistent map with `string` keys.
 *
 * Why:
 * - OCaml's standard `Map` is functorized (`Stdlib.Map.Make`), which Haxe cannot express directly.
 * - For OCaml-native mode we want a *typed* surface that maps 1:1 to a concrete OCaml module so
 *   downstream OCaml libraries can accept the map type without wrappers.
 *
 * What:
 * - `ocaml.StringMap<V>` represents the type `'v OcamlNativeStringMap.t`.
 * - Operations are thin `inline` wrappers over the emitted module `OcamlNativeStringMap`
 *   (generated by the backend when this surface is used).
 *
 * How:
 * - The backend emits an OCaml file `OcamlNativeStringMap.ml` containing:
 *   `include Stdlib.Map.Make(struct type t = string let compare = Stdlib.compare end)`.
 * - This Haxe surface binds to that module via `@:native("OcamlNativeStringMap")`.
 *
 * Notes:
 * - This is intentionally not portable Haxe code; it is for OCaml-native interop.
 * - Values are persistent (immutable) like OCaml maps: `add/remove` return a new map.
 */
abstract StringMap<V>(Dynamic) {
	inline function new(v:Dynamic)
		this = v;

	public static inline function empty<V>():StringMap<V> {
		return cast StringMapNative.empty;
	}

	public static inline function isEmpty<V>(m:StringMap<V>):Bool {
		return StringMapNative.is_empty(m);
	}

	public static inline function add<V>(k:String, v:V, m:StringMap<V>):StringMap<V> {
		return StringMapNative.add(k, v, m);
	}

	public static inline function remove<V>(k:String, m:StringMap<V>):StringMap<V> {
		return StringMapNative.remove(k, m);
	}

	public static inline function mem<V>(k:String, m:StringMap<V>):Bool {
		return StringMapNative.mem(k, m);
	}

	public static inline function find<V>(k:String, m:StringMap<V>):V {
		return StringMapNative.find(k, m);
	}

	public static inline function findOpt<V>(k:String, m:StringMap<V>):Option<V> {
		return StringMapNative.find_opt(k, m);
	}

	public static inline function iter<V>(f:String->V->Void, m:StringMap<V>):Void {
		StringMapNative.iter(f, m);
	}

	public static inline function fold<V, A>(f:String->V->A->A, m:StringMap<V>, init:A):A {
		return StringMapNative.fold(f, m, init);
	}
}

@:noCompletion
@:native("OcamlNativeStringMap")
extern class StringMapNative {
	// OCaml: `val empty : 'a t`
	static var empty:Dynamic;

	static function is_empty<V>(m:StringMap<V>):Bool;
	static function add<V>(k:String, v:V, m:StringMap<V>):StringMap<V>;
	static function remove<V>(k:String, m:StringMap<V>):StringMap<V>;
	static function mem<V>(k:String, m:StringMap<V>):Bool;
	static function find<V>(k:String, m:StringMap<V>):V;
	static function find_opt<V>(k:String, m:StringMap<V>):Option<V>;
	static function iter<V>(f:String->V->Void, m:StringMap<V>):Void;
	static function fold<V, A>(f:String->V->A->A, m:StringMap<V>, init:A):A;
}

package reflaxe.ocaml.runtimegen;

#if (macro || reflaxe_runtime)
import reflaxe.output.OutputManager;

/**
 * Emits small, pre-instantiated OCaml modules for functorized Stdlib APIs.
 *
 * Today this focuses on `Stdlib.Map`/`Stdlib.Set`, which are only accessible through functors
 * (`Map.Make` / `Set.Make`). Haxe cannot express OCaml functor application directly, so we
 * generate a few "defunctorized" modules that downstream Haxe code can target via externs.
 *
 * The intent is to provide an OCaml-native surface that can interop with libraries expecting
 * concrete `XMap.t` / `XSet.t` types, without forcing users into `untyped __ocaml__` blocks.
 */
class OcamlNativeFunctorEmitter {
	static inline final HEADER = "(* Generated by reflaxe.ocaml (OCaml-native functor instantiations) *)";
	static inline final LINE_DIRECTIVE_DISABLE_DEFINE = "ocaml_no_line_directives";

	static function escapeLineDirectivePath(path:String):String {
		if (path == null)
			return "";
		return StringTools.replace(StringTools.replace(path, "\\", "\\\\"), "\"", "\\\"");
	}

	static function maybeLineDirective(fileName:String):Null<String> {
		#if macro
		return !haxe.macro.Context.defined(LINE_DIRECTIVE_DISABLE_DEFINE) ? ("# 1 \"" + escapeLineDirectivePath(fileName) + "\"") : null;
		#else
		return null;
		#end
	}

	public static function emitMapSet(output:OutputManager):Void {
		emitMap(output, "OcamlNativeStringMap", "string");
		emitMap(output, "OcamlNativeIntMap", "int");

		emitSet(output, "OcamlNativeStringSet", "string");
		emitSet(output, "OcamlNativeIntSet", "int");
	}

	static function emitMap(output:OutputManager, moduleName:String, keyType:String):Void {
		// Use Stdlib.compare to avoid relying on `Stdlib.Int` / `Stdlib.String` module availability
		// across OCaml versions, while still producing a lawful ordering for `int`/`string`.
		final fileName = moduleName + ".ml";
		final lines = [
			maybeLineDirective(fileName),
			HEADER,
			"",
			"module Key = struct",
			"  type t = " + keyType,
			"  let compare = Stdlib.compare",
			"end",
			"",
			"include Stdlib.Map.Make(Key)",
			""
		];
		lines.remove(null);
		output.saveFile(fileName, lines.join("\n"));
	}

	static function emitSet(output:OutputManager, moduleName:String, keyType:String):Void {
		final fileName = moduleName + ".ml";
		final lines = [
			maybeLineDirective(fileName),
			HEADER,
			"",
			"module Key = struct",
			"  type t = " + keyType,
			"  let compare = Stdlib.compare",
			"end",
			"",
			"include Stdlib.Set.Make(Key)",
			""
		];
		lines.remove(null);
		output.saveFile(fileName, lines.join("\n"));
	}
}
#end

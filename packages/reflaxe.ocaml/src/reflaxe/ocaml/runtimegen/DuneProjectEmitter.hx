package reflaxe.ocaml.runtimegen;

#if (macro || reflaxe_runtime)
import haxe.io.Path;
import reflaxe.output.OutputManager;

typedef DuneProjectConfig = {
	final projectName:String;
	final exeName:String;
	final mainModuleId:Null<String>;
	final duneLibraries:Array<String>;

	/**
		Controls the dune layout emitted for the output directory.

		- `"exe"` (default): emit an executable project.
		- `"lib"`: emit a library-only project (no entry module).

		Additional layouts can be added later (e.g. lib+bin split).
	**/
	final duneLayout:Null<String>;

	/**
		Optional multi-executable configuration.

		If set and non-empty, the emitter generates a single `(executables ...)` stanza
		and writes one entry module per `name` (`name.ml`).

		Each entry module calls `<mainModuleId>.main ()` if provided.
	**/
	final executables:Null<Array<{name:String, mainModuleId:Null<String>}>>;
}

class DuneProjectEmitter {
	static inline final RUNTIME_LIB_NAME = "hx_runtime";
	static inline final LINE_DIRECTIVE_DISABLE_DEFINE = "ocaml_no_line_directives";

	static function escapeLineDirectivePath(path:String):String {
		if (path == null)
			return "";
		return StringTools.replace(StringTools.replace(path, "\\", "\\\\"), "\"", "\\\"");
	}

	public static function ocamlModuleNameFromHaxeModuleId(id:String):String {
		if (id == null || id.length == 0)
			return "Main";
		// OCaml module name is derived from filename; ensure leading uppercase.
		final first = id.charCodeAt(0);
		final isLower = first >= 97 && first <= 122;
		return isLower ? (String.fromCharCode(first - 32) + id.substr(1)) : id;
	}

	public static function defaultProjectName(outDir:String):String {
		final base = Path.withoutDirectory(Path.normalize(outDir));
		return sanitizeName(base.length > 0 ? base : "ocaml_app");
	}

	public static function defaultExeName(outDir:String):String {
		// Keep executable name lowercase to match dune conventions.
		return sanitizeName(defaultProjectName(outDir)).toLowerCase();
	}

	static function sanitizeName(name:String):String {
		final out = new StringBuf();
		for (i in 0...name.length) {
			final c = name.charCodeAt(i);
			final isAlphaNum = (c >= 97 && c <= 122) // a-z
				|| (c >= 65 && c <= 90) // A-Z
				|| (c >= 48 && c <= 57); // 0-9
			out.add(isAlphaNum ? String.fromCharCode(c) : "_");
		}
		var s = out.toString();
		if (s.length == 0)
			s = "ocaml_app";
		if (s.charCodeAt(0) >= 48 && s.charCodeAt(0) <= 57) {
			s = "_" + s;
		}
		return s;
	}

	public static function emit(output:OutputManager, cfg:DuneProjectConfig):Void {
		final projectName = cfg.projectName;
		final exeName = cfg.exeName;
		final duneLayout = cfg.duneLayout != null ? StringTools.trim(cfg.duneLayout).toLowerCase() : "exe";
		final duneLibs = cfg.duneLibraries != null ? cfg.duneLibraries.filter(s -> s != null && StringTools.trim(s).length > 0) : [];
		final duneLibLine = duneLibs.length > 0 ? (" (libraries " + duneLibs.join(" ") + ")") : null;

		output.saveFile(".gitignore", "_build/\n*.install\n");

		output.saveFile("dune-project", [
			// Keep language version conservative for distro-provided dune (e.g. Debian bookworm ships 2.9.x).
			"(lang dune 2.9)",
			"(name " + projectName + ")",
			// Disable dune's executable-wrapping so we can rely on record-label method dispatch
			// across compilation units without fighting `-open Dune__exe -no-alias-deps`.
			"(wrapped_executables false)",
			"",
			"; Generated by reflaxe.ocaml"
		].join("\n"));

		// Runtime library (M6): built from sources copied into `runtime/`.
		final runtimeDuneLines = [
			"(library",
			" (name " + RUNTIME_LIB_NAME + ")",
			" (wrapped false)",
			" (modules :standard)"
		];
		if (duneLibLine != null)
			runtimeDuneLines.push(duneLibLine);
		runtimeDuneLines.push(")");
		runtimeDuneLines.push("");
		runtimeDuneLines.push("; Generated by reflaxe.ocaml");
		output.saveFile("runtime/dune", runtimeDuneLines.join("\n"));

		final exeLibs = [RUNTIME_LIB_NAME].concat(duneLibs);

		inline function emitEntry(name:String, mainModuleId:Null<String>):Void {
			// Entry module: dune expects `<name>.ml` to exist for `(name ...)`.
			final mainModuleName = mainModuleId != null ? ocamlModuleNameFromHaxeModuleId(mainModuleId) : null;
			final entryBody = if (mainModuleName != null) {
				[
					"let () =",
					"  HxTypeRegistry.init ();",
					"  ignore (" + mainModuleName + ".main ())",
					""
				].join("\n");
			} else {
				"let () = ()\n";
			}
			#if macro
			final useLineDirectives = !haxe.macro.Context.defined(LINE_DIRECTIVE_DISABLE_DEFINE);
			#else
			final useLineDirectives = false;
			#end
			final entryFile = name + ".ml";
			final content = (useLineDirectives ? ("# 1 \"" + escapeLineDirectivePath(entryFile) + "\"\n") : "") + entryBody;
			output.saveFile(entryFile, content);
		}

		switch (duneLayout) {
			case "lib" | "library":
				output.saveFile("dune", [
					"(library",
					" (name " + projectName + ")",
					" (wrapped false)",
					" (modules :standard)",
					" (libraries " + exeLibs.join(" ") + "))",
					"",
					"; Generated by reflaxe.ocaml"
				].join("\n"));
			// No entry module in library-only mode.
			case _:
				final exes = cfg.executables != null ? cfg.executables.filter(e -> e != null && e.name != null && StringTools.trim(e.name).length > 0) : [];
				if (exes.length > 0) {
					final names = exes.map(e -> StringTools.trim(e.name));
					output.saveFile("dune", [
						"(executables",
						" (names " + names.join(" ") + ")",
						" (modules :standard)",
						" (libraries " + exeLibs.join(" ") + ")",
						" (modes (native exe) (byte exe)))",
						"",
						"; Generated by reflaxe.ocaml"
					].join("\n"));
					for (e in exes)
						emitEntry(StringTools.trim(e.name), e.mainModuleId);
				} else {
					output.saveFile("dune", [
						"(executable",
						" (name " + exeName + ")",
						" (modules :standard)",
						" (libraries " + exeLibs.join(" ") + ")",
						" (modes (native exe) (byte exe)))",
						"",
						"; Generated by reflaxe.ocaml"
					].join("\n"));
					emitEntry(exeName, cfg.mainModuleId);
				}
		}
	}
}
#end

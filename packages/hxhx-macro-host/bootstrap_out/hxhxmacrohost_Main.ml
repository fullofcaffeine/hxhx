# 1 "hxhxmacrohost_Main.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhxmacrohost.Main *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhxmacrohost.Main" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhxmacrohost.Main" } : t)

let safeReadLine = fun () -> try try raise (HxRuntime.Hx_return (Obj.repr (try input_line stdin with End_of_file -> Obj.magic (HxRuntime.hx_null)))) with
  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
  | HxRuntime.Hx_return __ret_3 -> raise (HxRuntime.Hx_return __ret_3)
  | HxRuntime.Hx_exception (__exn_v_4, __exn_tags_5) -> if true then let _hx = (__exn_v_4 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else HxRuntime.hx_throw_typed __exn_v_4 __exn_tags_5
  | __exn_6 -> if true then let _hx = (Obj.repr __exn_6 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else raise (__exn_6) with
  | HxRuntime.Hx_return __ret_7 -> Obj.obj __ret_7

let expandExprMacro = fun expr -> try let tempString = ref "" in (
  ignore (if expr == Obj.magic (HxRuntime.hx_null) then let __assign_62 = "" in (
    tempString := __assign_62;
    __assign_62
  ) else let __assign_63 = StringTools.trim expr in (
    tempString := __assign_63;
    __assign_63
  ));
  ignore (if HxString.length (!tempString) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "macro.expandExpr: empty expr") ["Dynamic"; "String"]) else ());
  let ext = Hxhxmacrohost_EntryPoints.run (!tempString) in (
    ignore (if ext != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ext)) else ());
    ignore (match !tempString with
      | "HelperMacros.getCompilationDate()" | "unit.HelperMacros.getCompilationDate()" -> raise (HxRuntime.Hx_return (Obj.repr "\"<compilation-date>\""))
      | _ -> ignore ());
    HxType.hx_throw_typed_rtti (Obj.repr ("macro.expandExpr: expr not registered: " ^ HxString.toStdString (!tempString))) ["Dynamic"; "String"]
  )
) with
  | HxRuntime.Hx_return __ret_64 -> Obj.obj __ret_64

let parseOneStringLiteralArg = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let t = StringTools.trim s in (
    ignore (if HxString.length t < 2 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let q = HxString.charCodeAt t 0 in (
      ignore (if not (let __nullable_65 = q in if __nullable_65 == HxRuntime.hx_null then false else Obj.obj __nullable_65 = 34) && not (let __nullable_66 = q in if __nullable_66 == HxRuntime.hx_null then false else Obj.obj __nullable_66 = 39) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      ignore (if not (let __nullable_67 = HxString.charCodeAt t (HxInt.sub (HxString.length t) 1) in let __nullable_68 = q in if __nullable_67 == HxRuntime.hx_null then __nullable_67 == HxRuntime.hx_null && __nullable_68 == HxRuntime.hx_null else not (__nullable_68 == HxRuntime.hx_null) && Obj.obj __nullable_67 = Obj.obj __nullable_68) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      let body = HxString.substr t 1 (HxInt.sub (HxString.length t) 2) in let body = StringTools.replace body "\\\\" "\\" in let body = StringTools.replace body "\\\"" "\"" in let body = StringTools.replace body "\\'" "'" in body
    )
  )
) with
  | HxRuntime.Hx_return __ret_69 -> Obj.obj __ret_69

let runMacroExpr = fun expr -> try let tempString = ref "" in (
  ignore (if expr == Obj.magic (HxRuntime.hx_null) then let __assign_50 = "" in (
    tempString := __assign_50;
    __assign_50
  ) else let __assign_51 = StringTools.trim expr in (
    tempString := __assign_51;
    __assign_51
  ));
  ignore (if StringTools.startsWith (!tempString) "include(" && StringTools.endsWith (!tempString) ")" then ignore (let inside = StringTools.trim (HxString.substr (!tempString) (HxString.length "include(") (HxInt.sub (HxInt.sub (HxString.length (!tempString)) (HxString.length "include(")) 1)) in let moduleName = parseOneStringLiteralArg inside in if moduleName != Obj.magic (HxRuntime.hx_null) && HxString.length moduleName > 0 then ignore ((
    ignore (Hxhxmacrohost_api_Compiler.includeModule moduleName);
    raise (HxRuntime.Hx_return (Obj.repr "include=ok"))
  )) else ()) else ());
  let tempMaybeString = ref (Obj.magic ()) in (
    ignore (match !tempString with
      | "BuiltinMacros.addCpFromEnv()" | "hxhxmacrohost.BuiltinMacros.addCpFromEnv()" -> let __assign_53 = Hxhxmacrohost_BuiltinMacros.addCpFromEnv () in (
        tempMaybeString := __assign_53;
        __assign_53
      )
      | "BuiltinMacros.dumpDefines()" | "hxhxmacrohost.BuiltinMacros.dumpDefines()" -> let __assign_54 = Hxhxmacrohost_BuiltinMacros.dumpDefines () in (
        tempMaybeString := __assign_54;
        __assign_54
      )
      | "BuiltinMacros.fail()" | "hxhxmacrohost.BuiltinMacros.fail()" -> let __assign_55 = Hxhxmacrohost_BuiltinMacros.fail () in (
        tempMaybeString := __assign_55;
        __assign_55
      )
      | "BuiltinMacros.genHxModule()" | "hxhxmacrohost.BuiltinMacros.genHxModule()" -> let __assign_56 = Hxhxmacrohost_BuiltinMacros.genHxModule () in (
        tempMaybeString := __assign_56;
        __assign_56
      )
      | "BuiltinMacros.genModule()" | "hxhxmacrohost.BuiltinMacros.genModule()" -> let __assign_57 = Hxhxmacrohost_BuiltinMacros.genModule () in (
        tempMaybeString := __assign_57;
        __assign_57
      )
      | "BuiltinMacros.readFlag()" | "hxhxmacrohost.BuiltinMacros.readFlag()" -> let __assign_58 = Hxhxmacrohost_BuiltinMacros.readFlag () in (
        tempMaybeString := __assign_58;
        __assign_58
      )
      | "BuiltinMacros.registerHooks()" | "hxhxmacrohost.BuiltinMacros.registerHooks()" -> let __assign_59 = Hxhxmacrohost_BuiltinMacros.registerHooks () in (
        tempMaybeString := __assign_59;
        __assign_59
      )
      | "BuiltinMacros.smoke()" | "hxhxmacrohost.BuiltinMacros.smoke()" -> let __assign_60 = Hxhxmacrohost_BuiltinMacros.smoke () in (
        tempMaybeString := __assign_60;
        __assign_60
      )
      | _ -> let __assign_52 = Obj.magic (HxRuntime.hx_null) in (
        tempMaybeString := __assign_52;
        __assign_52
      ));
    ignore (if !tempMaybeString != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (!tempMaybeString))) else ());
    let ext = Hxhxmacrohost_EntryPoints.run (!tempString) in (
      ignore (if ext != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ext)) else ());
      "ran:" ^ HxString.toStdString (!tempString)
    )
  )
) with
  | HxRuntime.Hx_return __ret_61 -> Obj.obj __ret_61

let parseKV = fun tail -> Hxhxmacrohost_Protocol.kvParse tail

let parseDecInt = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length s && (let __nullable_70 = HxString.charCodeAt s (!i) in if __nullable_70 == HxRuntime.hx_null then false else Obj.obj __nullable_70 = 32) do ignore (let __old_71 = !i in let __new_72 = HxInt.add __old_71 1 in (
      ignore (i := __new_72);
      __old_71
    )) done);
    ignore (if !i >= HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_73 = c in let __nullable_74 = 48 in if __nullable_73 == HxRuntime.hx_null then false else Obj.obj __nullable_73 < __nullable_74) || (let __nullable_75 = c in let __nullable_76 = 57 in if __nullable_75 == HxRuntime.hx_null then false else Obj.obj __nullable_75 > __nullable_76) then raise (HxRuntime.Hx_break) else ());
        ignore (let __assign_77 = true in (
          saw := __assign_77;
          __assign_77
        ));
        ignore (let __assign_78 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_79 = c in if __nullable_int_79 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_79) 48) in (
          value := __assign_78;
          __assign_78
        ));
        let __old_80 = !i in let __new_81 = HxInt.add __old_80 1 in (
          ignore (i := __new_81);
          __old_80
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let tempResult = ref 0 in (
        ignore (if !saw then let __assign_82 = !value in (
          tempResult := __assign_82;
          __assign_82
        ) else let __assign_83 = -1 in (
          tempResult := __assign_83;
          __assign_83
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_84 -> Obj.obj __ret_84

let flushStdout = fun () -> let __obj_87 = Sys_io_Stdio.stdout () in __obj_87.flush (Obj.magic __obj_87) ()

let replyOk = fun id tail -> (
  ignore (print_endline ((("res " ^ string_of_int id) ^ " ok ") ^ HxString.toStdString tail));
  flushStdout ()
)

let replyErr = fun id msg pos -> let tempString = ref "" in (
  ignore (if pos == Obj.magic (HxRuntime.hx_null) then let __assign_85 = "" in (
    tempString := __assign_85;
    __assign_85
  ) else let __assign_86 = (HxString.toStdString (Obj.obj (HxAnon.get pos "fileName")) ^ ":") ^ string_of_int (Obj.obj (HxAnon.get pos "lineNumber")) in (
    tempString := __assign_86;
    __assign_86
  ));
  ignore (print_endline ((((("res " ^ string_of_int id) ^ " err ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "m" msg)) ^ " ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "p" (!tempString))));
  flushStdout ()
)

let handleReq = fun line -> try let parts = Hxhxmacrohost_Protocol.splitN line 3 in let tempNumber = ref 0 in (
  ignore (if HxArray.length parts > 1 then let __assign_8 = parseDecInt (HxArray.get parts 1) in (
    tempNumber := __assign_8;
    __assign_8
  ) else let __assign_9 = -1 in (
    tempNumber := __assign_9;
    __assign_9
  ));
  let id = !tempNumber in let tempString = ref "" in (
    ignore (if HxArray.length parts > 2 then let __assign_10 = HxArray.get parts 2 in (
      tempString := __assign_10;
      __assign_10
    ) else let __assign_11 = "" in (
      tempString := __assign_11;
      __assign_11
    ));
    let tempString1 = ref "" in (
      ignore (if HxArray.length parts > 3 then let __assign_12 = HxArray.get parts 3 in (
        tempString1 := __assign_12;
        __assign_12
      ) else let __assign_13 = "" in (
        tempString1 := __assign_13;
        __assign_13
      ));
      ignore (if id < 0 then ignore ((
        ignore (replyErr 0 "missing id" (let __anon_14 = HxAnon.create () in (
          ignore (HxAnon.set __anon_14 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
          ignore (HxAnon.set __anon_14 "lineNumber" (Obj.repr 82));
          ignore (HxAnon.set __anon_14 "className" (Obj.repr "hxhxmacrohost.Main"));
          ignore (HxAnon.set __anon_14 "methodName" (Obj.repr "handleReq"));
          __anon_14
        )));
        raise (HxRuntime.Hx_return (Obj.repr ()))
      )) else ());
      try match !tempString with
        | "compiler.define" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "n" then let __assign_16 = HxMap.get_string parsed "n" in (
            tempMaybeString := __assign_16;
            __assign_16
          ) else let __assign_17 = "" in (
            tempMaybeString := __assign_17;
            __assign_17
          ));
          let name = !tempMaybeString in let tempMaybeString1 = ref (Obj.magic ()) in (
            ignore (if HxMap.exists_string parsed "v" then let __assign_18 = HxMap.get_string parsed "v" in (
              tempMaybeString1 := __assign_18;
              __assign_18
            ) else let __assign_19 = "" in (
              tempMaybeString1 := __assign_19;
              __assign_19
            ));
            let value = !tempMaybeString1 in (
              ignore (if HxString.length name = 0 then ignore ((
                ignore (replyErr id (HxString.toStdString (!tempString) ^ ": missing name") (let __anon_20 = HxAnon.create () in (
                  ignore (HxAnon.set __anon_20 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                  ignore (HxAnon.set __anon_20 "lineNumber" (Obj.repr 95));
                  ignore (HxAnon.set __anon_20 "className" (Obj.repr "hxhxmacrohost.Main"));
                  ignore (HxAnon.set __anon_20 "methodName" (Obj.repr "handleReq"));
                  __anon_20
                )));
                raise (HxRuntime.Hx_return (Obj.repr ()))
              )) else ());
              ignore (Hxhxmacrohost_api_Compiler.define name value);
              replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" "ok")
            )
          )
        ))
        | "context.defined" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString2 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "n" then let __assign_21 = HxMap.get_string parsed "n" in (
            tempMaybeString2 := __assign_21;
            __assign_21
          ) else let __assign_22 = "" in (
            tempMaybeString2 := __assign_22;
            __assign_22
          ));
          let name = !tempMaybeString2 in let tempString2 = ref "" in (
            ignore (if Hxhxmacrohost_api_Context.defined name then let __assign_23 = "1" in (
              tempString2 := __assign_23;
              __assign_23
            ) else let __assign_24 = "0" in (
              tempString2 := __assign_24;
              __assign_24
            ));
            replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" (!tempString2))
          )
        ))
        | "context.definedValue" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString3 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "n" then let __assign_25 = HxMap.get_string parsed "n" in (
            tempMaybeString3 := __assign_25;
            __assign_25
          ) else let __assign_26 = "" in (
            tempMaybeString3 := __assign_26;
            __assign_26
          ));
          let name = !tempMaybeString3 in replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" (Hxhxmacrohost_api_Context.definedValue name))
        ))
        | "context.getType" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString4 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "n" then let __assign_27 = HxMap.get_string parsed "n" in (
            tempMaybeString4 := __assign_27;
            __assign_27
          ) else let __assign_28 = "" in (
            tempMaybeString4 := __assign_28;
            __assign_28
          ));
          let name = !tempMaybeString4 in (
            ignore (if HxString.length name = 0 then ignore ((
              ignore (replyErr id (HxString.toStdString (!tempString) ^ ": missing name") (let __anon_29 = HxAnon.create () in (
                ignore (HxAnon.set __anon_29 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                ignore (HxAnon.set __anon_29 "lineNumber" (Obj.repr 161));
                ignore (HxAnon.set __anon_29 "className" (Obj.repr "hxhxmacrohost.Main"));
                ignore (HxAnon.set __anon_29 "methodName" (Obj.repr "handleReq"));
                __anon_29
              )));
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" (Hxhxmacrohost_api_Context.getType name))
          )
        ))
        | "macro.expandExpr" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString5 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "e" then let __assign_30 = HxMap.get_string parsed "e" in (
            tempMaybeString5 := __assign_30;
            __assign_30
          ) else let __assign_31 = "" in (
            tempMaybeString5 := __assign_31;
            __assign_31
          ));
          let expr = !tempMaybeString5 in (
            ignore (if HxString.length expr = 0 then ignore ((
              ignore (replyErr id (HxString.toStdString (!tempString) ^ ": missing expr") (let __anon_32 = HxAnon.create () in (
                ignore (HxAnon.set __anon_32 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                ignore (HxAnon.set __anon_32 "lineNumber" (Obj.repr 136));
                ignore (HxAnon.set __anon_32 "className" (Obj.repr "hxhxmacrohost.Main"));
                ignore (HxAnon.set __anon_32 "methodName" (Obj.repr "handleReq"));
                __anon_32
              )));
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" (expandExprMacro expr))
          )
        ))
        | "macro.run" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString6 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "e" then let __assign_33 = HxMap.get_string parsed "e" in (
            tempMaybeString6 := __assign_33;
            __assign_33
          ) else let __assign_34 = "" in (
            tempMaybeString6 := __assign_34;
            __assign_34
          ));
          let expr = !tempMaybeString6 in (
            ignore (if HxString.length expr = 0 then ignore ((
              ignore (replyErr id (HxString.toStdString (!tempString) ^ ": missing expr") (let __anon_35 = HxAnon.create () in (
                ignore (HxAnon.set __anon_35 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                ignore (HxAnon.set __anon_35 "lineNumber" (Obj.repr 118));
                ignore (HxAnon.set __anon_35 "className" (Obj.repr "hxhxmacrohost.Main"));
                ignore (HxAnon.set __anon_35 "methodName" (Obj.repr "handleReq"));
                __anon_35
              )));
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" (runMacroExpr expr))
          )
        ))
        | "macro.runHook" -> ignore (let parsed = parseKV (!tempString1) in let tempMaybeString7 = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string parsed "k" then let __assign_36 = HxMap.get_string parsed "k" in (
            tempMaybeString7 := __assign_36;
            __assign_36
          ) else let __assign_37 = "" in (
            tempMaybeString7 := __assign_37;
            __assign_37
          ));
          let kind = !tempMaybeString7 in let tempMaybeString8 = ref (Obj.magic ()) in (
            ignore (if HxMap.exists_string parsed "i" then let __assign_38 = HxMap.get_string parsed "i" in (
              tempMaybeString8 := __assign_38;
              __assign_38
            ) else let __assign_39 = "" in (
              tempMaybeString8 := __assign_39;
              __assign_39
            ));
            let idStr = !tempMaybeString8 in let hid = Std.parseInt idStr in (
              ignore (if HxString.length kind = 0 then ignore ((
                ignore (replyErr id (HxString.toStdString (!tempString) ^ ": missing kind") (let __anon_40 = HxAnon.create () in (
                  ignore (HxAnon.set __anon_40 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                  ignore (HxAnon.set __anon_40 "lineNumber" (Obj.repr 146));
                  ignore (HxAnon.set __anon_40 "className" (Obj.repr "hxhxmacrohost.Main"));
                  ignore (HxAnon.set __anon_40 "methodName" (Obj.repr "handleReq"));
                  __anon_40
                )));
                raise (HxRuntime.Hx_return (Obj.repr ()))
              )) else ());
              ignore (if hid == HxRuntime.hx_null then ignore ((
                ignore (replyErr id (HxString.toStdString (!tempString) ^ ": invalid hook id") (let __anon_41 = HxAnon.create () in (
                  ignore (HxAnon.set __anon_41 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
                  ignore (HxAnon.set __anon_41 "lineNumber" (Obj.repr 150));
                  ignore (HxAnon.set __anon_41 "className" (Obj.repr "hxhxmacrohost.Main"));
                  ignore (HxAnon.set __anon_41 "methodName" (Obj.repr "handleReq"));
                  __anon_41
                )));
                raise (HxRuntime.Hx_return (Obj.repr ()))
              )) else ());
              ignore (Hxhxmacrohost_MacroRuntime.runHook kind (let __nullable_int_42 = hid in if __nullable_int_42 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_42));
              replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" "ok")
            )
          )
        ))
        | "ping" -> ignore (replyOk id (Hxhxmacrohost_Protocol.encodeLen "v" "pong"))
        | _ -> ignore (replyErr id ("unknown method: " ^ HxString.toStdString (!tempString)) (let __anon_15 = HxAnon.create () in (
          ignore (HxAnon.set __anon_15 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
          ignore (HxAnon.set __anon_15 "lineNumber" (Obj.repr 166));
          ignore (HxAnon.set __anon_15 "className" (Obj.repr "hxhxmacrohost.Main"));
          ignore (HxAnon.set __anon_15 "methodName" (Obj.repr "handleReq"));
          __anon_15
        ))) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_43 -> raise (HxRuntime.Hx_return __ret_43)
        | HxRuntime.Hx_exception (__exn_v_44, __exn_tags_45) -> if true then let e = (__exn_v_44 : Obj.t) in (
          ignore e;
          let tag = HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "__hxhx_tag")) in (
            ignore (if HxString.equals tag "hxhx_macro_host_error_v1" then ignore (let msg = HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "message")) in let p = Obj.obj (HxAnon.get e "pos") in (
              ignore (replyErr id ((HxString.toStdString (!tempString) ^ ": ") ^ HxString.toStdString msg) p);
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            replyErr id ((HxString.toStdString (!tempString) ^ ": exception: ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) (let __anon_46 = HxAnon.create () in (
              ignore (HxAnon.set __anon_46 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
              ignore (HxAnon.set __anon_46 "lineNumber" (Obj.repr 177));
              ignore (HxAnon.set __anon_46 "className" (Obj.repr "hxhxmacrohost.Main"));
              ignore (HxAnon.set __anon_46 "methodName" (Obj.repr "handleReq"));
              __anon_46
            ))
          )
        ) else HxRuntime.hx_throw_typed __exn_v_44 __exn_tags_45
        | __exn_47 -> if true then let e = (Obj.repr __exn_47 : Obj.t) in (
          ignore e;
          let tag = HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "__hxhx_tag")) in (
            ignore (if HxString.equals tag "hxhx_macro_host_error_v1" then ignore (let msg = HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "message")) in let p = Obj.obj (HxAnon.get e "pos") in (
              ignore (replyErr id ((HxString.toStdString (!tempString) ^ ": ") ^ HxString.toStdString msg) p);
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            replyErr id ((HxString.toStdString (!tempString) ^ ": exception: ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) (let __anon_48 = HxAnon.create () in (
              ignore (HxAnon.set __anon_48 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
              ignore (HxAnon.set __anon_48 "lineNumber" (Obj.repr 177));
              ignore (HxAnon.set __anon_48 "className" (Obj.repr "hxhxmacrohost.Main"));
              ignore (HxAnon.set __anon_48 "methodName" (Obj.repr "handleReq"));
              __anon_48
            ))
          )
        ) else raise (__exn_47)
    )
  )
) with
  | HxRuntime.Hx_return __ret_49 -> Obj.obj __ret_49

let main = fun () -> try (
  ignore (print_endline ("hxhx_macro_rpc_v=" ^ string_of_int 1));
  ignore (flushStdout ());
  let hello = safeReadLine () in (
    ignore (if hello == Obj.magic (HxRuntime.hx_null) || HxString.indexOf hello "hello" 0 <> 0 then ignore ((
      ignore (print_endline ("err " ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "m" "missing hello")));
      raise (HxRuntime.Hx_return (Obj.repr ()))
    )) else ());
    ignore (if HxString.indexOf hello ("proto=" ^ string_of_int 1) 0 = -1 then ignore ((
      ignore (print_endline ("err " ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "m" "unsupported proto")));
      raise (HxRuntime.Hx_return (Obj.repr ()))
    )) else ());
    ignore (print_endline "ok");
    ignore (flushStdout ());
    try while true do try ignore (let line = safeReadLine () in (
      ignore (if line == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
      let trimmed = StringTools.trim line in (
        ignore (if HxString.length trimmed = 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if HxString.equals trimmed "quit" then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
        ignore (if StringTools.startsWith trimmed "req " then ignore ((
          ignore (handleReq trimmed);
          raise (HxRuntime.Hx_continue)
        )) else ());
        replyErr 0 "unknown message" (let __anon_1 = HxAnon.create () in (
          ignore (HxAnon.set __anon_1 "fileName" (Obj.repr "src/hxhxmacrohost/Main.hx"));
          ignore (HxAnon.set __anon_1 "lineNumber" (Obj.repr 63));
          ignore (HxAnon.set __anon_1 "className" (Obj.repr "hxhxmacrohost.Main"));
          ignore (HxAnon.set __anon_1 "methodName" (Obj.repr "main"));
          __anon_1
        ))
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()
  )
) with
  | HxRuntime.Hx_return __ret_2 -> Obj.obj __ret_2
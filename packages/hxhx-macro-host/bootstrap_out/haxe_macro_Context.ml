# 1 "haxe_macro_Context.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.Message *)

type message =
| Info of string * Obj.t
| Warning of string * Obj.t

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: haxe.macro.Context *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "haxe.macro.Context" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "haxe.macro.Context" } : t)

let defined = fun key -> Hxhxmacrohost_api_Context.defined key

let definedValue = fun key -> Hxhxmacrohost_api_Context.definedValue key

let getDefines = fun () -> Hxhxmacrohost_api_Context.getDefines ()

let getBuildFields = fun () -> Hxhxmacrohost_api_Context.getBuildFields ()

let error = fun msg pos depth -> (
  ignore (if pos != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if not (let __nullable_1 = depth in if __nullable_1 == HxRuntime.hx_null then false else Obj.obj __nullable_1 = 0) then ignore () else ());
  Hxhxmacrohost_MacroError.raise msg (let __anon_2 = HxAnon.create () in (
    ignore (HxAnon.set __anon_2 "fileName" (Obj.repr "overrides/haxe/macro/Context.hx"));
    ignore (HxAnon.set __anon_2 "lineNumber" (Obj.repr 313));
    ignore (HxAnon.set __anon_2 "className" (Obj.repr "haxe.macro.Context"));
    ignore (HxAnon.set __anon_2 "methodName" (Obj.repr "error"));
    __anon_2
  ))
)

let fatalError = fun msg pos depth -> (
  ignore (if pos != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if not (let __nullable_3 = depth in if __nullable_3 == HxRuntime.hx_null then false else Obj.obj __nullable_3 = 0) then ignore () else ());
  Hxhxmacrohost_MacroError.raise msg (let __anon_4 = HxAnon.create () in (
    ignore (HxAnon.set __anon_4 "fileName" (Obj.repr "overrides/haxe/macro/Context.hx"));
    ignore (HxAnon.set __anon_4 "lineNumber" (Obj.repr 319));
    ignore (HxAnon.set __anon_4 "className" (Obj.repr "haxe.macro.Context"));
    ignore (HxAnon.set __anon_4 "methodName" (Obj.repr "fatalError"));
    __anon_4
  ))
)

let warning = fun msg pos depth -> (
  ignore (if msg != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if pos != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  if not (let __nullable_5 = depth in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 = 0) then ignore () else ()
)

let info = fun msg pos depth -> (
  ignore (if msg != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if pos != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  if not (let __nullable_6 = depth in if __nullable_6 == HxRuntime.hx_null then false else Obj.obj __nullable_6 = 0) then ignore () else ()
)

let currentPos = fun () -> Obj.magic (HxRuntime.hx_null)

let getType = fun name -> (
  ignore (if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then ignore () else ());
  Haxe_macro_Type.TDynamic (Obj.obj (HxEnum.unbox_or_obj "haxe.macro.Type" (Obj.magic (HxRuntime.hx_null))))
)

let onGenerate = fun callback persistent -> Hxhxmacrohost_api_Context.onGenerate callback persistent

let onAfterGenerate = fun callback -> Hxhxmacrohost_api_Context.onAfterGenerate callback

let onAfterTyping = fun callback -> Hxhxmacrohost_api_Context.onAfterTyping callback

let getMessages = fun () -> let __arr_7 = HxArray.create () in __arr_7

let filterMessages = fun predicate -> try if predicate == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else () with
  | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8
# 1 "haxe_macro_Expr.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.StringLiteralKind *)

type stringliteralkind =
| DoubleQuotes
| SingleQuotes

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.Constant *)

type constant =
| CInt of string * string
| CFloat of string * string
| CString of string * Obj.t
| CIdent of string
| CRegexp of string * string

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.Binop *)

type binop =
| OpAdd
| OpMult
| OpDiv
| OpSub
| OpAssign
| OpEq
| OpNotEq
| OpGt
| OpGte
| OpLt
| OpLte
| OpAnd
| OpOr
| OpXor
| OpBoolAnd
| OpBoolOr
| OpShl
| OpShr
| OpUShr
| OpMod
| OpAssignOp of binop
| OpInterval
| OpArrow
| OpIn
| OpNullCoal

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.Unop *)

type unop =
| OpIncrement
| OpDecrement
| OpNot
| OpNeg
| OpNegBits
| OpSpread

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.EFieldKind *)

type efieldkind =
| Normal
| Safe

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.QuoteStatus *)

type quotestatus =
| Unquoted
| Quoted

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.FunctionKind *)

type functionkind =
| FAnonymous
| FNamed of string * Obj.t
| FArrow

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.DisplayKind *)

type displaykind =
| DKCall
| DKDot
| DKStructure
| DKMarked
| DKPattern of bool

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.ComplexType *)

type complextype =
| TPath of Obj.t
| TFunction of complextype HxArray.t * complextype
| TAnonymous of Obj.t HxArray.t
| TParent of complextype
| TExtend of Obj.t HxArray.t * Obj.t HxArray.t
| TOptional of complextype
| TNamed of string * complextype
| TIntersection of complextype HxArray.t

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.ExprDef *)

type exprdef =
| EConst of constant
| EArray of Obj.t * Obj.t
| EBinop of binop * Obj.t * Obj.t
| EField of Obj.t * string * Obj.t
| EParenthesis of Obj.t
| EObjectDecl of Obj.t HxArray.t
| EArrayDecl of Obj.t HxArray.t
| ECall of Obj.t * Obj.t HxArray.t
| ENew of Obj.t * Obj.t HxArray.t
| EUnop of unop * bool * Obj.t
| EVars of Obj.t HxArray.t
| EFunction of Obj.t * Obj.t
| EBlock of Obj.t HxArray.t
| EFor of Obj.t * Obj.t
| EIf of Obj.t * Obj.t * Obj.t
| EWhile of Obj.t * Obj.t * bool
| ESwitch of Obj.t * Obj.t HxArray.t * Obj.t
| ETry of Obj.t * Obj.t HxArray.t
| EReturn of Obj.t
| EBreak
| EContinue
| EUntyped of Obj.t
| EThrow of Obj.t
| ECast of Obj.t * Obj.t
| EDisplay of Obj.t * displaykind
| ETernary of Obj.t * Obj.t * Obj.t
| ECheckType of Obj.t * complextype
| EMeta of Obj.t * Obj.t
| EIs of Obj.t * complextype

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.TypeParam *)

type typeparam =
| TPType of complextype
| TPExpr of Obj.t

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.Access *)

type access =
| APublic
| APrivate
| AStatic
| AOverride
| ADynamic
| AInline
| AMacro
| AFinal
| AExtern
| AAbstract
| AOverload

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.FieldType *)

type fieldtype =
| FVar of Obj.t * Obj.t
| FFun of Obj.t
| FProp of string * string * Obj.t * Obj.t

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.AbstractFlag *)

type abstractflag =
| AbEnum
| AbFrom of complextype
| AbTo of complextype

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.TypeDefKind *)

type typedefkind =
| TDEnum
| TDStructure
| TDClass of Obj.t * Obj.t HxArray.t * Obj.t * Obj.t * Obj.t
| TDAlias of complextype
| TDAbstract of Obj.t * abstractflag HxArray.t * complextype HxArray.t * complextype HxArray.t
| TDField of fieldtype * access HxArray.t

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: haxe.macro.ImportMode *)

type importmode =
| INormal
| IAsName of string
| IAll

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: haxe.macro.Error *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable message : string; mutable stack : Haxe_CallStack.stackitem HxArray.t; mutable previous : Haxe_Exception.t; mutable native : Obj.t; mutable __exceptionMessage : string; mutable __exceptionStack : Haxe_CallStack.stackitem HxArray.t; mutable __nativeStack : Obj.t; mutable __skipStack : int; mutable __nativeException : Obj.t; mutable __previousException : Haxe_Exception.t; unwrap : Obj.t -> unit -> Obj.t; toString : Obj.t -> unit -> string; details : Obj.t -> unit -> string; __shiftStack : Obj.t -> unit -> unit; __unshiftStack : Obj.t -> unit -> unit; get_message : Obj.t -> unit -> string; get_previous : Obj.t -> unit -> Haxe_Exception.t; get_native : Obj.t -> unit -> Obj.t; get_stack : Obj.t -> unit -> Haxe_CallStack.stackitem HxArray.t; mutable pos : Obj.t }

let create = fun message pos2 previous -> let self = ({ __hx_type = HxType.class_ "haxe.macro.Error"; message = ""; stack = Obj.magic (); previous = Obj.magic (); native = Obj.magic (); __exceptionMessage = ""; __exceptionStack = Obj.magic (); __nativeStack = Obj.magic (); __skipStack = 0; __nativeException = Obj.magic (); __previousException = Obj.magic (); unwrap = (fun o () -> Haxe_Exception.unwrap__impl (Obj.magic o) ()); toString = (fun o () -> Haxe_Exception.toString__impl (Obj.magic o) ()); details = (fun o () -> Haxe_Exception.details__impl (Obj.magic o) ()); __shiftStack = (fun o () -> Haxe_Exception.__shiftStack__impl (Obj.magic o) ()); __unshiftStack = (fun o () -> Haxe_Exception.__unshiftStack__impl (Obj.magic o) ()); get_message = (fun o () -> Haxe_Exception.get_message__impl (Obj.magic o) ()); get_previous = (fun o () -> Haxe_Exception.get_previous__impl (Obj.magic o) ()); get_native = (fun o () -> Haxe_Exception.get_native__impl (Obj.magic o) ()); get_stack = (fun o () -> Haxe_Exception.get_stack__impl (Obj.magic o) ()); pos = Obj.magic () } : t) in (
  ignore ((
    ignore (Haxe_Exception.__ctor (Obj.magic self) message previous (Obj.magic (HxRuntime.hx_null)));
    ignore (let __assign_1 = pos2 in (
      self.pos <- __assign_1;
      __assign_1
    ));
    let __obj_2 = self in let __old_3 = __obj_2.__skipStack in let __new_4 = HxInt.add __old_3 1 in (
      ignore (__obj_2.__skipStack <- __new_4);
      __old_3
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "haxe.macro.Error"; message = ""; stack = Obj.magic (); previous = Obj.magic (); native = Obj.magic (); __exceptionMessage = ""; __exceptionStack = Obj.magic (); __nativeStack = Obj.magic (); __skipStack = 0; __nativeException = Obj.magic (); __previousException = Obj.magic (); unwrap = (fun o () -> Haxe_Exception.unwrap__impl (Obj.magic o) ()); toString = (fun o () -> Haxe_Exception.toString__impl (Obj.magic o) ()); details = (fun o () -> Haxe_Exception.details__impl (Obj.magic o) ()); __shiftStack = (fun o () -> Haxe_Exception.__shiftStack__impl (Obj.magic o) ()); __unshiftStack = (fun o () -> Haxe_Exception.__unshiftStack__impl (Obj.magic o) ()); get_message = (fun o () -> Haxe_Exception.get_message__impl (Obj.magic o) ()); get_previous = (fun o () -> Haxe_Exception.get_previous__impl (Obj.magic o) ()); get_native = (fun o () -> Haxe_Exception.get_native__impl (Obj.magic o) ()); get_stack = (fun o () -> Haxe_Exception.get_stack__impl (Obj.magic o) ()); pos = Obj.magic () } : t)

let __ctor = fun (self : t) message pos2 previous -> ignore ((
  ignore (Haxe_Exception.__ctor (Obj.magic self) message previous (Obj.magic (HxRuntime.hx_null)));
  ignore (let __assign_1 = pos2 in (
    self.pos <- __assign_1;
    __assign_1
  ));
  let __obj_2 = self in let __old_3 = __obj_2.__skipStack in let __new_4 = HxInt.add __old_3 1 in (
    ignore (__obj_2.__skipStack <- __new_4);
    __old_3
  )
))
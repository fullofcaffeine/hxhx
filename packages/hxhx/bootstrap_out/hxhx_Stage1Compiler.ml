# 1 "hxhx_Stage1Compiler.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Stage1Args *)

let __reflaxe_ocaml__ = ()

type stage1args_t = { __hx_type : Obj.t; mutable classPaths : string HxArray.t; mutable main : string; mutable noOutput : bool; mutable roots : string HxArray.t; mutable defines : string HxArray.t; mutable libs : string HxArray.t; mutable macros : string HxArray.t; mutable displayRequest : string; mutable cwd : string; mutable hadCmd : bool }

let stage1args_create = fun classPaths2 main2 noOutput2 roots2 defines2 libs2 macros2 displayRequest2 cwd2 hadCmd2 -> let self = ({ __hx_type = HxType.class_ "hxhx.Stage1Args"; classPaths = Obj.magic (); main = ""; noOutput = false; roots = Obj.magic (); defines = Obj.magic (); libs = Obj.magic (); macros = Obj.magic (); displayRequest = Obj.magic (); cwd = ""; hadCmd = false } : stage1args_t) in (
  ignore ((
    ignore (let __assign_1 = classPaths2 in (
      self.classPaths <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = main2 in (
      self.main <- __assign_2;
      __assign_2
    ));
    ignore (let __assign_3 = noOutput2 in (
      self.noOutput <- __assign_3;
      __assign_3
    ));
    ignore (let __assign_4 = roots2 in (
      self.roots <- __assign_4;
      __assign_4
    ));
    ignore (let __assign_5 = defines2 in (
      self.defines <- __assign_5;
      __assign_5
    ));
    ignore (let __assign_6 = libs2 in (
      self.libs <- __assign_6;
      __assign_6
    ));
    ignore (let __assign_7 = macros2 in (
      self.macros <- __assign_7;
      __assign_7
    ));
    ignore (let __assign_8 = displayRequest2 in (
      self.displayRequest <- __assign_8;
      __assign_8
    ));
    ignore (let __assign_9 = cwd2 in (
      self.cwd <- __assign_9;
      __assign_9
    ));
    let __assign_10 = hadCmd2 in (
      self.hadCmd <- __assign_10;
      __assign_10
    )
  ));
  self
)

let stage1args___empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Stage1Args"; classPaths = Obj.magic (); main = ""; noOutput = false; roots = Obj.magic (); defines = Obj.magic (); libs = Obj.magic (); macros = Obj.magic (); displayRequest = Obj.magic (); cwd = ""; hadCmd = false } : stage1args_t)

let stage1args_inferStdRoot = fun () -> try (
  ignore (try let direct = HxSys.getEnv "HAXE_STD_PATH" in (
    ignore (if direct != Obj.magic (HxRuntime.hx_null) && HxString.length direct > 0 && HxFileSystem.exists direct && HxFileSystem.isDirectory direct then raise (HxRuntime.Hx_return (Obj.repr direct)) else ());
    let haxePath = HxSys.getEnv "HAXEPATH" in if haxePath != Obj.magic (HxRuntime.hx_null) && HxString.length haxePath > 0 then ignore (let candidate = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_23 = HxArray.create () in (
      ignore (HxArray.push __arr_23 haxePath);
      ignore (HxArray.push __arr_23 "std");
      __arr_23
    ))) in if HxFileSystem.exists candidate && HxFileSystem.isDirectory candidate then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()) else ()
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_24 -> raise (HxRuntime.Hx_return __ret_24)
    | HxRuntime.Hx_exception (__exn_v_25, __exn_tags_26) -> if HxRuntime.tags_has __exn_tags_26 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_25) : Haxe_io_Error.error) in (
      ignore _hx;
      ()
    ) else if HxRuntime.tags_has __exn_tags_26 "String" then let _hx = (Obj.obj __exn_v_25 : string) in (
      ignore _hx;
      ()
    ) else HxRuntime.hx_throw_typed __exn_v_25 __exn_tags_26
    | __exn_27 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_27)) : Haxe_io_Error.error) in (
      ignore _hx;
      ()
    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_27) : string) in (
      ignore _hx;
      ()
    ) else raise (__exn_27));
  ""
) with
  | HxRuntime.Hx_return __ret_28 -> Obj.obj __ret_28

let stage1args_expandHxmlArgs = fun args -> try let sawHxml = ref false in let out = HxArray.create () in let _g = ref 0 in (
  ignore (try while !_g < HxArray.length args do try ignore (let a = HxArray.get args (!_g) in (
    ignore (let __old_29 = !_g in let __new_30 = HxInt.add __old_29 1 in (
      ignore (_g := __new_30);
      __new_30
    ));
    ignore (if a == Obj.magic (HxRuntime.hx_null) || HxString.length a = 0 then raise (HxRuntime.Hx_continue) else ());
    ignore (if not (StringTools.startsWith a "-") && StringTools.endsWith a ".hxml" then ignore ((
      ignore (let __assign_31 = true in (
        sawHxml := __assign_31;
        __assign_31
      ));
      ignore (if not (HxFileSystem.exists a) || HxFileSystem.isDirectory a then ignore ((
        ignore (print_endline ("hxhx(stage1): hxml path is not a file: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )) else ());
      let expanded = Hxhx_Hxml.parseFile a in (
        ignore (if expanded == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
        let _g2 = ref 0 in (
          ignore (while !_g2 < HxArray.length expanded do ignore (let t = HxArray.get expanded (!_g2) in (
            ignore (let __old_32 = !_g2 in let __new_33 = HxInt.add __old_32 1 in (
              ignore (_g2 := __new_33);
              __new_33
            ));
            HxArray.push out t
          )) done);
          raise (HxRuntime.Hx_continue)
        )
      )
    )) else ());
    HxArray.push out a
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (if !sawHxml then let __assign_34 = out in (
      tempResult := __assign_34;
      __assign_34
    ) else let __assign_35 = args in (
      tempResult := __assign_35;
      __assign_35
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_36 -> Obj.obj __ret_36

let stage1args_parse = fun args permissive -> try let expanded = stage1args_expandHxmlArgs args in (
  ignore (if expanded == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let classPaths2 = HxArray.create () in let main2 = ref "" in let noOutput2 = ref false in let roots2 = HxArray.create () in let defines2 = HxArray.create () in let libs2 = HxArray.create () in let macros2 = HxArray.create () in let displayRequest2 = ref (Obj.magic (HxRuntime.hx_null)) in let cwd2 = ref "." in let stdRoot = ref "" in let hadCmd2 = ref false in let i = ref 0 in (
    ignore (try while !i < HxArray.length expanded do try ignore (let a = HxArray.get expanded (!i) in match a with
      | "--" -> ignore ((
        ignore (print_endline "hxhx(stage1): unexpected '--' separator");
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      ))
      | "--class-path" | "-cp" | "-p" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push classPaths2 (HxArray.get expanded (HxInt.add (!i) 1)));
        i := HxInt.add (!i) 2
      ))
      | "--cmd" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --cmd");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_11 = true in (
          hadCmd2 := __assign_11;
          __assign_11
        ));
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--cwd" | "-C" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_12 = HxArray.get expanded (HxInt.add (!i) 1) in (
          cwd2 := __assign_12;
          __assign_12
        ));
        i := HxInt.add (!i) 2
      ))
      | "--dce" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --dce");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push defines2 ("dce=" ^ HxString.toStdString (HxArray.get expanded (HxInt.add (!i) 1))));
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--debug" -> ignore (if permissive then ignore ((
        ignore (HxArray.push defines2 "debug=1");
        i := HxInt.add (!i) 1
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--display" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --display");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_13 = HxArray.get expanded (HxInt.add (!i) 1) in (
          displayRequest2 := __assign_13;
          __assign_13
        ));
        ignore (HxArray.push defines2 "display=1");
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--interp" -> ignore (if permissive then ignore ((
        ignore (HxArray.push defines2 "interp=1");
        i := HxInt.add (!i) 1
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--library" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --library");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push libs2 (HxArray.get expanded (HxInt.add (!i) 1)));
        i := HxInt.add (!i) 2
      ))
      | "--macro" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --macro");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push macros2 (HxArray.get expanded (HxInt.add (!i) 1)));
        i := HxInt.add (!i) 2
      ))
      | "--main" | "-main" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after -main");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_14 = HxArray.get expanded (HxInt.add (!i) 1) in (
          main2 := __assign_14;
          __assign_14
        ));
        i := HxInt.add (!i) 2
      ))
      | "--no-output" -> ignore ((
        ignore (let __assign_15 = true in (
          noOutput2 := __assign_15;
          __assign_15
        ));
        i := HxInt.add (!i) 1
      ))
      | "--resource" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --resource");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--std" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after --std");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_16 = HxArray.get expanded (HxInt.add (!i) 1) in (
          stdRoot := __assign_16;
          __assign_16
        ));
        i := HxInt.add (!i) 2
      ))
      | "--display-details" | "--times" -> ignore (if permissive then ignore (i := HxInt.add (!i) 1) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--connect" | "--wait" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--as3" | "--cpp" | "--cs" | "--hl" | "--java" | "--js" | "--jvm" | "--lua" | "--neko" | "--php" | "--python" | "--swf" | "--xml" | "-as3" | "-cpp" | "-cs" | "-hl" | "-java" | "-js" | "-jvm" | "-lua" | "-neko" | "-php" | "-python" | "-swf" | "-xml" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "-D" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after -D");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push defines2 (HxArray.get expanded (HxInt.add (!i) 1)));
        i := HxInt.add (!i) 2
      ))
      | "-cmd" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after -cmd");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_17 = true in (
          hadCmd2 := __assign_17;
          __assign_17
        ));
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "-lib" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after -lib");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (HxArray.push libs2 (HxArray.get expanded (HxInt.add (!i) 1)));
        i := HxInt.add (!i) 2
      ))
      | "-swf-lib" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline "hxhx(stage1): missing value after -swf-lib");
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        i := HxInt.add (!i) 2
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | "--run" | "-x" -> ignore (if permissive then ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length expanded then ignore ((
          ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (let __assign_18 = HxArray.get expanded (HxInt.add (!i) 1) in (
          main2 := __assign_18;
          __assign_18
        ));
        ignore (i := HxInt.add (!i) 2);
        while !i < HxArray.length expanded && not (StringTools.startsWith (HxArray.get expanded (!i)) "-") do ignore (let __old_19 = !i in let __new_20 = HxInt.add __old_19 1 in (
          ignore (i := __new_20);
          __old_19
        )) done
      )) else ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )))
      | _ -> ignore ((
        ignore (if StringTools.startsWith a "-" then ignore ((
          ignore (if permissive then ignore ((
            ignore (print_endline ("hxhx(stage1): ignoring unsupported flag in permissive mode: " ^ HxString.toStdString a));
            ignore (i := HxInt.add (!i) 1);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (print_endline ("hxhx(stage1): unsupported flag: " ^ HxString.toStdString a));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        ignore (if permissive then ignore ((
          ignore (HxArray.push roots2 a);
          ignore (i := HxInt.add (!i) 1);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (print_endline ("hxhx(stage1): unsupported argument: " ^ HxString.toStdString a));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      ))) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if HxArray.length classPaths2 = 0 then ignore (HxArray.push classPaths2 ".") else ());
    ignore (if !stdRoot == Obj.magic (HxRuntime.hx_null) || HxString.length (!stdRoot) = 0 then ignore (let __assign_21 = stage1args_inferStdRoot () in (
      stdRoot := __assign_21;
      __assign_21
    )) else ());
    ignore (if !stdRoot != Obj.magic (HxRuntime.hx_null) && HxString.length (!stdRoot) > 0 && HxArray.indexOf classPaths2 (!stdRoot) 0 = -1 then ignore (HxArray.push classPaths2 (!stdRoot)) else ());
    stage1args_create classPaths2 (!main2) (!noOutput2) roots2 defines2 libs2 macros2 (!displayRequest2) (!cwd2) (!hadCmd2)
  )
) with
  | HxRuntime.Hx_return __ret_22 -> Obj.obj __ret_22

let stage1args_getClassPaths = fun a -> a.classPaths

let stage1args_getMain = fun a -> a.main

let stage1args_getNoOutput = fun a -> a.noOutput

let stage1args_getRoots = fun a -> a.roots

let stage1args_getDefines = fun a -> a.defines

let stage1args_getLibs = fun a -> a.libs

let stage1args_getMacros = fun a -> a.macros

let stage1args_getDisplayRequest = fun a -> a.displayRequest

let stage1args_getCwd = fun a -> a.cwd

let stage1args_getHadCmd = fun a -> a.hadCmd

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Stage1Resolver *)

let __reflaxe_ocaml__ = ()

type stage1resolver_t = { __hx_type : Obj.t }

let stage1resolver_create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Stage1Resolver" } : stage1resolver_t) in (
  ignore ();
  self
)

let stage1resolver___empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Stage1Resolver" } : stage1resolver_t)

let stage1resolver_normalizeSep = fun s -> let tempResult = ref "" in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then let __assign_1 = "" in (
    tempResult := __assign_1;
    __assign_1
  ) else let __assign_2 = StringTools.replace s "\\" "/" in (
    tempResult := __assign_2;
    __assign_2
  ));
  !tempResult
)

let stage1resolver_resolveClassPath = fun cwd cp -> let tempString = ref "" in (
  ignore (if cp == Obj.magic (HxRuntime.hx_null) then let __assign_3 = "" in (
    tempString := __assign_3;
    __assign_3
  ) else let __assign_4 = StringTools.replace cp "\\" "/" in (
    tempString := __assign_4;
    __assign_4
  ));
  let tempResult = ref "" in (
    ignore (if Haxe_io_Path.isAbsolute (!tempString) then let __assign_5 = !tempString in (
      tempResult := __assign_5;
      __assign_5
    ) else let __assign_6 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_7 = HxArray.create () in (
      ignore (HxArray.push __arr_7 cwd);
      ignore (HxArray.push __arr_7 (!tempString));
      __arr_7
    ))) in (
      tempResult := __assign_6;
      __assign_6
    ));
    !tempResult
  )
)

let stage1resolver_resolveMain = fun classPaths main cwd -> try let parts = HxString.split main "." in (
  ignore (if HxArray.length parts = 0 then ignore ((
    ignore (print_endline ("hxhx(stage1): invalid -main: " ^ HxString.toStdString main));
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  )) else ());
  let className = HxArray.get parts (HxInt.sub (HxArray.length parts) 1) in let pkgParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let pkg = HxArray.join pkgParts "." (fun x -> x) in (
    ignore (let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_8 = !_g in let __new_9 = HxInt.add __old_8 1 in (
        ignore (_g := __new_9);
        __new_9
      ));
      let base = stage1resolver_resolveClassPath cwd cp in let candidate = Haxe_io_Path.join (HxArray.concat (HxArray.concat (let __arr_10 = HxArray.create () in (
        ignore (HxArray.push __arr_10 base);
        __arr_10
      )) pkgParts) (let __arr_11 = HxArray.create () in (
        ignore (HxArray.push __arr_11 (HxString.toStdString className ^ ".hx"));
        __arr_11
      ))) in if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_12 = HxAnon.create () in (
        ignore (HxAnon.set __anon_12 "path" (Obj.repr candidate));
        ignore (HxAnon.set __anon_12 "packagePath" (Obj.repr pkg));
        ignore (HxAnon.set __anon_12 "className" (Obj.repr className));
        __anon_12
      )))) else ()
    )) done);
    ignore (print_endline ("hxhx(stage1): could not find main module for -main " ^ HxString.toStdString main));
    ignore (let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_13 = !_g in let __new_14 = HxInt.add __old_13 1 in (
        ignore (_g := __new_14);
        __new_14
      ));
      print_endline ("  searched: " ^ HxString.toStdString (stage1resolver_resolveClassPath cwd cp))
    )) done);
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_15 -> Obj.obj __ret_15

let stage1resolver_resolveModule = fun classPaths modulePath cwd -> try let parts = HxString.split modulePath "." in (
  ignore (if HxArray.length parts = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let leafName = HxArray.get parts (HxInt.sub (HxArray.length parts) 1) in let _g = ref 0 in (
    ignore (while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_16 = !_g in let __new_17 = HxInt.add __old_16 1 in (
        ignore (_g := __new_17);
        __new_17
      ));
      let base = stage1resolver_resolveClassPath cwd cp in (
        ignore (let pkgParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let pkg = HxArray.join pkgParts "." (fun x -> x) in let candidate = Haxe_io_Path.join (HxArray.concat (HxArray.concat (let __arr_18 = HxArray.create () in (
          ignore (HxArray.push __arr_18 base);
          __arr_18
        )) pkgParts) (let __arr_19 = HxArray.create () in (
          ignore (HxArray.push __arr_19 (HxString.toStdString leafName ^ ".hx"));
          __arr_19
        ))) in if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_20 = HxAnon.create () in (
          ignore (HxAnon.set __anon_20 "path" (Obj.repr candidate));
          ignore (HxAnon.set __anon_20 "packagePath" (Obj.repr pkg));
          ignore (HxAnon.set __anon_20 "className" (Obj.repr leafName));
          __anon_20
        )))) else ());
        if HxArray.length parts >= 2 then ignore (let modName = HxArray.get parts (HxInt.sub (HxArray.length parts) 2) in let pkgParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 2) in let pkg = HxArray.join pkgParts "." (fun x -> x) in let candidate = Haxe_io_Path.join (HxArray.concat (HxArray.concat (let __arr_21 = HxArray.create () in (
          ignore (HxArray.push __arr_21 base);
          __arr_21
        )) pkgParts) (let __arr_22 = HxArray.create () in (
          ignore (HxArray.push __arr_22 (HxString.toStdString modName ^ ".hx"));
          __arr_22
        ))) in if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_23 = HxAnon.create () in (
          ignore (HxAnon.set __anon_23 "path" (Obj.repr candidate));
          ignore (HxAnon.set __anon_23 "packagePath" (Obj.repr pkg));
          ignore (HxAnon.set __anon_23 "className" (Obj.repr modName));
          __anon_23
        )))) else ()) else ()
      )
    )) done);
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_24 -> Obj.obj __ret_24

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Stage1Compiler *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Stage1Compiler" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Stage1Compiler" } : t)

let error = fun msg -> (
  ignore (print_endline ("hxhx(stage1): " ^ HxString.toStdString msg));
  2
)

let haxelibBin = fun () -> let v = HxSys.getEnv "HAXELIB_BIN" in let tempResult = ref "" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_1 = "haxelib" in (
    tempResult := __assign_1;
    __assign_1
  ) else let __assign_2 = v in (
    tempResult := __assign_2;
    __assign_2
  ));
  !tempResult
)

let resolveHaxelibPaths = fun lib -> let paths = HxArray.create () in let p = Sys_io_Process.create (haxelibBin ()) (let __arr_3 = HxArray.create () in (
  ignore (HxArray.push __arr_3 "path");
  ignore (HxArray.push __arr_3 lib);
  __arr_3
)) (HxRuntime.hx_null) in (
  ignore (try try while true do try ignore (let raw = let __obj_4 = p.stdout in __obj_4.readLine (Obj.magic __obj_4) () in let line = StringTools.trim raw in (
    ignore (if HxString.length line = 0 then raise (HxRuntime.Hx_continue) else ());
    ignore (if StringTools.startsWith line "-" then raise (HxRuntime.Hx_continue) else ());
    HxArray.push paths line
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> () with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_5 -> raise (HxRuntime.Hx_return __ret_5)
    | HxRuntime.Hx_exception (__exn_v_6, __exn_tags_7) -> if HxRuntime.tags_has __exn_tags_7 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_6 : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else HxRuntime.hx_throw_typed __exn_v_6 __exn_tags_7
    | __exn_8 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_8) : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else raise (__exn_8));
  let code = Sys_io_Process.exitCode p () in (
    ignore (if code <> 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr ((("haxelib path " ^ HxString.toStdString lib) ^ " failed with exit code ") ^ string_of_int code)) ["Dynamic"; "String"]) else ());
    paths
  )
)

let formatParseError = fun e -> HxParseError.toString e ()

let run = fun args -> try let permissive = ref false in let filtered = HxArray.create () in (
  ignore (let _g = ref 0 in try while !_g < HxArray.length args do try ignore (let a = HxArray.get args (!_g) in (
    ignore (let __old_9 = !_g in let __new_10 = HxInt.add __old_9 1 in (
      ignore (_g := __new_10);
      __new_10
    ));
    ignore (if HxString.equals a "--hxhx-permissive" then ignore ((
      ignore (let __assign_11 = true in (
        permissive := __assign_11;
        __assign_11
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    HxArray.push filtered a
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let parsed = stage1args_parse filtered (!permissive) in (
    ignore (if parsed == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 2)) else ());
    ignore (if not (parsed.noOutput) then raise (HxRuntime.Hx_return (Obj.repr (error "only --no-output is supported in stage1 bring-up"))) else ());
    ignore (if parsed.main == Obj.magic (HxRuntime.hx_null) || HxString.length (parsed.main) = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "missing -main <TypeName>"))) else ());
    let classPaths = HxArray.copy (parsed.classPaths) in (
      ignore (if !permissive && HxArray.length (parsed.libs) > 0 then ignore (let _g = ref 0 in let _g1 = parsed.libs in while !_g < HxArray.length _g1 do ignore (let lib = HxArray.get _g1 (!_g) in (
        ignore (let __old_12 = !_g in let __new_13 = HxInt.add __old_12 1 in (
          ignore (_g := __new_13);
          __new_13
        ));
        try let _g2 = ref 0 in let _g3 = resolveHaxelibPaths lib in while !_g2 < HxArray.length _g3 do ignore (let p = HxArray.get _g3 (!_g2) in (
          ignore (let __old_14 = !_g2 in let __new_15 = HxInt.add __old_14 1 in (
            ignore (_g2 := __new_15);
            __new_15
          ));
          HxArray.push classPaths p
        )) done with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_16 -> raise (HxRuntime.Hx_return __ret_16)
          | HxRuntime.Hx_exception (__exn_v_17, __exn_tags_18) -> if HxRuntime.tags_has __exn_tags_18 "String" then let e = (Obj.obj __exn_v_17 : string) in (
            ignore e;
            raise (HxRuntime.Hx_return (Obj.repr (error ((("failed to resolve -lib " ^ HxString.toStdString lib) ^ ": ") ^ HxString.toStdString e))))
          ) else HxRuntime.hx_throw_typed __exn_v_17 __exn_tags_18
          | __exn_19 -> if HxRuntime.tags_has ["OcamlExn"] "String" then let e = (Obj.obj (Obj.repr __exn_19) : string) in (
            ignore e;
            raise (HxRuntime.Hx_return (Obj.repr (error ((("failed to resolve -lib " ^ HxString.toStdString lib) ^ ": ") ^ HxString.toStdString e))))
          ) else raise (__exn_19)
      )) done) else ());
      let resolved = stage1resolver_resolveMain classPaths (parsed.main) (parsed.cwd) in (
        ignore (if resolved == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 2)) else ());
        let tempMaybeString = ref (Obj.magic ()) in (
          ignore (try let path = Obj.obj (HxAnon.get resolved "path") in let __assign_20 = HxFile.getContent path in (
            tempMaybeString := __assign_20;
            __assign_20
          ) with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_21 -> raise (HxRuntime.Hx_return __ret_21)
            | HxRuntime.Hx_exception (__exn_v_22, __exn_tags_23) -> if HxRuntime.tags_has __exn_tags_23 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_22) : Haxe_io_Error.error) in (
              ignore _hx;
              let __assign_25 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_25;
                __assign_25
              )
            ) else if HxRuntime.tags_has __exn_tags_23 "String" then let _hx = (Obj.obj __exn_v_22 : string) in (
              ignore _hx;
              let __assign_24 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_24;
                __assign_24
              )
            ) else HxRuntime.hx_throw_typed __exn_v_22 __exn_tags_23
            | __exn_26 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_26)) : Haxe_io_Error.error) in (
              ignore _hx;
              let __assign_28 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_28;
                __assign_28
              )
            ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_26) : string) in (
              ignore _hx;
              let __assign_27 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_27;
                __assign_27
              )
            ) else raise (__exn_26));
          let source = !tempMaybeString in (
            ignore (if source == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (error ("failed to read: " ^ HxString.toStdString (Obj.obj (HxAnon.get resolved "path")))))) else ());
            let definesMap = HxDefineMap.fromRawDefines (parsed.defines) in (
              ignore (HxMap.set_string definesMap "sys" "1");
              ignore (HxMap.set_string definesMap "ocaml" "1");
              let filteredSource = HxConditionalCompilation.filterSource source definesMap in let tempHxModuleDecl = ref (Obj.magic ()) in (
                ignore (try let __assign_29 = ParsedModule.getDecl (ParserStage.parse filteredSource (Obj.obj (HxAnon.get resolved "path"))) () in (
                  tempHxModuleDecl := __assign_29;
                  __assign_29
                ) with
                  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                  | HxRuntime.Hx_return __ret_30 -> raise (HxRuntime.Hx_return __ret_30)
                  | HxRuntime.Hx_exception (__exn_v_31, __exn_tags_32) -> if HxRuntime.tags_has __exn_tags_32 "HxParseError" then let e = (Obj.obj __exn_v_31 : HxParseError.t) in (
                    ignore e;
                    raise (HxRuntime.Hx_return (Obj.repr (error ("parse failed: " ^ HxString.toStdString (formatParseError e)))))
                  ) else if HxRuntime.tags_has __exn_tags_32 "String" then let e = (Obj.obj __exn_v_31 : string) in (
                    ignore e;
                    raise (HxRuntime.Hx_return (Obj.repr (error ("parse failed: " ^ HxString.toStdString e))))
                  ) else HxRuntime.hx_throw_typed __exn_v_31 __exn_tags_32
                  | __exn_33 -> if HxRuntime.tags_has ["OcamlExn"] "HxParseError" then let e = (Obj.obj (Obj.repr __exn_33) : HxParseError.t) in (
                    ignore e;
                    raise (HxRuntime.Hx_return (Obj.repr (error ("parse failed: " ^ HxString.toStdString (formatParseError e)))))
                  ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let e = (Obj.obj (Obj.repr __exn_33) : string) in (
                    ignore e;
                    raise (HxRuntime.Hx_return (Obj.repr (error ("parse failed: " ^ HxString.toStdString e))))
                  ) else raise (__exn_33));
                let decl = !tempHxModuleDecl in let tempLeft = ref "" in (
                  ignore (let tmp = decl.packagePath in if tmp != Obj.magic (HxRuntime.hx_null) then let __assign_34 = tmp in (
                    tempLeft := __assign_34;
                    __assign_34
                  ) else let __assign_35 = "" in (
                    tempLeft := __assign_35;
                    __assign_35
                  ));
                  ignore (if not (HxString.equals (!tempLeft) (Obj.obj (HxAnon.get resolved "packagePath"))) then ignore (let tempRight = ref "" in (
                    ignore (let tmp = decl.packagePath in if tmp != Obj.magic (HxRuntime.hx_null) then let __assign_36 = tmp in (
                      tempRight := __assign_36;
                      __assign_36
                    ) else let __assign_37 = "" in (
                      tempRight := __assign_37;
                      __assign_37
                    ));
                    raise (HxRuntime.Hx_return (Obj.repr (error (((((("package mismatch for \"" ^ HxString.toStdString (parsed.main)) ^ "\": expected \"") ^ HxString.toStdString (Obj.obj (HxAnon.get resolved "packagePath"))) ^ "\" but parsed \"") ^ HxString.toStdString (!tempRight)) ^ "\""))))
                  )) else ());
                  let hasToplevelMain = HxModuleDecl.getHasToplevelMain decl in (
                    ignore (if not (hasToplevelMain) then ignore ((
                      ignore (if not (HxString.equals (decl.mainClass.name) (Obj.obj (HxAnon.get resolved "className"))) then raise (HxRuntime.Hx_return (Obj.repr (error ((((("expected main class \"" ^ HxString.toStdString (Obj.obj (HxAnon.get resolved "className"))) ^ "\" but parsed \"") ^ HxString.toStdString (decl.mainClass.name)) ^ "\" in ") ^ HxString.toStdString (Obj.obj (HxAnon.get resolved "path")))))) else ());
                      if not (decl.mainClass.hasStaticMain) then raise (HxRuntime.Hx_return (Obj.repr (error (("missing entrypoint main for " ^ HxString.toStdString (parsed.main)) ^ " (expected static function main or toplevel function main)")))) else ()
                    )) else ());
                    let queue = HxArray.create () in (
                      ignore (let _g = ref 0 in let _g1 = decl.imports in while !_g < HxArray.length _g1 do ignore (let imp = HxArray.get _g1 (!_g) in (
                        ignore (let __old_38 = !_g in let __new_39 = HxInt.add __old_38 1 in (
                          ignore (_g := __new_39);
                          __new_39
                        ));
                        HxArray.push queue imp
                      )) done);
                      let visited = HxMap.create_string () in let q = ref 0 in (
                        ignore (try while !q < HxArray.length queue do try ignore (let imp = HxArray.get queue (let __old_40 = !q in let __new_41 = HxInt.add __old_40 1 in (
                          ignore (q := __new_41);
                          __old_40
                        )) in (
                          ignore (if imp == Obj.magic (HxRuntime.hx_null) || HxString.length imp = 0 then raise (HxRuntime.Hx_continue) else ());
                          ignore (if HxMap.exists_string visited imp then raise (HxRuntime.Hx_continue) else ());
                          ignore (HxMap.set_string visited imp true);
                          ignore (if StringTools.endsWith imp ".*" then ignore (let base = HxString.substr imp 0 (HxInt.sub (HxString.length imp) 2) in let baseResolved = stage1resolver_resolveModule classPaths base (parsed.cwd) in (
                            ignore (if baseResolved == Obj.magic (HxRuntime.hx_null) then ignore ((
                              ignore (print_endline ("stage1=warn import_wildcard " ^ HxString.toStdString imp));
                              raise (HxRuntime.Hx_continue)
                            )) else ());
                            ignore (if not (HxMap.exists_string visited base) then ignore (HxArray.push queue base) else ());
                            raise (HxRuntime.Hx_continue)
                          )) else ());
                          let impResolved = stage1resolver_resolveModule classPaths imp (parsed.cwd) in (
                            ignore (if impResolved == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (error ("import_missing " ^ HxString.toStdString imp)))) else ());
                            let tempMaybeString1 = ref (Obj.magic ()) in (
                              ignore (try let path = Obj.obj (HxAnon.get impResolved "path") in let __assign_42 = HxFile.getContent path in (
                                tempMaybeString1 := __assign_42;
                                __assign_42
                              ) with
                                | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                | HxRuntime.Hx_return __ret_43 -> raise (HxRuntime.Hx_return __ret_43)
                                | HxRuntime.Hx_exception (__exn_v_44, __exn_tags_45) -> if HxRuntime.tags_has __exn_tags_45 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_44) : Haxe_io_Error.error) in (
                                  ignore _hx;
                                  let __assign_47 = Obj.magic (HxRuntime.hx_null) in (
                                    tempMaybeString1 := __assign_47;
                                    __assign_47
                                  )
                                ) else if HxRuntime.tags_has __exn_tags_45 "String" then let _hx = (Obj.obj __exn_v_44 : string) in (
                                  ignore _hx;
                                  let __assign_46 = Obj.magic (HxRuntime.hx_null) in (
                                    tempMaybeString1 := __assign_46;
                                    __assign_46
                                  )
                                ) else HxRuntime.hx_throw_typed __exn_v_44 __exn_tags_45
                                | __exn_48 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_48)) : Haxe_io_Error.error) in (
                                  ignore _hx;
                                  let __assign_50 = Obj.magic (HxRuntime.hx_null) in (
                                    tempMaybeString1 := __assign_50;
                                    __assign_50
                                  )
                                ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_48) : string) in (
                                  ignore _hx;
                                  let __assign_49 = Obj.magic (HxRuntime.hx_null) in (
                                    tempMaybeString1 := __assign_49;
                                    __assign_49
                                  )
                                ) else raise (__exn_48));
                              let impSrc = !tempMaybeString1 in (
                                ignore (if impSrc == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (error ("import_unreadable " ^ HxString.toStdString (Obj.obj (HxAnon.get impResolved "path")))))) else ());
                                let tempHxModuleDecl1 = ref (Obj.magic ()) in (
                                  ignore (try let filteredImp = HxConditionalCompilation.filterSource impSrc definesMap in let __assign_51 = ParsedModule.getDecl (ParserStage.parse filteredImp (Obj.obj (HxAnon.get impResolved "path"))) () in (
                                    tempHxModuleDecl1 := __assign_51;
                                    __assign_51
                                  ) with
                                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                    | HxRuntime.Hx_return __ret_52 -> raise (HxRuntime.Hx_return __ret_52)
                                    | HxRuntime.Hx_exception (__exn_v_53, __exn_tags_54) -> if HxRuntime.tags_has __exn_tags_54 "HxParseError" then let e = (Obj.obj __exn_v_53 : HxParseError.t) in (
                                      ignore e;
                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("parse failed for import \"" ^ HxString.toStdString imp) ^ "\": ") ^ HxString.toStdString (formatParseError e)))))
                                    ) else if HxRuntime.tags_has __exn_tags_54 "String" then let e = (Obj.obj __exn_v_53 : string) in (
                                      ignore e;
                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("parse failed for import \"" ^ HxString.toStdString imp) ^ "\": ") ^ HxString.toStdString e))))
                                    ) else HxRuntime.hx_throw_typed __exn_v_53 __exn_tags_54
                                    | __exn_55 -> if HxRuntime.tags_has ["OcamlExn"] "HxParseError" then let e = (Obj.obj (Obj.repr __exn_55) : HxParseError.t) in (
                                      ignore e;
                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("parse failed for import \"" ^ HxString.toStdString imp) ^ "\": ") ^ HxString.toStdString (formatParseError e)))))
                                    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let e = (Obj.obj (Obj.repr __exn_55) : string) in (
                                      ignore e;
                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("parse failed for import \"" ^ HxString.toStdString imp) ^ "\": ") ^ HxString.toStdString e))))
                                    ) else raise (__exn_55));
                                  let impDecl = !tempHxModuleDecl1 in let parsedName = impDecl.mainClass.name in (
                                    ignore (if parsedName != Obj.magic (HxRuntime.hx_null) && HxString.length parsedName > 0 && not (HxString.equals parsedName "Unknown") && not (HxString.equals parsedName (Obj.obj (HxAnon.get impResolved "className"))) then ignore (print_endline ("stage1=warn import_class_mismatch " ^ HxString.toStdString imp)) else ());
                                    let tempLeft1 = ref "" in (
                                      ignore (let tmp = impDecl.packagePath in if tmp != Obj.magic (HxRuntime.hx_null) then let __assign_56 = tmp in (
                                        tempLeft1 := __assign_56;
                                        __assign_56
                                      ) else let __assign_57 = "" in (
                                        tempLeft1 := __assign_57;
                                        __assign_57
                                      ));
                                      ignore (if not (HxString.equals (!tempLeft1) (Obj.obj (HxAnon.get impResolved "packagePath"))) then ignore ((
                                        ignore (print_endline ("stage1=warn import_package_mismatch " ^ HxString.toStdString imp));
                                        raise (HxRuntime.Hx_continue)
                                      )) else ());
                                      let _g = ref 0 in let _g1 = impDecl.imports in while !_g < HxArray.length _g1 do ignore (let imp2 = HxArray.get _g1 (!_g) in (
                                        ignore (let __old_58 = !_g in let __new_59 = HxInt.add __old_58 1 in (
                                          ignore (_g := __new_59);
                                          __new_59
                                        ));
                                        HxArray.push queue imp2
                                      )) done
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )) with
                          | HxRuntime.Hx_continue -> () done with
                          | HxRuntime.Hx_break -> ());
                        ignore (print_endline "stage1=ok");
                        ignore (print_endline ("main=" ^ HxString.toStdString (parsed.main)));
                        ignore (print_endline ("file=" ^ HxString.toStdString (Obj.obj (HxAnon.get resolved "path"))));
                        0
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_60 -> Obj.obj __ret_60
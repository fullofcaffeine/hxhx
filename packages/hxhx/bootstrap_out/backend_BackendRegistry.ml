# 1 "backend_BackendRegistry.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: backend.BackendRegistry *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "backend.BackendRegistry" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "backend.BackendRegistry" } : t)

let builtinRegistrations = let __arr_26 = HxArray.create () in (
  ignore (HxArray.push __arr_26 (let __anon_27 = HxAnon.create () in (
    ignore (HxAnon.set __anon_27 "descriptor" (Obj.repr (Backend_ocaml_OcamlStage3Backend.descriptor ())));
    ignore (HxAnon.set __anon_27 "create" (Obj.repr (fun () -> Backend_ocaml_OcamlStage3Backend.create ())));
    __anon_27
  )));
  ignore (HxArray.push __arr_26 (let __anon_28 = HxAnon.create () in (
    ignore (HxAnon.set __anon_28 "descriptor" (Obj.repr (Backend_js_JsBackend.descriptor ())));
    ignore (HxAnon.set __anon_28 "create" (Obj.repr (fun () -> Backend_js_JsBackend.create ())));
    __anon_28
  )));
  __arr_26
)

let dynamicRegistrations = let __arr_29 = HxArray.create () in __arr_29

let allRegistrations = fun () -> HxArray.concat builtinRegistrations dynamicRegistrations

let sortedForTarget = fun targetId -> let tempString = ref "" in (
  ignore (if targetId == Obj.magic (HxRuntime.hx_null) then let __assign_1 = "" in (
    tempString := __assign_1;
    __assign_1
  ) else let __assign_2 = targetId in (
    tempString := __assign_2;
    __assign_2
  ));
  let _this = allRegistrations () in let _g = let __arr_3 = HxArray.create () in __arr_3 in let _g1 = ref 0 in (
    ignore (while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
      ignore (let __old_4 = !_g1 in let __new_5 = HxInt.add __old_4 1 in (
        ignore (_g1 := __new_5);
        __new_5
      ));
      if HxString.equals (Obj.obj (HxAnon.get (Obj.obj (HxAnon.get v "descriptor")) "id")) (!tempString) then ignore (HxArray.push _g v) else ()
    )) done);
    ignore (HxArray.sort _g (fun a b -> try (
      ignore (if Obj.obj (HxAnon.get (Obj.obj (HxAnon.get a "descriptor")) "priority") <> Obj.obj (HxAnon.get (Obj.obj (HxAnon.get b "descriptor")) "priority") then raise (HxRuntime.Hx_return (Obj.repr (HxInt.sub (Obj.obj (HxAnon.get (Obj.obj (HxAnon.get b "descriptor")) "priority")) (Obj.obj (HxAnon.get (Obj.obj (HxAnon.get a "descriptor")) "priority"))))) else ());
      let tempResult = ref 0 in (
        ignore (if Obj.obj (HxAnon.get (Obj.obj (HxAnon.get a "descriptor")) "implId") < Obj.obj (HxAnon.get (Obj.obj (HxAnon.get b "descriptor")) "implId") then let __assign_6 = -1 in (
          tempResult := __assign_6;
          __assign_6
        ) else if Obj.obj (HxAnon.get (Obj.obj (HxAnon.get a "descriptor")) "implId") > Obj.obj (HxAnon.get (Obj.obj (HxAnon.get b "descriptor")) "implId") then let __assign_7 = 1 in (
          tempResult := __assign_7;
          __assign_7
        ) else let __assign_8 = 0 in (
          tempResult := __assign_8;
          __assign_8
        ));
        !tempResult
      )
    ) with
      | HxRuntime.Hx_return __ret_9 -> Obj.obj __ret_9));
    _g
  )
)

let listDescriptors = fun () -> let _this = allRegistrations () in let _g = let __arr_10 = HxArray.create () in __arr_10 in let _g1 = ref 0 in (
  ignore (while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
    ignore (let __old_11 = !_g1 in let __new_12 = HxInt.add __old_11 1 in (
      ignore (_g1 := __new_12);
      __new_12
    ));
    HxArray.push _g (Obj.obj (HxAnon.get v "descriptor"))
  )) done);
  _g
)

let supportedTargetIds = fun () -> let seen = HxMap.create_string () in let ids = HxArray.create () in let _g = ref 0 in let _g1 = allRegistrations () in (
  ignore (try while !_g < HxArray.length _g1 do try ignore (let r = HxArray.get _g1 (!_g) in (
    ignore (let __old_13 = !_g in let __new_14 = HxInt.add __old_13 1 in (
      ignore (_g := __new_14);
      __new_14
    ));
    let id = Obj.obj (HxAnon.get (Obj.obj (HxAnon.get r "descriptor")) "id") in (
      ignore (if HxMap.exists_string seen id then raise (HxRuntime.Hx_continue) else ());
      ignore (HxMap.set_string seen id true);
      HxArray.push ids id
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ids
)

let register = fun spec -> (
  ignore (if spec == Obj.magic (HxRuntime.hx_null) || Obj.obj (HxAnon.get spec "descriptor") == Obj.magic (HxRuntime.hx_null) || Obj.obj (HxAnon.get spec "create") == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "invalid backend registration (descriptor/create required)") ["Dynamic"; "String"]) else ());
  let d = Obj.obj (HxAnon.get spec "descriptor") in (
    ignore (if Obj.obj (HxAnon.get d "id") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get d "id")) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "invalid backend registration: descriptor.id is required") ["Dynamic"; "String"]) else ());
    ignore (if Obj.obj (HxAnon.get d "implId") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get d "implId")) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "invalid backend registration: descriptor.implId is required") ["Dynamic"; "String"]) else ());
    HxArray.push dynamicRegistrations spec
  )
)

let registerProvider = fun regs -> try (
  ignore (if regs == Obj.magic (HxRuntime.hx_null) || HxArray.length regs = 0 then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let _g = ref 0 in (
    ignore (while !_g < HxArray.length regs do ignore (let reg = HxArray.get regs (!_g) in (
      ignore (let __old_15 = !_g in let __new_16 = HxInt.add __old_15 1 in (
        ignore (_g := __new_16);
        __new_16
      ));
      register reg
    )) done);
    HxArray.length regs
  )
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17

let clearDynamicRegistrations = fun () -> HxArray.splice dynamicRegistrations 0 (HxArray.length dynamicRegistrations)

let descriptorForTarget = fun targetId -> let candidates = sortedForTarget targetId in let tempResult = ref (Obj.magic ()) in (
  ignore (if HxArray.length candidates = 0 then let __assign_18 = HxRuntime.hx_null in (
    tempResult := __assign_18;
    __assign_18
  ) else let __assign_19 = Obj.obj (HxAnon.get (HxArray.get candidates 0) "descriptor") in (
    tempResult := __assign_19;
    __assign_19
  ));
  !tempResult
)

let createForTarget = fun targetId -> let candidates = sortedForTarget targetId in let tempResult = ref (Obj.magic ()) in (
  ignore (if HxArray.length candidates = 0 then let __assign_20 = Obj.magic (HxRuntime.hx_null) in (
    tempResult := __assign_20;
    __assign_20
  ) else let __assign_21 = Obj.obj (HxAnon.get (HxArray.get candidates 0) "create") () in (
    tempResult := __assign_21;
    __assign_21
  ));
  !tempResult
)

let requireForTarget = fun targetId -> try let backend = createForTarget targetId in (
  ignore (if backend != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr backend)) else ());
  let supported = supportedTargetIds () in (
    ignore (HxArray.sort supported (fun a b -> let tempResult = ref 0 in (
      ignore (if a < b then let __assign_22 = -1 in (
        tempResult := __assign_22;
        __assign_22
      ) else if a > b then let __assign_23 = 1 in (
        tempResult := __assign_23;
        __assign_23
      ) else let __assign_24 = 0 in (
        tempResult := __assign_24;
        __assign_24
      ));
      !tempResult
    )));
    HxType.hx_throw_typed_rtti (Obj.repr (((("unknown Stage3 backend: " ^ HxString.toStdString targetId) ^ " (supported: ") ^ HxString.toStdString (HxArray.join supported ", " (fun x -> x))) ^ ")")) ["Dynamic"; "String"]
  )
) with
  | HxRuntime.Hx_return __ret_25 -> Obj.obj __ret_25
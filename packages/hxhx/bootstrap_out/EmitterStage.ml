# 1 "EmitterStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: EmitterStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "EmitterStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "EmitterStage" } : t)

let emit = fun _hx -> ()

let escapeOcamlIdentPart = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) || HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr "_")) else ());
  let out = StringBuf.create () in let _g = ref 0 in let _g1 = HxString.length s in (
    ignore (while !_g < _g1 do ignore (let i = let __old_1 = !_g in let __new_2 = HxInt.add __old_1 1 in (
      ignore (_g := __new_2);
      __old_1
    ) in let c = HxString.charCodeAt s i in let isAlphaNum = (let __nullable_3 = c in let __nullable_4 = 97 in if __nullable_3 == HxRuntime.hx_null then false else Obj.obj __nullable_3 >= __nullable_4) && (let __nullable_5 = c in let __nullable_6 = 122 in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 <= __nullable_6) || (let __nullable_7 = c in let __nullable_8 = 65 in if __nullable_7 == HxRuntime.hx_null then false else Obj.obj __nullable_7 >= __nullable_8) && (let __nullable_9 = c in let __nullable_10 = 90 in if __nullable_9 == HxRuntime.hx_null then false else Obj.obj __nullable_9 <= __nullable_10) || (let __nullable_11 = c in let __nullable_12 = 48 in if __nullable_11 == HxRuntime.hx_null then false else Obj.obj __nullable_11 >= __nullable_12) && (let __nullable_13 = c in let __nullable_14 = 57 in if __nullable_13 == HxRuntime.hx_null then false else Obj.obj __nullable_13 <= __nullable_14) in let tempString = ref "" in (
      ignore (if isAlphaNum then let __assign_15 = HxString.fromCharCode (let __nullable_int_16 = c in if __nullable_int_16 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_16) in (
        tempString := __assign_15;
        __assign_15
      ) else let __assign_17 = "_" in (
        tempString := __assign_17;
        __assign_17
      ));
      StringBuf.add out (Obj.repr (!tempString))
    )) done);
    let t = StringBuf.toString out () in let tempResult = ref "" in (
      ignore (if HxString.length t = 0 then let __assign_18 = "_" in (
        tempResult := __assign_18;
        __assign_18
      ) else let __assign_19 = t in (
        tempResult := __assign_19;
        __assign_19
      ));
      !tempResult
    )
  )
) with
  | HxRuntime.Hx_return __ret_20 -> Obj.obj __ret_20

let ocamlTypeFromTy = fun t -> let tempResult = ref "" in (
  ignore (let _g = TyType.toString t () in match _g with
    | "Bool" -> let __assign_22 = "bool" in (
      tempResult := __assign_22;
      __assign_22
    )
    | "Float" -> let __assign_23 = "float" in (
      tempResult := __assign_23;
      __assign_23
    )
    | "Int" -> let __assign_24 = "int" in (
      tempResult := __assign_24;
      __assign_24
    )
    | "Int64" | "haxe.Int64" -> let __assign_25 = "HxInt64.t" in (
      tempResult := __assign_25;
      __assign_25
    )
    | "PosInfos" | "haxe.PosInfos" -> let __assign_26 = "HxPosInfos.t" in (
      tempResult := __assign_26;
      __assign_26
    )
    | "String" -> let __assign_27 = "string" in (
      tempResult := __assign_27;
      __assign_27
    )
    | "Void" -> let __assign_28 = "unit" in (
      tempResult := __assign_28;
      __assign_28
    )
    | _ -> let __assign_21 = "_" in (
      tempResult := __assign_21;
      __assign_21
    ));
  !tempResult
)

let lowerFirst = fun name -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr "_")) else ());
  let c = HxString.charCodeAt name 0 in let isUpper = (let __nullable_29 = c in let __nullable_30 = 65 in if __nullable_29 == HxRuntime.hx_null then false else Obj.obj __nullable_29 >= __nullable_30) && (let __nullable_31 = c in let __nullable_32 = 90 in if __nullable_31 == HxRuntime.hx_null then false else Obj.obj __nullable_31 <= __nullable_32) in let tempResult = ref "" in (
    ignore (if isUpper then let __assign_33 = HxString.toStdString (HxString.fromCharCode (HxInt.add (let __nullable_int_34 = c in if __nullable_int_34 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_34) 32)) ^ HxString.toStdString (HxString.substr name 1 (-1)) in (
      tempResult := __assign_33;
      __assign_33
    ) else let __assign_35 = name in (
      tempResult := __assign_35;
      __assign_35
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_36 -> Obj.obj __ret_36

let isOcamlKeyword = fun name -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  let tempResult = ref false in (
    ignore (match name with
      | "and" | "as" | "assert" | "begin" | "class" | "constraint" | "do" | "done" | "downto" | "else" | "end" | "exception" | "external" | "false" | "for" | "fun" | "function" | "functor" | "if" | "in" | "include" | "inherit" | "initializer" | "lazy" | "let" | "match" | "method" | "module" | "mutable" | "new" | "nonrec" | "object" | "of" | "open" | "or" | "private" | "rec" | "sig" | "struct" | "then" | "to" | "true" | "try" | "type" | "val" | "virtual" | "when" | "while" | "with" -> let __assign_38 = true in (
        tempResult := __assign_38;
        __assign_38
      )
      | _ -> let __assign_37 = false in (
        tempResult := __assign_37;
        __assign_37
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_39 -> Obj.obj __ret_39

let ocamlValueIdent = fun raw -> try let base = lowerFirst raw in (
  ignore (if HxString.equals base "_" || HxString.length base = 0 then raise (HxRuntime.Hx_return (Obj.repr "_")) else ());
  let tempResult = ref "" in (
    ignore (if isOcamlKeyword base then let __assign_40 = HxString.toStdString base ^ "_" in (
      tempResult := __assign_40;
      __assign_40
    ) else let __assign_41 = base in (
      tempResult := __assign_41;
      __assign_41
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_42 -> Obj.obj __ret_42

let isUpperStart = fun name -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  let c = HxString.charCodeAt name 0 in (let __nullable_43 = c in let __nullable_44 = 65 in if __nullable_43 == HxRuntime.hx_null then false else Obj.obj __nullable_43 >= __nullable_44) && (let __nullable_45 = c in let __nullable_46 = 90 in if __nullable_45 == HxRuntime.hx_null then false else Obj.obj __nullable_45 <= __nullable_46)
) with
  | HxRuntime.Hx_return __ret_47 -> Obj.obj __ret_47

let escapeOcamlString = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "\"\"")) else ());
  let out = StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace s "\\" "\\\\") "\"" "\\\"") "\n" "\\n") "\r" "\\r") "\t" "\\t" in ("\"" ^ HxString.toStdString out) ^ "\""
) with
  | HxRuntime.Hx_return __ret_48 -> Obj.obj __ret_48

let exprToOcamlString = fun e tyByIdent -> let tempResult = ref "" in (
  ignore (match e with
    | HxExpr.EBool _p0 -> let _g = _p0 in let v = _g in let tempString = ref "" in (
      ignore (if v then let __assign_50 = "true" in (
        tempString := __assign_50;
        __assign_50
      ) else let __assign_51 = "false" in (
        tempString := __assign_51;
        __assign_51
      ));
      let __assign_52 = "string_of_bool " ^ HxString.toStdString (!tempString) in (
        tempResult := __assign_52;
        __assign_52
      )
    )
    | HxExpr.EString _p0 -> let _g = _p0 in let v = _g in let __assign_53 = escapeOcamlString v in (
      tempResult := __assign_53;
      __assign_53
    )
    | HxExpr.EInt _p0 -> let _g = _p0 in let v = _g in let __assign_54 = "string_of_int " ^ HxString.toStdString (string_of_int v) in (
      tempResult := __assign_54;
      __assign_54
    )
    | HxExpr.EFloat _p0 -> let _g = _p0 in let v = _g in let __assign_55 = "string_of_float " ^ HxString.toStdString (string_of_float v) in (
      tempResult := __assign_55;
      __assign_55
    )
    | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in if tyByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string tyByIdent name && HxMap.get_string tyByIdent name != Obj.magic (HxRuntime.hx_null) && HxString.equals (TyType.toString (HxMap.get_string tyByIdent name) ()) "Int" then let __assign_56 = "string_of_int " ^ HxString.toStdString (ocamlValueIdent name) in (
      tempResult := __assign_56;
      __assign_56
    ) else let name2 = _g in if tyByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string tyByIdent name2 && HxMap.get_string tyByIdent name2 != Obj.magic (HxRuntime.hx_null) && HxString.equals (TyType.toString (HxMap.get_string tyByIdent name2) ()) "Float" then let __assign_57 = "string_of_float " ^ HxString.toStdString (ocamlValueIdent name2) in (
      tempResult := __assign_57;
      __assign_57
    ) else let name3 = _g in if tyByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string tyByIdent name3 && HxMap.get_string tyByIdent name3 != Obj.magic (HxRuntime.hx_null) && HxString.equals (TyType.toString (HxMap.get_string tyByIdent name3) ()) "Bool" then let __assign_58 = "string_of_bool " ^ HxString.toStdString (ocamlValueIdent name3) in (
      tempResult := __assign_58;
      __assign_58
    ) else let __assign_59 = escapeOcamlString "<unsupported>" in (
      tempResult := __assign_59;
      __assign_59
    )
    | _ -> let __assign_49 = escapeOcamlString "<unsupported>" in (
      tempResult := __assign_49;
      __assign_49
    ));
  !tempResult
)

let rec exprToOcaml = fun e arityByIdent tyByIdent -> let isFloatExpr = fun expr -> let tempResult = ref false in (
  ignore (match expr with
    | HxExpr.EFloat _p0 -> (
      ignore _p0;
      let __assign_61 = true in (
        tempResult := __assign_61;
        __assign_61
      )
    )
    | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in let tempString = ref "" in (
      ignore (if tyByIdent == Obj.magic (HxRuntime.hx_null) then let __assign_62 = "" in (
        tempString := __assign_62;
        __assign_62
      ) else if not (HxMap.exists_string tyByIdent name) then let __assign_63 = "" in (
        tempString := __assign_63;
        __assign_63
      ) else let t = HxMap.get_string tyByIdent name in if t == Obj.magic (HxRuntime.hx_null) then let __assign_64 = "" in (
        tempString := __assign_64;
        __assign_64
      ) else let __assign_65 = TyType.toString t () in (
        tempString := __assign_65;
        __assign_65
      ));
      let __assign_66 = HxString.equals (!tempString) "Float" in (
        tempResult := __assign_66;
        __assign_66
      )
    )
    | _ -> let __assign_60 = false in (
      tempResult := __assign_60;
      __assign_60
    ));
  !tempResult
) in let isIntExpr = fun expr -> let tempResult1 = ref false in (
  ignore (match expr with
    | HxExpr.EInt _p0 -> (
      ignore _p0;
      let __assign_68 = true in (
        tempResult1 := __assign_68;
        __assign_68
      )
    )
    | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in let tempString1 = ref "" in (
      ignore (if tyByIdent == Obj.magic (HxRuntime.hx_null) then let __assign_69 = "" in (
        tempString1 := __assign_69;
        __assign_69
      ) else if not (HxMap.exists_string tyByIdent name) then let __assign_70 = "" in (
        tempString1 := __assign_70;
        __assign_70
      ) else let t = HxMap.get_string tyByIdent name in if t == Obj.magic (HxRuntime.hx_null) then let __assign_71 = "" in (
        tempString1 := __assign_71;
        __assign_71
      ) else let __assign_72 = TyType.toString t () in (
        tempString1 := __assign_72;
        __assign_72
      ));
      let __assign_73 = HxString.equals (!tempString1) "Int" in (
        tempResult1 := __assign_73;
        __assign_73
      )
    )
    | _ -> let __assign_67 = false in (
      tempResult1 := __assign_67;
      __assign_67
    ));
  !tempResult1
) in let tempResult2 = ref "" in (
  ignore (match e with
    | HxExpr.ENull -> let __assign_74 = "(Obj.magic 0)" in (
      tempResult2 := __assign_74;
      __assign_74
    )
    | HxExpr.EBool _p0 -> let _g = _p0 in let v = _g in if v then let __assign_75 = "true" in (
      tempResult2 := __assign_75;
      __assign_75
    ) else let __assign_76 = "false" in (
      tempResult2 := __assign_76;
      __assign_76
    )
    | HxExpr.EString _p0 -> let _g = _p0 in let v = _g in let __assign_77 = escapeOcamlString v in (
      tempResult2 := __assign_77;
      __assign_77
    )
    | HxExpr.EInt _p0 -> let _g = _p0 in let v = _g in let __assign_78 = string_of_int v in (
      tempResult2 := __assign_78;
      __assign_78
    )
    | HxExpr.EFloat _p0 -> let _g = _p0 in let v = _g in let __assign_79 = string_of_float v in (
      tempResult2 := __assign_79;
      __assign_79
    )
    | HxExpr.EThis -> let __assign_80 = "(Obj.magic 0)" in (
      tempResult2 := __assign_80;
      __assign_80
    )
    | HxExpr.ESuper -> let __assign_81 = "(Obj.magic 0)" in (
      tempResult2 := __assign_81;
      __assign_81
    )
    | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in if isUpperStart name then let __assign_82 = name in (
      tempResult2 := __assign_82;
      __assign_82
    ) else let __assign_83 = ocamlValueIdent name in (
      tempResult2 := __assign_83;
      __assign_83
    )
    | HxExpr.EField (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in if (match _g with
      | HxExpr.ENull -> 0
      | HxExpr.EBool _ -> 1
      | HxExpr.EString _ -> 2
      | HxExpr.EInt _ -> 3
      | HxExpr.EFloat _ -> 4
      | HxExpr.EThis -> 5
      | HxExpr.ESuper -> 6
      | HxExpr.EIdent _ -> 7
      | HxExpr.EField (_, _) -> 8
      | HxExpr.ECall (_, _) -> 9
      | HxExpr.ENew (_, _) -> 10
      | HxExpr.EUnop (_, _) -> 11
      | HxExpr.EBinop (_, _, _) -> 12
      | HxExpr.ETernary (_, _, _) -> 13
      | HxExpr.EAnon (_, _) -> 14
      | HxExpr.EArrayDecl _ -> 15
      | HxExpr.EArrayAccess (_, _) -> 16
      | HxExpr.ECast (_, _) -> 17
      | HxExpr.EUntyped _ -> 18
      | HxExpr.EUnsupported _ -> 19) = 7 then let _g2 = match _g with
      | HxExpr.EIdent __enum_param_84 -> __enum_param_84
      | _ -> failwith "Unexpected enum parameter" in if HxString.equals _g2 "Math" then match _g1 with
      | "NEGATIVE_INFINITY" -> let __assign_86 = "neg_infinity" in (
        tempResult2 := __assign_86;
        __assign_86
      )
      | "NaN" -> let __assign_87 = "nan" in (
        tempResult2 := __assign_87;
        __assign_87
      )
      | "PI" -> let __assign_88 = "(4.0 *. atan 1.0)" in (
        tempResult2 := __assign_88;
        __assign_88
      )
      | "POSITIVE_INFINITY" -> let __assign_89 = "infinity" in (
        tempResult2 := __assign_89;
        __assign_89
      )
      | _ -> let obj = _g in let field = _g1 in let __assign_85 = (HxString.toStdString (exprToOcaml obj arityByIdent tyByIdent) ^ ".") ^ HxString.toStdString (ocamlValueIdent field) in (
        tempResult2 := __assign_85;
        __assign_85
      ) else let obj = _g in let field = _g1 in let __assign_90 = (HxString.toStdString (exprToOcaml obj arityByIdent tyByIdent) ^ ".") ^ HxString.toStdString (ocamlValueIdent field) in (
      tempResult2 := __assign_90;
      __assign_90
    ) else let obj = _g in let field = _g1 in let __assign_91 = (HxString.toStdString (exprToOcaml obj arityByIdent tyByIdent) ^ ".") ^ HxString.toStdString (ocamlValueIdent field) in (
      tempResult2 := __assign_91;
      __assign_91
    )
    | HxExpr.ECall (_p0, _p1) -> (let _g = _p0 in let _g1 = _p1 in match _g with
      | HxExpr.EIdent _p0 -> let _g2 = _p0 in if HxString.equals _g2 "trace" then if HxArray.length _g1 = 1 then let _g3 = HxArray.get _g1 0 in let arg = _g3 in let __assign_114 = ("print_endline (" ^ HxString.toStdString (exprToOcamlString arg tyByIdent)) ^ ")" in (
        tempResult2 := __assign_114;
        __assign_114
      ) else let callee = _g in let args = _g1 in let tempNumber = ref 0 in (
        ignore (match callee with
          | HxExpr.EIdent _p0 -> let _g3 = _p0 in let name = _g3 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_116 = expected in let __nullable_117 = HxArray.length args in if __nullable_116 == HxRuntime.hx_null then false else Obj.obj __nullable_116 > __nullable_117) then let __assign_118 = HxInt.sub (let __nullable_int_119 = expected in if __nullable_int_119 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_119) (HxArray.length args) in (
            tempNumber := __assign_118;
            __assign_118
          ) else let __assign_120 = 0 in (
            tempNumber := __assign_120;
            __assign_120
          ) else let __assign_121 = 0 in (
            tempNumber := __assign_121;
            __assign_121
          )
          | HxExpr.EField (_p0, _p1) -> let _g3 = _p0 in let _g4 = _p1 in if (match _g3 with
            | HxExpr.ENull -> 0
            | HxExpr.EBool _ -> 1
            | HxExpr.EString _ -> 2
            | HxExpr.EInt _ -> 3
            | HxExpr.EFloat _ -> 4
            | HxExpr.EThis -> 5
            | HxExpr.ESuper -> 6
            | HxExpr.EIdent _ -> 7
            | HxExpr.EField (_, _) -> 8
            | HxExpr.ECall (_, _) -> 9
            | HxExpr.ENew (_, _) -> 10
            | HxExpr.EUnop (_, _) -> 11
            | HxExpr.EBinop (_, _, _) -> 12
            | HxExpr.ETernary (_, _, _) -> 13
            | HxExpr.EAnon (_, _) -> 14
            | HxExpr.EArrayDecl _ -> 15
            | HxExpr.EArrayAccess (_, _) -> 16
            | HxExpr.ECast (_, _) -> 17
            | HxExpr.EUntyped _ -> 18
            | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g4 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_122 = expected in let __nullable_123 = HxArray.length args in if __nullable_122 == HxRuntime.hx_null then false else Obj.obj __nullable_122 > __nullable_123) then let __assign_124 = HxInt.sub (let __nullable_int_125 = expected in if __nullable_int_125 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_125) (HxArray.length args) in (
            tempNumber := __assign_124;
            __assign_124
          ) else let __assign_126 = 0 in (
            tempNumber := __assign_126;
            __assign_126
          ) else let __assign_127 = 0 in (
            tempNumber := __assign_127;
            __assign_127
          ) else let __assign_128 = 0 in (
            tempNumber := __assign_128;
            __assign_128
          )
          | _ -> let __assign_115 = 0 in (
            tempNumber := __assign_115;
            __assign_115
          ));
        let missing = !tempNumber in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
          ignore (let _g3 = ref 0 in let _g4 = missing in while !_g3 < _g4 do ignore ((
            ignore (let __old_129 = !_g3 in let __new_130 = HxInt.add __old_129 1 in (
              ignore (_g3 := __new_130);
              __old_129
            ));
            HxArray.push fullArgs (HxExpr.ENull)
          )) done);
          if HxArray.length fullArgs = 0 then let __assign_131 = HxString.toStdString c ^ " ()" in (
            tempResult2 := __assign_131;
            __assign_131
          ) else let tempArray = ref (Obj.magic ()) in (
            ignore (let _g3 = let __arr_132 = HxArray.create () in __arr_132 in (
              ignore (let _g4 = ref 0 in let _g5 = fullArgs in while !_g4 < HxArray.length _g5 do ignore (let v = HxArray.get _g5 (!_g4) in (
                ignore (let __old_133 = !_g4 in let __new_134 = HxInt.add __old_133 1 in (
                  ignore (_g4 := __new_134);
                  __new_134
                ));
                HxArray.push _g3 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
              )) done);
              let __assign_135 = _g3 in (
                tempArray := __assign_135;
                __assign_135
              )
            ));
            let __assign_136 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray) " " (fun x -> x)) in (
              tempResult2 := __assign_136;
              __assign_136
            )
          )
        )
      ) else let callee = _g in let args = _g1 in let tempNumber1 = ref 0 in (
        ignore (match callee with
          | HxExpr.EIdent _p0 -> let _g3 = _p0 in let name = _g3 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_138 = expected in let __nullable_139 = HxArray.length args in if __nullable_138 == HxRuntime.hx_null then false else Obj.obj __nullable_138 > __nullable_139) then let __assign_140 = HxInt.sub (let __nullable_int_141 = expected in if __nullable_int_141 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_141) (HxArray.length args) in (
            tempNumber1 := __assign_140;
            __assign_140
          ) else let __assign_142 = 0 in (
            tempNumber1 := __assign_142;
            __assign_142
          ) else let __assign_143 = 0 in (
            tempNumber1 := __assign_143;
            __assign_143
          )
          | HxExpr.EField (_p0, _p1) -> let _g3 = _p0 in let _g4 = _p1 in if (match _g3 with
            | HxExpr.ENull -> 0
            | HxExpr.EBool _ -> 1
            | HxExpr.EString _ -> 2
            | HxExpr.EInt _ -> 3
            | HxExpr.EFloat _ -> 4
            | HxExpr.EThis -> 5
            | HxExpr.ESuper -> 6
            | HxExpr.EIdent _ -> 7
            | HxExpr.EField (_, _) -> 8
            | HxExpr.ECall (_, _) -> 9
            | HxExpr.ENew (_, _) -> 10
            | HxExpr.EUnop (_, _) -> 11
            | HxExpr.EBinop (_, _, _) -> 12
            | HxExpr.ETernary (_, _, _) -> 13
            | HxExpr.EAnon (_, _) -> 14
            | HxExpr.EArrayDecl _ -> 15
            | HxExpr.EArrayAccess (_, _) -> 16
            | HxExpr.ECast (_, _) -> 17
            | HxExpr.EUntyped _ -> 18
            | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g4 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_144 = expected in let __nullable_145 = HxArray.length args in if __nullable_144 == HxRuntime.hx_null then false else Obj.obj __nullable_144 > __nullable_145) then let __assign_146 = HxInt.sub (let __nullable_int_147 = expected in if __nullable_int_147 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_147) (HxArray.length args) in (
            tempNumber1 := __assign_146;
            __assign_146
          ) else let __assign_148 = 0 in (
            tempNumber1 := __assign_148;
            __assign_148
          ) else let __assign_149 = 0 in (
            tempNumber1 := __assign_149;
            __assign_149
          ) else let __assign_150 = 0 in (
            tempNumber1 := __assign_150;
            __assign_150
          )
          | _ -> let __assign_137 = 0 in (
            tempNumber1 := __assign_137;
            __assign_137
          ));
        let missing = !tempNumber1 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
          ignore (let _g3 = ref 0 in let _g4 = missing in while !_g3 < _g4 do ignore ((
            ignore (let __old_151 = !_g3 in let __new_152 = HxInt.add __old_151 1 in (
              ignore (_g3 := __new_152);
              __old_151
            ));
            HxArray.push fullArgs (HxExpr.ENull)
          )) done);
          if HxArray.length fullArgs = 0 then let __assign_153 = HxString.toStdString c ^ " ()" in (
            tempResult2 := __assign_153;
            __assign_153
          ) else let tempArray1 = ref (Obj.magic ()) in (
            ignore (let _g3 = let __arr_154 = HxArray.create () in __arr_154 in (
              ignore (let _g4 = ref 0 in let _g5 = fullArgs in while !_g4 < HxArray.length _g5 do ignore (let v = HxArray.get _g5 (!_g4) in (
                ignore (let __old_155 = !_g4 in let __new_156 = HxInt.add __old_155 1 in (
                  ignore (_g4 := __new_156);
                  __new_156
                ));
                HxArray.push _g3 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
              )) done);
              let __assign_157 = _g3 in (
                tempArray1 := __assign_157;
                __assign_157
              )
            ));
            let __assign_158 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray1) " " (fun x -> x)) in (
              tempResult2 := __assign_158;
              __assign_158
            )
          )
        )
      )
      | HxExpr.EField (_p0, _p1) -> let _g2 = _p0 in let _g3 = _p1 in if (match _g2 with
        | HxExpr.ENull -> 0
        | HxExpr.EBool _ -> 1
        | HxExpr.EString _ -> 2
        | HxExpr.EInt _ -> 3
        | HxExpr.EFloat _ -> 4
        | HxExpr.EThis -> 5
        | HxExpr.ESuper -> 6
        | HxExpr.EIdent _ -> 7
        | HxExpr.EField (_, _) -> 8
        | HxExpr.ECall (_, _) -> 9
        | HxExpr.ENew (_, _) -> 10
        | HxExpr.EUnop (_, _) -> 11
        | HxExpr.EBinop (_, _, _) -> 12
        | HxExpr.ETernary (_, _, _) -> 13
        | HxExpr.EAnon (_, _) -> 14
        | HxExpr.EArrayDecl _ -> 15
        | HxExpr.EArrayAccess (_, _) -> 16
        | HxExpr.ECast (_, _) -> 17
        | HxExpr.EUntyped _ -> 18
        | HxExpr.EUnsupported _ -> 19) = 7 then let _g4 = match _g2 with
        | HxExpr.EIdent __enum_param_159 -> __enum_param_159
        | _ -> failwith "Unexpected enum parameter" in match _g4 with
        | "Math" -> (match _g3 with
          | "abs" -> if HxArray.length _g1 = 1 then let _g5 = HxArray.get _g1 0 in let arg = _g5 in let tempString2 = ref "" in (
            ignore (if isFloatExpr arg then let __assign_204 = "abs_float " in (
              tempString2 := __assign_204;
              __assign_204
            ) else if isIntExpr arg then let __assign_205 = "abs " in (
              tempString2 := __assign_205;
              __assign_205
            ) else let __assign_206 = "abs_float " in (
              tempString2 := __assign_206;
              __assign_206
            ));
            let __assign_207 = ((HxString.toStdString (!tempString2) ^ "(") ^ HxString.toStdString (exprToOcaml arg arityByIdent tyByIdent)) ^ ")" in (
              tempResult2 := __assign_207;
              __assign_207
            )
          ) else let callee = _g in let args = _g1 in let tempNumber2 = ref 0 in (
            ignore (match callee with
              | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_209 = expected in let __nullable_210 = HxArray.length args in if __nullable_209 == HxRuntime.hx_null then false else Obj.obj __nullable_209 > __nullable_210) then let __assign_211 = HxInt.sub (let __nullable_int_212 = expected in if __nullable_int_212 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_212) (HxArray.length args) in (
                tempNumber2 := __assign_211;
                __assign_211
              ) else let __assign_213 = 0 in (
                tempNumber2 := __assign_213;
                __assign_213
              ) else let __assign_214 = 0 in (
                tempNumber2 := __assign_214;
                __assign_214
              )
              | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
                | HxExpr.ENull -> 0
                | HxExpr.EBool _ -> 1
                | HxExpr.EString _ -> 2
                | HxExpr.EInt _ -> 3
                | HxExpr.EFloat _ -> 4
                | HxExpr.EThis -> 5
                | HxExpr.ESuper -> 6
                | HxExpr.EIdent _ -> 7
                | HxExpr.EField (_, _) -> 8
                | HxExpr.ECall (_, _) -> 9
                | HxExpr.ENew (_, _) -> 10
                | HxExpr.EUnop (_, _) -> 11
                | HxExpr.EBinop (_, _, _) -> 12
                | HxExpr.ETernary (_, _, _) -> 13
                | HxExpr.EAnon (_, _) -> 14
                | HxExpr.EArrayDecl _ -> 15
                | HxExpr.EArrayAccess (_, _) -> 16
                | HxExpr.ECast (_, _) -> 17
                | HxExpr.EUntyped _ -> 18
                | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_215 = expected in let __nullable_216 = HxArray.length args in if __nullable_215 == HxRuntime.hx_null then false else Obj.obj __nullable_215 > __nullable_216) then let __assign_217 = HxInt.sub (let __nullable_int_218 = expected in if __nullable_int_218 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_218) (HxArray.length args) in (
                tempNumber2 := __assign_217;
                __assign_217
              ) else let __assign_219 = 0 in (
                tempNumber2 := __assign_219;
                __assign_219
              ) else let __assign_220 = 0 in (
                tempNumber2 := __assign_220;
                __assign_220
              ) else let __assign_221 = 0 in (
                tempNumber2 := __assign_221;
                __assign_221
              )
              | _ -> let __assign_208 = 0 in (
                tempNumber2 := __assign_208;
                __assign_208
              ));
            let missing = !tempNumber2 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
              ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
                ignore (let __old_222 = !_g5 in let __new_223 = HxInt.add __old_222 1 in (
                  ignore (_g5 := __new_223);
                  __old_222
                ));
                HxArray.push fullArgs (HxExpr.ENull)
              )) done);
              if HxArray.length fullArgs = 0 then let __assign_224 = HxString.toStdString c ^ " ()" in (
                tempResult2 := __assign_224;
                __assign_224
              ) else let tempArray2 = ref (Obj.magic ()) in (
                ignore (let _g5 = let __arr_225 = HxArray.create () in __arr_225 in (
                  ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                    ignore (let __old_226 = !_g6 in let __new_227 = HxInt.add __old_226 1 in (
                      ignore (_g6 := __new_227);
                      __new_227
                    ));
                    HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                  )) done);
                  let __assign_228 = _g5 in (
                    tempArray2 := __assign_228;
                    __assign_228
                  )
                ));
                let __assign_229 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray2) " " (fun x -> x)) in (
                  tempResult2 := __assign_229;
                  __assign_229
                )
              )
            )
          )
          | "isFinite" -> if HxArray.length _g1 = 1 then let _g5 = HxArray.get _g1 0 in let arg = _g5 in let __assign_230 = ("(match classify_float (" ^ HxString.toStdString (exprToOcaml arg arityByIdent tyByIdent)) ^ ") with | FP_nan | FP_infinite -> false | _ -> true)" in (
            tempResult2 := __assign_230;
            __assign_230
          ) else let callee = _g in let args = _g1 in let tempNumber3 = ref 0 in (
            ignore (match callee with
              | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_232 = expected in let __nullable_233 = HxArray.length args in if __nullable_232 == HxRuntime.hx_null then false else Obj.obj __nullable_232 > __nullable_233) then let __assign_234 = HxInt.sub (let __nullable_int_235 = expected in if __nullable_int_235 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_235) (HxArray.length args) in (
                tempNumber3 := __assign_234;
                __assign_234
              ) else let __assign_236 = 0 in (
                tempNumber3 := __assign_236;
                __assign_236
              ) else let __assign_237 = 0 in (
                tempNumber3 := __assign_237;
                __assign_237
              )
              | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
                | HxExpr.ENull -> 0
                | HxExpr.EBool _ -> 1
                | HxExpr.EString _ -> 2
                | HxExpr.EInt _ -> 3
                | HxExpr.EFloat _ -> 4
                | HxExpr.EThis -> 5
                | HxExpr.ESuper -> 6
                | HxExpr.EIdent _ -> 7
                | HxExpr.EField (_, _) -> 8
                | HxExpr.ECall (_, _) -> 9
                | HxExpr.ENew (_, _) -> 10
                | HxExpr.EUnop (_, _) -> 11
                | HxExpr.EBinop (_, _, _) -> 12
                | HxExpr.ETernary (_, _, _) -> 13
                | HxExpr.EAnon (_, _) -> 14
                | HxExpr.EArrayDecl _ -> 15
                | HxExpr.EArrayAccess (_, _) -> 16
                | HxExpr.ECast (_, _) -> 17
                | HxExpr.EUntyped _ -> 18
                | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_238 = expected in let __nullable_239 = HxArray.length args in if __nullable_238 == HxRuntime.hx_null then false else Obj.obj __nullable_238 > __nullable_239) then let __assign_240 = HxInt.sub (let __nullable_int_241 = expected in if __nullable_int_241 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_241) (HxArray.length args) in (
                tempNumber3 := __assign_240;
                __assign_240
              ) else let __assign_242 = 0 in (
                tempNumber3 := __assign_242;
                __assign_242
              ) else let __assign_243 = 0 in (
                tempNumber3 := __assign_243;
                __assign_243
              ) else let __assign_244 = 0 in (
                tempNumber3 := __assign_244;
                __assign_244
              )
              | _ -> let __assign_231 = 0 in (
                tempNumber3 := __assign_231;
                __assign_231
              ));
            let missing = !tempNumber3 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
              ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
                ignore (let __old_245 = !_g5 in let __new_246 = HxInt.add __old_245 1 in (
                  ignore (_g5 := __new_246);
                  __old_245
                ));
                HxArray.push fullArgs (HxExpr.ENull)
              )) done);
              if HxArray.length fullArgs = 0 then let __assign_247 = HxString.toStdString c ^ " ()" in (
                tempResult2 := __assign_247;
                __assign_247
              ) else let tempArray3 = ref (Obj.magic ()) in (
                ignore (let _g5 = let __arr_248 = HxArray.create () in __arr_248 in (
                  ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                    ignore (let __old_249 = !_g6 in let __new_250 = HxInt.add __old_249 1 in (
                      ignore (_g6 := __new_250);
                      __new_250
                    ));
                    HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                  )) done);
                  let __assign_251 = _g5 in (
                    tempArray3 := __assign_251;
                    __assign_251
                  )
                ));
                let __assign_252 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray3) " " (fun x -> x)) in (
                  tempResult2 := __assign_252;
                  __assign_252
                )
              )
            )
          )
          | "isInfinite" -> if HxArray.length _g1 = 1 then let _g5 = HxArray.get _g1 0 in let arg = _g5 in let __assign_253 = ("(classify_float (" ^ HxString.toStdString (exprToOcaml arg arityByIdent tyByIdent)) ^ ") = FP_infinite)" in (
            tempResult2 := __assign_253;
            __assign_253
          ) else let callee = _g in let args = _g1 in let tempNumber4 = ref 0 in (
            ignore (match callee with
              | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_255 = expected in let __nullable_256 = HxArray.length args in if __nullable_255 == HxRuntime.hx_null then false else Obj.obj __nullable_255 > __nullable_256) then let __assign_257 = HxInt.sub (let __nullable_int_258 = expected in if __nullable_int_258 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_258) (HxArray.length args) in (
                tempNumber4 := __assign_257;
                __assign_257
              ) else let __assign_259 = 0 in (
                tempNumber4 := __assign_259;
                __assign_259
              ) else let __assign_260 = 0 in (
                tempNumber4 := __assign_260;
                __assign_260
              )
              | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
                | HxExpr.ENull -> 0
                | HxExpr.EBool _ -> 1
                | HxExpr.EString _ -> 2
                | HxExpr.EInt _ -> 3
                | HxExpr.EFloat _ -> 4
                | HxExpr.EThis -> 5
                | HxExpr.ESuper -> 6
                | HxExpr.EIdent _ -> 7
                | HxExpr.EField (_, _) -> 8
                | HxExpr.ECall (_, _) -> 9
                | HxExpr.ENew (_, _) -> 10
                | HxExpr.EUnop (_, _) -> 11
                | HxExpr.EBinop (_, _, _) -> 12
                | HxExpr.ETernary (_, _, _) -> 13
                | HxExpr.EAnon (_, _) -> 14
                | HxExpr.EArrayDecl _ -> 15
                | HxExpr.EArrayAccess (_, _) -> 16
                | HxExpr.ECast (_, _) -> 17
                | HxExpr.EUntyped _ -> 18
                | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_261 = expected in let __nullable_262 = HxArray.length args in if __nullable_261 == HxRuntime.hx_null then false else Obj.obj __nullable_261 > __nullable_262) then let __assign_263 = HxInt.sub (let __nullable_int_264 = expected in if __nullable_int_264 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_264) (HxArray.length args) in (
                tempNumber4 := __assign_263;
                __assign_263
              ) else let __assign_265 = 0 in (
                tempNumber4 := __assign_265;
                __assign_265
              ) else let __assign_266 = 0 in (
                tempNumber4 := __assign_266;
                __assign_266
              ) else let __assign_267 = 0 in (
                tempNumber4 := __assign_267;
                __assign_267
              )
              | _ -> let __assign_254 = 0 in (
                tempNumber4 := __assign_254;
                __assign_254
              ));
            let missing = !tempNumber4 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
              ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
                ignore (let __old_268 = !_g5 in let __new_269 = HxInt.add __old_268 1 in (
                  ignore (_g5 := __new_269);
                  __old_268
                ));
                HxArray.push fullArgs (HxExpr.ENull)
              )) done);
              if HxArray.length fullArgs = 0 then let __assign_270 = HxString.toStdString c ^ " ()" in (
                tempResult2 := __assign_270;
                __assign_270
              ) else let tempArray4 = ref (Obj.magic ()) in (
                ignore (let _g5 = let __arr_271 = HxArray.create () in __arr_271 in (
                  ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                    ignore (let __old_272 = !_g6 in let __new_273 = HxInt.add __old_272 1 in (
                      ignore (_g6 := __new_273);
                      __new_273
                    ));
                    HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                  )) done);
                  let __assign_274 = _g5 in (
                    tempArray4 := __assign_274;
                    __assign_274
                  )
                ));
                let __assign_275 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray4) " " (fun x -> x)) in (
                  tempResult2 := __assign_275;
                  __assign_275
                )
              )
            )
          )
          | "isNaN" -> if HxArray.length _g1 = 1 then let _g5 = HxArray.get _g1 0 in let arg = _g5 in let __assign_276 = ("(classify_float (" ^ HxString.toStdString (exprToOcaml arg arityByIdent tyByIdent)) ^ ") = FP_nan)" in (
            tempResult2 := __assign_276;
            __assign_276
          ) else let callee = _g in let args = _g1 in let tempNumber5 = ref 0 in (
            ignore (match callee with
              | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_278 = expected in let __nullable_279 = HxArray.length args in if __nullable_278 == HxRuntime.hx_null then false else Obj.obj __nullable_278 > __nullable_279) then let __assign_280 = HxInt.sub (let __nullable_int_281 = expected in if __nullable_int_281 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_281) (HxArray.length args) in (
                tempNumber5 := __assign_280;
                __assign_280
              ) else let __assign_282 = 0 in (
                tempNumber5 := __assign_282;
                __assign_282
              ) else let __assign_283 = 0 in (
                tempNumber5 := __assign_283;
                __assign_283
              )
              | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
                | HxExpr.ENull -> 0
                | HxExpr.EBool _ -> 1
                | HxExpr.EString _ -> 2
                | HxExpr.EInt _ -> 3
                | HxExpr.EFloat _ -> 4
                | HxExpr.EThis -> 5
                | HxExpr.ESuper -> 6
                | HxExpr.EIdent _ -> 7
                | HxExpr.EField (_, _) -> 8
                | HxExpr.ECall (_, _) -> 9
                | HxExpr.ENew (_, _) -> 10
                | HxExpr.EUnop (_, _) -> 11
                | HxExpr.EBinop (_, _, _) -> 12
                | HxExpr.ETernary (_, _, _) -> 13
                | HxExpr.EAnon (_, _) -> 14
                | HxExpr.EArrayDecl _ -> 15
                | HxExpr.EArrayAccess (_, _) -> 16
                | HxExpr.ECast (_, _) -> 17
                | HxExpr.EUntyped _ -> 18
                | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_284 = expected in let __nullable_285 = HxArray.length args in if __nullable_284 == HxRuntime.hx_null then false else Obj.obj __nullable_284 > __nullable_285) then let __assign_286 = HxInt.sub (let __nullable_int_287 = expected in if __nullable_int_287 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_287) (HxArray.length args) in (
                tempNumber5 := __assign_286;
                __assign_286
              ) else let __assign_288 = 0 in (
                tempNumber5 := __assign_288;
                __assign_288
              ) else let __assign_289 = 0 in (
                tempNumber5 := __assign_289;
                __assign_289
              ) else let __assign_290 = 0 in (
                tempNumber5 := __assign_290;
                __assign_290
              )
              | _ -> let __assign_277 = 0 in (
                tempNumber5 := __assign_277;
                __assign_277
              ));
            let missing = !tempNumber5 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
              ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
                ignore (let __old_291 = !_g5 in let __new_292 = HxInt.add __old_291 1 in (
                  ignore (_g5 := __new_292);
                  __old_291
                ));
                HxArray.push fullArgs (HxExpr.ENull)
              )) done);
              if HxArray.length fullArgs = 0 then let __assign_293 = HxString.toStdString c ^ " ()" in (
                tempResult2 := __assign_293;
                __assign_293
              ) else let tempArray5 = ref (Obj.magic ()) in (
                ignore (let _g5 = let __arr_294 = HxArray.create () in __arr_294 in (
                  ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                    ignore (let __old_295 = !_g6 in let __new_296 = HxInt.add __old_295 1 in (
                      ignore (_g6 := __new_296);
                      __new_296
                    ));
                    HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                  )) done);
                  let __assign_297 = _g5 in (
                    tempArray5 := __assign_297;
                    __assign_297
                  )
                ));
                let __assign_298 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray5) " " (fun x -> x)) in (
                  tempResult2 := __assign_298;
                  __assign_298
                )
              )
            )
          )
          | _ -> let callee = _g in let args = _g1 in let tempNumber6 = ref 0 in (
            ignore (match callee with
              | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_183 = expected in let __nullable_184 = HxArray.length args in if __nullable_183 == HxRuntime.hx_null then false else Obj.obj __nullable_183 > __nullable_184) then let __assign_185 = HxInt.sub (let __nullable_int_186 = expected in if __nullable_int_186 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_186) (HxArray.length args) in (
                tempNumber6 := __assign_185;
                __assign_185
              ) else let __assign_187 = 0 in (
                tempNumber6 := __assign_187;
                __assign_187
              ) else let __assign_188 = 0 in (
                tempNumber6 := __assign_188;
                __assign_188
              )
              | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
                | HxExpr.ENull -> 0
                | HxExpr.EBool _ -> 1
                | HxExpr.EString _ -> 2
                | HxExpr.EInt _ -> 3
                | HxExpr.EFloat _ -> 4
                | HxExpr.EThis -> 5
                | HxExpr.ESuper -> 6
                | HxExpr.EIdent _ -> 7
                | HxExpr.EField (_, _) -> 8
                | HxExpr.ECall (_, _) -> 9
                | HxExpr.ENew (_, _) -> 10
                | HxExpr.EUnop (_, _) -> 11
                | HxExpr.EBinop (_, _, _) -> 12
                | HxExpr.ETernary (_, _, _) -> 13
                | HxExpr.EAnon (_, _) -> 14
                | HxExpr.EArrayDecl _ -> 15
                | HxExpr.EArrayAccess (_, _) -> 16
                | HxExpr.ECast (_, _) -> 17
                | HxExpr.EUntyped _ -> 18
                | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_189 = expected in let __nullable_190 = HxArray.length args in if __nullable_189 == HxRuntime.hx_null then false else Obj.obj __nullable_189 > __nullable_190) then let __assign_191 = HxInt.sub (let __nullable_int_192 = expected in if __nullable_int_192 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_192) (HxArray.length args) in (
                tempNumber6 := __assign_191;
                __assign_191
              ) else let __assign_193 = 0 in (
                tempNumber6 := __assign_193;
                __assign_193
              ) else let __assign_194 = 0 in (
                tempNumber6 := __assign_194;
                __assign_194
              ) else let __assign_195 = 0 in (
                tempNumber6 := __assign_195;
                __assign_195
              )
              | _ -> let __assign_182 = 0 in (
                tempNumber6 := __assign_182;
                __assign_182
              ));
            let missing = !tempNumber6 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
              ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
                ignore (let __old_196 = !_g5 in let __new_197 = HxInt.add __old_196 1 in (
                  ignore (_g5 := __new_197);
                  __old_196
                ));
                HxArray.push fullArgs (HxExpr.ENull)
              )) done);
              if HxArray.length fullArgs = 0 then let __assign_198 = HxString.toStdString c ^ " ()" in (
                tempResult2 := __assign_198;
                __assign_198
              ) else let tempArray6 = ref (Obj.magic ()) in (
                ignore (let _g5 = let __arr_199 = HxArray.create () in __arr_199 in (
                  ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                    ignore (let __old_200 = !_g6 in let __new_201 = HxInt.add __old_200 1 in (
                      ignore (_g6 := __new_201);
                      __new_201
                    ));
                    HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                  )) done);
                  let __assign_202 = _g5 in (
                    tempArray6 := __assign_202;
                    __assign_202
                  )
                ));
                let __assign_203 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray6) " " (fun x -> x)) in (
                  tempResult2 := __assign_203;
                  __assign_203
                )
              )
            )
          ))
        | "Sys" -> if HxString.equals _g3 "println" then if HxArray.length _g1 = 1 then let _g5 = HxArray.get _g1 0 in let arg = _g5 in let __assign_299 = ("print_endline (" ^ HxString.toStdString (exprToOcamlString arg tyByIdent)) ^ ")" in (
          tempResult2 := __assign_299;
          __assign_299
        ) else let callee = _g in let args = _g1 in let tempNumber7 = ref 0 in (
          ignore (match callee with
            | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_301 = expected in let __nullable_302 = HxArray.length args in if __nullable_301 == HxRuntime.hx_null then false else Obj.obj __nullable_301 > __nullable_302) then let __assign_303 = HxInt.sub (let __nullable_int_304 = expected in if __nullable_int_304 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_304) (HxArray.length args) in (
              tempNumber7 := __assign_303;
              __assign_303
            ) else let __assign_305 = 0 in (
              tempNumber7 := __assign_305;
              __assign_305
            ) else let __assign_306 = 0 in (
              tempNumber7 := __assign_306;
              __assign_306
            )
            | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
              | HxExpr.ENull -> 0
              | HxExpr.EBool _ -> 1
              | HxExpr.EString _ -> 2
              | HxExpr.EInt _ -> 3
              | HxExpr.EFloat _ -> 4
              | HxExpr.EThis -> 5
              | HxExpr.ESuper -> 6
              | HxExpr.EIdent _ -> 7
              | HxExpr.EField (_, _) -> 8
              | HxExpr.ECall (_, _) -> 9
              | HxExpr.ENew (_, _) -> 10
              | HxExpr.EUnop (_, _) -> 11
              | HxExpr.EBinop (_, _, _) -> 12
              | HxExpr.ETernary (_, _, _) -> 13
              | HxExpr.EAnon (_, _) -> 14
              | HxExpr.EArrayDecl _ -> 15
              | HxExpr.EArrayAccess (_, _) -> 16
              | HxExpr.ECast (_, _) -> 17
              | HxExpr.EUntyped _ -> 18
              | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_307 = expected in let __nullable_308 = HxArray.length args in if __nullable_307 == HxRuntime.hx_null then false else Obj.obj __nullable_307 > __nullable_308) then let __assign_309 = HxInt.sub (let __nullable_int_310 = expected in if __nullable_int_310 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_310) (HxArray.length args) in (
              tempNumber7 := __assign_309;
              __assign_309
            ) else let __assign_311 = 0 in (
              tempNumber7 := __assign_311;
              __assign_311
            ) else let __assign_312 = 0 in (
              tempNumber7 := __assign_312;
              __assign_312
            ) else let __assign_313 = 0 in (
              tempNumber7 := __assign_313;
              __assign_313
            )
            | _ -> let __assign_300 = 0 in (
              tempNumber7 := __assign_300;
              __assign_300
            ));
          let missing = !tempNumber7 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
            ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
              ignore (let __old_314 = !_g5 in let __new_315 = HxInt.add __old_314 1 in (
                ignore (_g5 := __new_315);
                __old_314
              ));
              HxArray.push fullArgs (HxExpr.ENull)
            )) done);
            if HxArray.length fullArgs = 0 then let __assign_316 = HxString.toStdString c ^ " ()" in (
              tempResult2 := __assign_316;
              __assign_316
            ) else let tempArray7 = ref (Obj.magic ()) in (
              ignore (let _g5 = let __arr_317 = HxArray.create () in __arr_317 in (
                ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                  ignore (let __old_318 = !_g6 in let __new_319 = HxInt.add __old_318 1 in (
                    ignore (_g6 := __new_319);
                    __new_319
                  ));
                  HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                )) done);
                let __assign_320 = _g5 in (
                  tempArray7 := __assign_320;
                  __assign_320
                )
              ));
              let __assign_321 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray7) " " (fun x -> x)) in (
                tempResult2 := __assign_321;
                __assign_321
              )
            )
          )
        ) else let callee = _g in let args = _g1 in let tempNumber8 = ref 0 in (
          ignore (match callee with
            | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_323 = expected in let __nullable_324 = HxArray.length args in if __nullable_323 == HxRuntime.hx_null then false else Obj.obj __nullable_323 > __nullable_324) then let __assign_325 = HxInt.sub (let __nullable_int_326 = expected in if __nullable_int_326 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_326) (HxArray.length args) in (
              tempNumber8 := __assign_325;
              __assign_325
            ) else let __assign_327 = 0 in (
              tempNumber8 := __assign_327;
              __assign_327
            ) else let __assign_328 = 0 in (
              tempNumber8 := __assign_328;
              __assign_328
            )
            | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
              | HxExpr.ENull -> 0
              | HxExpr.EBool _ -> 1
              | HxExpr.EString _ -> 2
              | HxExpr.EInt _ -> 3
              | HxExpr.EFloat _ -> 4
              | HxExpr.EThis -> 5
              | HxExpr.ESuper -> 6
              | HxExpr.EIdent _ -> 7
              | HxExpr.EField (_, _) -> 8
              | HxExpr.ECall (_, _) -> 9
              | HxExpr.ENew (_, _) -> 10
              | HxExpr.EUnop (_, _) -> 11
              | HxExpr.EBinop (_, _, _) -> 12
              | HxExpr.ETernary (_, _, _) -> 13
              | HxExpr.EAnon (_, _) -> 14
              | HxExpr.EArrayDecl _ -> 15
              | HxExpr.EArrayAccess (_, _) -> 16
              | HxExpr.ECast (_, _) -> 17
              | HxExpr.EUntyped _ -> 18
              | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_329 = expected in let __nullable_330 = HxArray.length args in if __nullable_329 == HxRuntime.hx_null then false else Obj.obj __nullable_329 > __nullable_330) then let __assign_331 = HxInt.sub (let __nullable_int_332 = expected in if __nullable_int_332 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_332) (HxArray.length args) in (
              tempNumber8 := __assign_331;
              __assign_331
            ) else let __assign_333 = 0 in (
              tempNumber8 := __assign_333;
              __assign_333
            ) else let __assign_334 = 0 in (
              tempNumber8 := __assign_334;
              __assign_334
            ) else let __assign_335 = 0 in (
              tempNumber8 := __assign_335;
              __assign_335
            )
            | _ -> let __assign_322 = 0 in (
              tempNumber8 := __assign_322;
              __assign_322
            ));
          let missing = !tempNumber8 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
            ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
              ignore (let __old_336 = !_g5 in let __new_337 = HxInt.add __old_336 1 in (
                ignore (_g5 := __new_337);
                __old_336
              ));
              HxArray.push fullArgs (HxExpr.ENull)
            )) done);
            if HxArray.length fullArgs = 0 then let __assign_338 = HxString.toStdString c ^ " ()" in (
              tempResult2 := __assign_338;
              __assign_338
            ) else let tempArray8 = ref (Obj.magic ()) in (
              ignore (let _g5 = let __arr_339 = HxArray.create () in __arr_339 in (
                ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                  ignore (let __old_340 = !_g6 in let __new_341 = HxInt.add __old_340 1 in (
                    ignore (_g6 := __new_341);
                    __new_341
                  ));
                  HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                )) done);
                let __assign_342 = _g5 in (
                  tempArray8 := __assign_342;
                  __assign_342
                )
              ));
              let __assign_343 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray8) " " (fun x -> x)) in (
                tempResult2 := __assign_343;
                __assign_343
              )
            )
          )
        )
        | _ -> let callee = _g in let args = _g1 in let tempNumber9 = ref 0 in (
          ignore (match callee with
            | HxExpr.EIdent _p0 -> let _g5 = _p0 in let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_161 = expected in let __nullable_162 = HxArray.length args in if __nullable_161 == HxRuntime.hx_null then false else Obj.obj __nullable_161 > __nullable_162) then let __assign_163 = HxInt.sub (let __nullable_int_164 = expected in if __nullable_int_164 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_164) (HxArray.length args) in (
              tempNumber9 := __assign_163;
              __assign_163
            ) else let __assign_165 = 0 in (
              tempNumber9 := __assign_165;
              __assign_165
            ) else let __assign_166 = 0 in (
              tempNumber9 := __assign_166;
              __assign_166
            )
            | HxExpr.EField (_p0, _p1) -> let _g5 = _p0 in let _g6 = _p1 in if (match _g5 with
              | HxExpr.ENull -> 0
              | HxExpr.EBool _ -> 1
              | HxExpr.EString _ -> 2
              | HxExpr.EInt _ -> 3
              | HxExpr.EFloat _ -> 4
              | HxExpr.EThis -> 5
              | HxExpr.ESuper -> 6
              | HxExpr.EIdent _ -> 7
              | HxExpr.EField (_, _) -> 8
              | HxExpr.ECall (_, _) -> 9
              | HxExpr.ENew (_, _) -> 10
              | HxExpr.EUnop (_, _) -> 11
              | HxExpr.EBinop (_, _, _) -> 12
              | HxExpr.ETernary (_, _, _) -> 13
              | HxExpr.EAnon (_, _) -> 14
              | HxExpr.EArrayDecl _ -> 15
              | HxExpr.EArrayAccess (_, _) -> 16
              | HxExpr.ECast (_, _) -> 17
              | HxExpr.EUntyped _ -> 18
              | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g6 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_167 = expected in let __nullable_168 = HxArray.length args in if __nullable_167 == HxRuntime.hx_null then false else Obj.obj __nullable_167 > __nullable_168) then let __assign_169 = HxInt.sub (let __nullable_int_170 = expected in if __nullable_int_170 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_170) (HxArray.length args) in (
              tempNumber9 := __assign_169;
              __assign_169
            ) else let __assign_171 = 0 in (
              tempNumber9 := __assign_171;
              __assign_171
            ) else let __assign_172 = 0 in (
              tempNumber9 := __assign_172;
              __assign_172
            ) else let __assign_173 = 0 in (
              tempNumber9 := __assign_173;
              __assign_173
            )
            | _ -> let __assign_160 = 0 in (
              tempNumber9 := __assign_160;
              __assign_160
            ));
          let missing = !tempNumber9 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
            ignore (let _g5 = ref 0 in let _g6 = missing in while !_g5 < _g6 do ignore ((
              ignore (let __old_174 = !_g5 in let __new_175 = HxInt.add __old_174 1 in (
                ignore (_g5 := __new_175);
                __old_174
              ));
              HxArray.push fullArgs (HxExpr.ENull)
            )) done);
            if HxArray.length fullArgs = 0 then let __assign_176 = HxString.toStdString c ^ " ()" in (
              tempResult2 := __assign_176;
              __assign_176
            ) else let tempArray9 = ref (Obj.magic ()) in (
              ignore (let _g5 = let __arr_177 = HxArray.create () in __arr_177 in (
                ignore (let _g6 = ref 0 in let _g7 = fullArgs in while !_g6 < HxArray.length _g7 do ignore (let v = HxArray.get _g7 (!_g6) in (
                  ignore (let __old_178 = !_g6 in let __new_179 = HxInt.add __old_178 1 in (
                    ignore (_g6 := __new_179);
                    __new_179
                  ));
                  HxArray.push _g5 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
                )) done);
                let __assign_180 = _g5 in (
                  tempArray9 := __assign_180;
                  __assign_180
                )
              ));
              let __assign_181 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray9) " " (fun x -> x)) in (
                tempResult2 := __assign_181;
                __assign_181
              )
            )
          )
        ) else let callee = _g in let args = _g1 in let tempNumber10 = ref 0 in (
        ignore (match callee with
          | HxExpr.EIdent _p0 -> let _g4 = _p0 in let name = _g4 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_345 = expected in let __nullable_346 = HxArray.length args in if __nullable_345 == HxRuntime.hx_null then false else Obj.obj __nullable_345 > __nullable_346) then let __assign_347 = HxInt.sub (let __nullable_int_348 = expected in if __nullable_int_348 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_348) (HxArray.length args) in (
            tempNumber10 := __assign_347;
            __assign_347
          ) else let __assign_349 = 0 in (
            tempNumber10 := __assign_349;
            __assign_349
          ) else let __assign_350 = 0 in (
            tempNumber10 := __assign_350;
            __assign_350
          )
          | HxExpr.EField (_p0, _p1) -> let _g4 = _p0 in let _g5 = _p1 in if (match _g4 with
            | HxExpr.ENull -> 0
            | HxExpr.EBool _ -> 1
            | HxExpr.EString _ -> 2
            | HxExpr.EInt _ -> 3
            | HxExpr.EFloat _ -> 4
            | HxExpr.EThis -> 5
            | HxExpr.ESuper -> 6
            | HxExpr.EIdent _ -> 7
            | HxExpr.EField (_, _) -> 8
            | HxExpr.ECall (_, _) -> 9
            | HxExpr.ENew (_, _) -> 10
            | HxExpr.EUnop (_, _) -> 11
            | HxExpr.EBinop (_, _, _) -> 12
            | HxExpr.ETernary (_, _, _) -> 13
            | HxExpr.EAnon (_, _) -> 14
            | HxExpr.EArrayDecl _ -> 15
            | HxExpr.EArrayAccess (_, _) -> 16
            | HxExpr.ECast (_, _) -> 17
            | HxExpr.EUntyped _ -> 18
            | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g5 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_351 = expected in let __nullable_352 = HxArray.length args in if __nullable_351 == HxRuntime.hx_null then false else Obj.obj __nullable_351 > __nullable_352) then let __assign_353 = HxInt.sub (let __nullable_int_354 = expected in if __nullable_int_354 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_354) (HxArray.length args) in (
            tempNumber10 := __assign_353;
            __assign_353
          ) else let __assign_355 = 0 in (
            tempNumber10 := __assign_355;
            __assign_355
          ) else let __assign_356 = 0 in (
            tempNumber10 := __assign_356;
            __assign_356
          ) else let __assign_357 = 0 in (
            tempNumber10 := __assign_357;
            __assign_357
          )
          | _ -> let __assign_344 = 0 in (
            tempNumber10 := __assign_344;
            __assign_344
          ));
        let missing = !tempNumber10 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
          ignore (let _g4 = ref 0 in let _g5 = missing in while !_g4 < _g5 do ignore ((
            ignore (let __old_358 = !_g4 in let __new_359 = HxInt.add __old_358 1 in (
              ignore (_g4 := __new_359);
              __old_358
            ));
            HxArray.push fullArgs (HxExpr.ENull)
          )) done);
          if HxArray.length fullArgs = 0 then let __assign_360 = HxString.toStdString c ^ " ()" in (
            tempResult2 := __assign_360;
            __assign_360
          ) else let tempArray10 = ref (Obj.magic ()) in (
            ignore (let _g4 = let __arr_361 = HxArray.create () in __arr_361 in (
              ignore (let _g5 = ref 0 in let _g6 = fullArgs in while !_g5 < HxArray.length _g6 do ignore (let v = HxArray.get _g6 (!_g5) in (
                ignore (let __old_362 = !_g5 in let __new_363 = HxInt.add __old_362 1 in (
                  ignore (_g5 := __new_363);
                  __new_363
                ));
                HxArray.push _g4 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
              )) done);
              let __assign_364 = _g4 in (
                tempArray10 := __assign_364;
                __assign_364
              )
            ));
            let __assign_365 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray10) " " (fun x -> x)) in (
              tempResult2 := __assign_365;
              __assign_365
            )
          )
        )
      )
      | _ -> let callee = _g in let args = _g1 in let tempNumber11 = ref 0 in (
        ignore (match callee with
          | HxExpr.EIdent _p0 -> let _g2 = _p0 in let name = _g2 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_93 = expected in let __nullable_94 = HxArray.length args in if __nullable_93 == HxRuntime.hx_null then false else Obj.obj __nullable_93 > __nullable_94) then let __assign_95 = HxInt.sub (let __nullable_int_96 = expected in if __nullable_int_96 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_96) (HxArray.length args) in (
            tempNumber11 := __assign_95;
            __assign_95
          ) else let __assign_97 = 0 in (
            tempNumber11 := __assign_97;
            __assign_97
          ) else let __assign_98 = 0 in (
            tempNumber11 := __assign_98;
            __assign_98
          )
          | HxExpr.EField (_p0, _p1) -> let _g2 = _p0 in let _g3 = _p1 in if (match _g2 with
            | HxExpr.ENull -> 0
            | HxExpr.EBool _ -> 1
            | HxExpr.EString _ -> 2
            | HxExpr.EInt _ -> 3
            | HxExpr.EFloat _ -> 4
            | HxExpr.EThis -> 5
            | HxExpr.ESuper -> 6
            | HxExpr.EIdent _ -> 7
            | HxExpr.EField (_, _) -> 8
            | HxExpr.ECall (_, _) -> 9
            | HxExpr.ENew (_, _) -> 10
            | HxExpr.EUnop (_, _) -> 11
            | HxExpr.EBinop (_, _, _) -> 12
            | HxExpr.ETernary (_, _, _) -> 13
            | HxExpr.EAnon (_, _) -> 14
            | HxExpr.EArrayDecl _ -> 15
            | HxExpr.EArrayAccess (_, _) -> 16
            | HxExpr.ECast (_, _) -> 17
            | HxExpr.EUntyped _ -> 18
            | HxExpr.EUnsupported _ -> 19) = 5 then let name = _g3 in if arityByIdent != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string arityByIdent name then let expected = HxMap.get_string arityByIdent name in if expected != HxRuntime.hx_null && (let __nullable_99 = expected in let __nullable_100 = HxArray.length args in if __nullable_99 == HxRuntime.hx_null then false else Obj.obj __nullable_99 > __nullable_100) then let __assign_101 = HxInt.sub (let __nullable_int_102 = expected in if __nullable_int_102 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_102) (HxArray.length args) in (
            tempNumber11 := __assign_101;
            __assign_101
          ) else let __assign_103 = 0 in (
            tempNumber11 := __assign_103;
            __assign_103
          ) else let __assign_104 = 0 in (
            tempNumber11 := __assign_104;
            __assign_104
          ) else let __assign_105 = 0 in (
            tempNumber11 := __assign_105;
            __assign_105
          )
          | _ -> let __assign_92 = 0 in (
            tempNumber11 := __assign_92;
            __assign_92
          ));
        let missing = !tempNumber11 in let c = exprToOcaml callee arityByIdent tyByIdent in let fullArgs = HxArray.copy args in (
          ignore (let _g2 = ref 0 in let _g3 = missing in while !_g2 < _g3 do ignore ((
            ignore (let __old_106 = !_g2 in let __new_107 = HxInt.add __old_106 1 in (
              ignore (_g2 := __new_107);
              __old_106
            ));
            HxArray.push fullArgs (HxExpr.ENull)
          )) done);
          if HxArray.length fullArgs = 0 then let __assign_108 = HxString.toStdString c ^ " ()" in (
            tempResult2 := __assign_108;
            __assign_108
          ) else let tempArray11 = ref (Obj.magic ()) in (
            ignore (let _g2 = let __arr_109 = HxArray.create () in __arr_109 in (
              ignore (let _g3 = ref 0 in let _g4 = fullArgs in while !_g3 < HxArray.length _g4 do ignore (let v = HxArray.get _g4 (!_g3) in (
                ignore (let __old_110 = !_g3 in let __new_111 = HxInt.add __old_110 1 in (
                  ignore (_g3 := __new_111);
                  __new_111
                ));
                HxArray.push _g2 (("(" ^ HxString.toStdString (exprToOcaml v arityByIdent tyByIdent)) ^ ")")
              )) done);
              let __assign_112 = _g2 in (
                tempArray11 := __assign_112;
                __assign_112
              )
            ));
            let __assign_113 = (HxString.toStdString c ^ " ") ^ HxString.toStdString (HxArray.join (!tempArray11) " " (fun x -> x)) in (
              tempResult2 := __assign_113;
              __assign_113
            )
          )
        )
      ))
    | HxExpr.ENew (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in (
      ignore _g;
      ignore _g1;
      let __assign_366 = "(Obj.magic 0)" in (
        tempResult2 := __assign_366;
        __assign_366
      )
    )
    | HxExpr.EUnop (_p0, _p1) -> (let _g = _p0 in let _g1 = _p1 in let op = _g in let expr = _g1 in match op with
      | "!" -> let __assign_368 = ("(not (" ^ HxString.toStdString (exprToOcaml expr arityByIdent tyByIdent)) ^ "))" in (
        tempResult2 := __assign_368;
        __assign_368
      )
      | "-" -> let __assign_369 = ("(-(" ^ HxString.toStdString (exprToOcaml expr arityByIdent tyByIdent)) ^ "))" in (
        tempResult2 := __assign_369;
        __assign_369
      )
      | _ -> let __assign_367 = "(Obj.magic 0)" in (
        tempResult2 := __assign_367;
        __assign_367
      ))
    | HxExpr.EBinop (_p0, _p1, _p2) -> (let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let op = _g in let a = _g1 in let b = _g2 in let la = exprToOcaml a arityByIdent tyByIdent in let rb = exprToOcaml b arityByIdent tyByIdent in match op with
      | "!=" -> let __assign_371 = ((("((" ^ HxString.toStdString la) ^ ") <> (") ^ HxString.toStdString rb) ^ "))" in (
        tempResult2 := __assign_371;
        __assign_371
      )
      | "%" | "*" | "+" | "-" | "/" -> let aIsF = isFloatExpr a in let bIsF = isFloatExpr b in let aIsI = isIntExpr a in let bIsI = isIntExpr b in if aIsF && bIsF && (HxString.equals op "+" || HxString.equals op "-" || HxString.equals op "*" || HxString.equals op "/") then let tempString3 = ref "" in (
        ignore (match op with
          | "*" -> let __assign_373 = "*." in (
            tempString3 := __assign_373;
            __assign_373
          )
          | "+" -> let __assign_374 = "+." in (
            tempString3 := __assign_374;
            __assign_374
          )
          | "-" -> let __assign_375 = "-." in (
            tempString3 := __assign_375;
            __assign_375
          )
          | "/" -> let __assign_376 = "/." in (
            tempString3 := __assign_376;
            __assign_376
          )
          | _ -> let __assign_372 = op in (
            tempString3 := __assign_372;
            __assign_372
          ));
        let fop = !tempString3 in let __assign_377 = ((((("((" ^ HxString.toStdString la) ^ ") ") ^ HxString.toStdString fop) ^ " (") ^ HxString.toStdString rb) ^ "))" in (
          tempResult2 := __assign_377;
          __assign_377
        )
      ) else if aIsI && bIsI || not (aIsF) && not (bIsF) then let __assign_378 = ((((("((" ^ HxString.toStdString la) ^ ") ") ^ HxString.toStdString op) ^ " (") ^ HxString.toStdString rb) ^ "))" in (
        tempResult2 := __assign_378;
        __assign_378
      ) else let __assign_379 = "(Obj.magic 0)" in (
        tempResult2 := __assign_379;
        __assign_379
      )
      | "==" -> let __assign_380 = ((("((" ^ HxString.toStdString la) ^ ") = (") ^ HxString.toStdString rb) ^ "))" in (
        tempResult2 := __assign_380;
        __assign_380
      )
      | "<" | "<=" | ">" | ">=" -> let __assign_381 = ((((("((" ^ HxString.toStdString la) ^ ") ") ^ HxString.toStdString op) ^ " (") ^ HxString.toStdString rb) ^ "))" in (
        tempResult2 := __assign_381;
        __assign_381
      )
      | "&&" | "||" -> let __assign_382 = ((((("((" ^ HxString.toStdString la) ^ ") ") ^ HxString.toStdString op) ^ " (") ^ HxString.toStdString rb) ^ "))" in (
        tempResult2 := __assign_382;
        __assign_382
      )
      | _ -> let __assign_370 = "(Obj.magic 0)" in (
        tempResult2 := __assign_370;
        __assign_370
      ))
    | HxExpr.ETernary (_p0, _p1, _p2) -> let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let cond = _g in let thenExpr = _g1 in let elseExpr = _g2 in let __assign_383 = ((((("(if (" ^ HxString.toStdString (exprToOcaml cond arityByIdent tyByIdent)) ^ ") then (") ^ HxString.toStdString (exprToOcaml thenExpr arityByIdent tyByIdent)) ^ ") else (") ^ HxString.toStdString (exprToOcaml elseExpr arityByIdent tyByIdent)) ^ "))" in (
      tempResult2 := __assign_383;
      __assign_383
    )
    | HxExpr.EAnon (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in (
      ignore _g;
      ignore _g1;
      let __assign_384 = "(Obj.magic 0)" in (
        tempResult2 := __assign_384;
        __assign_384
      )
    )
    | HxExpr.EArrayDecl _p0 -> let _g = _p0 in (
      ignore _g;
      let __assign_385 = "(Obj.magic 0)" in (
        tempResult2 := __assign_385;
        __assign_385
      )
    )
    | HxExpr.EArrayAccess (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in (
      ignore _g;
      ignore _g1;
      let __assign_386 = "(Obj.magic 0)" in (
        tempResult2 := __assign_386;
        __assign_386
      )
    )
    | HxExpr.ECast (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      let __assign_387 = exprToOcaml expr arityByIdent tyByIdent in (
        tempResult2 := __assign_387;
        __assign_387
      )
    )
    | HxExpr.EUntyped _p0 -> let _g = _p0 in let expr = _g in let __assign_388 = exprToOcaml expr arityByIdent tyByIdent in (
      tempResult2 := __assign_388;
      __assign_388
    )
    | HxExpr.EUnsupported _p0 -> (
      ignore _p0;
      let __assign_389 = "(Obj.magic 0)" in (
        tempResult2 := __assign_389;
        __assign_389
      )
    ));
  !tempResult2
)

let returnExprToOcaml = fun expr allowedValueIdents arityByIdent tyByIdent -> try let hasBringupPoison = ref (Obj.magic (HxRuntime.hx_null)) in (
  ignore (let __assign_390 = fun e -> try let tempResult = ref false in (
    ignore (match e with
      | HxExpr.ENull -> let __assign_392 = true in (
        tempResult := __assign_392;
        __assign_392
      )
      | HxExpr.EThis -> let __assign_393 = true in (
        tempResult := __assign_393;
        __assign_393
      )
      | HxExpr.ESuper -> let __assign_394 = true in (
        tempResult := __assign_394;
        __assign_394
      )
      | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in if isUpperStart name then let __assign_395 = false in (
        tempResult := __assign_395;
        __assign_395
      ) else if HxString.equals name "trace" then let __assign_396 = false in (
        tempResult := __assign_396;
        __assign_396
      ) else if allowedValueIdents != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string allowedValueIdents name then let __assign_397 = false in (
        tempResult := __assign_397;
        __assign_397
      ) else let __assign_398 = true in (
        tempResult := __assign_398;
        __assign_398
      )
      | HxExpr.EField (_p0, _p1) -> let _g = _p0 in (
        ignore _p1;
        let obj = _g in let __assign_399 = (!hasBringupPoison) obj in (
          tempResult := __assign_399;
          __assign_399
        )
      )
      | HxExpr.ECall (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let callee = _g in let args = _g1 in (
        ignore (if (!hasBringupPoison) callee then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
          ignore (let __old_400 = !_g2 in let __new_401 = HxInt.add __old_400 1 in (
            ignore (_g2 := __new_401);
            __new_401
          ));
          if (!hasBringupPoison) a then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
        )) done);
        let __assign_402 = false in (
          tempResult := __assign_402;
          __assign_402
        )
      )
      | HxExpr.ENew (_p0, _p1) -> (
        ignore _p0;
        ignore _p1;
        let __assign_403 = true in (
          tempResult := __assign_403;
          __assign_403
        )
      )
      | HxExpr.EUnop (_p0, _p1) -> (let _g = _p0 in let _g1 = _p1 in let op = _g in let inner = _g1 in match op with
        | "!" | "-" -> let __assign_405 = (!hasBringupPoison) inner in (
          tempResult := __assign_405;
          __assign_405
        )
        | _ -> let __assign_404 = true in (
          tempResult := __assign_404;
          __assign_404
        ))
      | HxExpr.EBinop (_p0, _p1, _p2) -> (let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let op = _g in let a = _g1 in let b = _g2 in match op with
        | "!=" | "%" | "&&" | "*" | "+" | "-" | "/" | "<" | "<=" | "==" | ">" | ">=" | "||" -> let __assign_407 = (!hasBringupPoison) a || (!hasBringupPoison) b in (
          tempResult := __assign_407;
          __assign_407
        )
        | _ -> let __assign_406 = true in (
          tempResult := __assign_406;
          __assign_406
        ))
      | HxExpr.EArrayDecl _p0 -> let _g = _p0 in let values = _g in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
          ignore (let __old_408 = !_g2 in let __new_409 = HxInt.add __old_408 1 in (
            ignore (_g2 := __new_409);
            __new_409
          ));
          if (!hasBringupPoison) v then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
        )) done);
        let __assign_410 = false in (
          tempResult := __assign_410;
          __assign_410
        )
      )
      | HxExpr.EArrayAccess (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let arr = _g in let idx = _g1 in let __assign_411 = (!hasBringupPoison) arr || (!hasBringupPoison) idx in (
        tempResult := __assign_411;
        __assign_411
      )
      | HxExpr.ECast (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr2 = _g in (
        ignore _g1;
        let __assign_412 = (!hasBringupPoison) expr2 in (
          tempResult := __assign_412;
          __assign_412
        )
      )
      | HxExpr.EUntyped _p0 -> let _g = _p0 in let expr2 = _g in let __assign_413 = (!hasBringupPoison) expr2 in (
        tempResult := __assign_413;
        __assign_413
      )
      | HxExpr.EUnsupported _p0 -> (
        ignore _p0;
        let __assign_414 = true in (
          tempResult := __assign_414;
          __assign_414
        )
      )
      | _ -> let __assign_391 = false in (
        tempResult := __assign_391;
        __assign_391
      ));
    !tempResult
  ) with
    | HxRuntime.Hx_return __ret_415 -> Obj.obj __ret_415 in (
    hasBringupPoison := __assign_390;
    __assign_390
  ));
  ignore (if (!hasBringupPoison) expr then raise (HxRuntime.Hx_return (Obj.repr "(Obj.magic 0)")) else ());
  exprToOcaml expr arityByIdent tyByIdent
) with
  | HxRuntime.Hx_return __ret_416 -> Obj.obj __ret_416

let rec stmtListToOcaml = fun stmts allowedValueIdents returnExc arityByIdent tyByIdent -> try (
  ignore (if stmts == Obj.magic (HxRuntime.hx_null) || HxArray.length stmts = 0 then raise (HxRuntime.Hx_return (Obj.repr "()")) else ());
  let stmtAlwaysReturns = ref (Obj.magic (HxRuntime.hx_null)) in (
    ignore (let __assign_417 = fun s -> let tempResult = ref false in (
      ignore (match s with
        | HxStmt.SBlock (_p0, _p1) -> let _g = _p0 in (
          ignore _p1;
          let ss = _g in if ss == Obj.magic (HxRuntime.hx_null) || HxArray.length ss = 0 then let __assign_419 = false in (
            tempResult := __assign_419;
            __assign_419
          ) else let __assign_420 = (!stmtAlwaysReturns) (HxArray.get ss (HxInt.sub (HxArray.length ss) 1)) in (
            tempResult := __assign_420;
            __assign_420
          )
        )
        | HxStmt.SIf (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in (
          ignore _p3;
          ignore _g;
          let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in let __assign_421 = elseBranch != Obj.magic (HxRuntime.hx_null) && (!stmtAlwaysReturns) thenBranch && (!stmtAlwaysReturns) (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) in (
            tempResult := __assign_421;
            __assign_421
          )
        )
        | HxStmt.SReturnVoid _p0 -> (
          ignore _p0;
          let __assign_422 = true in (
            tempResult := __assign_422;
            __assign_422
          )
        )
        | HxStmt.SReturn (_p0, _p1) -> (
          ignore _p0;
          ignore _p1;
          let __assign_423 = true in (
            tempResult := __assign_423;
            __assign_423
          )
        )
        | _ -> let __assign_418 = false in (
          tempResult := __assign_418;
          __assign_418
        ));
      !tempResult
    ) in (
      stmtAlwaysReturns := __assign_417;
      __assign_417
    ));
    let condToOcamlBool = fun e -> let tempResult1 = ref "" in (
      ignore (match e with
        | HxExpr.EBool _p0 -> let _g = _p0 in let v = _g in if v then let __assign_425 = "true" in (
          tempResult1 := __assign_425;
          __assign_425
        ) else let __assign_426 = "false" in (
          tempResult1 := __assign_426;
          __assign_426
        )
        | HxExpr.EUnop (_p0, _p1) -> let _g = _p0 in (
          ignore _p1;
          if HxString.equals _g "!" then let s = returnExprToOcaml e allowedValueIdents arityByIdent tyByIdent in if HxString.equals s "(Obj.magic 0)" then let __assign_427 = "true" in (
            tempResult1 := __assign_427;
            __assign_427
          ) else let __assign_428 = s in (
            tempResult1 := __assign_428;
            __assign_428
          ) else let __assign_429 = "true" in (
            tempResult1 := __assign_429;
            __assign_429
          )
        )
        | HxExpr.EBinop (_p0, _p1, _p2) -> let _g = _p0 in (
          ignore _p1;
          ignore _p2;
          let op = _g in if HxString.equals op "==" || HxString.equals op "!=" || HxString.equals op "<" || HxString.equals op ">" || HxString.equals op "<=" || HxString.equals op ">=" || HxString.equals op "&&" || HxString.equals op "||" then let s = returnExprToOcaml e allowedValueIdents arityByIdent tyByIdent in if HxString.equals s "(Obj.magic 0)" then let __assign_430 = "true" in (
            tempResult1 := __assign_430;
            __assign_430
          ) else let __assign_431 = s in (
            tempResult1 := __assign_431;
            __assign_431
          ) else let __assign_432 = "true" in (
            tempResult1 := __assign_432;
            __assign_432
          )
        )
        | _ -> let __assign_424 = "true" in (
          tempResult1 := __assign_424;
          __assign_424
        ));
      !tempResult1
    ) in let stmtToUnit = ref (Obj.magic (HxRuntime.hx_null)) in (
      ignore (let __assign_433 = fun s -> let tempResult2 = ref "" in (
        ignore (match s with
          | HxStmt.SBlock (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let ss = _g in (
            ignore _g1;
            let __assign_434 = stmtListToOcaml ss allowedValueIdents returnExc arityByIdent tyByIdent in (
              tempResult2 := __assign_434;
              __assign_434
            )
          )
          | HxStmt.SVar (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in (
            ignore _g;
            ignore _g1;
            ignore _g2;
            ignore _g3;
            let __assign_435 = "()" in (
              tempResult2 := __assign_435;
              __assign_435
            )
          )
          | HxStmt.SIf (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
            ignore _g3;
            let thenUnit = (!stmtToUnit) thenBranch in let tempString = ref "" in (
              ignore (if elseBranch == Obj.magic (HxRuntime.hx_null) then let __assign_436 = "()" in (
                tempString := __assign_436;
                __assign_436
              ) else let __assign_437 = (!stmtToUnit) (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) in (
                tempString := __assign_437;
                __assign_437
              ));
              let elseUnit = !tempString in let __assign_438 = ((((("if " ^ HxString.toStdString (condToOcamlBool cond)) ^ " then (") ^ HxString.toStdString thenUnit) ^ ") else (") ^ HxString.toStdString elseUnit) ^ ")" in (
                tempResult2 := __assign_438;
                __assign_438
              )
            )
          )
          | HxStmt.SReturnVoid _p0 -> let _g = _p0 in (
            ignore _g;
            let __assign_439 = ("raise (" ^ HxString.toStdString returnExc) ^ " (Obj.repr ()))" in (
              tempResult2 := __assign_439;
              __assign_439
            )
          )
          | HxStmt.SReturn (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
            ignore _g1;
            let __assign_440 = ((("raise (" ^ HxString.toStdString returnExc) ^ " (Obj.repr (") ^ HxString.toStdString (returnExprToOcaml expr allowedValueIdents arityByIdent tyByIdent)) ^ ")))" in (
              tempResult2 := __assign_440;
              __assign_440
            )
          )
          | HxStmt.SExpr (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
            ignore _g1;
            if (match expr with
              | HxExpr.ENull -> 0
              | HxExpr.EBool _ -> 1
              | HxExpr.EString _ -> 2
              | HxExpr.EInt _ -> 3
              | HxExpr.EFloat _ -> 4
              | HxExpr.EThis -> 5
              | HxExpr.ESuper -> 6
              | HxExpr.EIdent _ -> 7
              | HxExpr.EField (_, _) -> 8
              | HxExpr.ECall (_, _) -> 9
              | HxExpr.ENew (_, _) -> 10
              | HxExpr.EUnop (_, _) -> 11
              | HxExpr.EBinop (_, _, _) -> 12
              | HxExpr.ETernary (_, _, _) -> 13
              | HxExpr.EAnon (_, _) -> 14
              | HxExpr.EArrayDecl _ -> 15
              | HxExpr.EArrayAccess (_, _) -> 16
              | HxExpr.ECast (_, _) -> 17
              | HxExpr.EUntyped _ -> 18
              | HxExpr.EUnsupported _ -> 19) = 12 then let _g2 = match expr with
              | HxExpr.EBinop (__enum_param_441, _, _) -> __enum_param_441
              | _ -> failwith "Unexpected enum parameter" in let _g3 = match expr with
              | HxExpr.EBinop (_, __enum_param_442, _) -> __enum_param_442
              | _ -> failwith "Unexpected enum parameter" in let _g4 = match expr with
              | HxExpr.EBinop (_, _, __enum_param_443) -> __enum_param_443
              | _ -> failwith "Unexpected enum parameter" in if HxString.equals _g2 "=" then (
              ignore _g3;
              ignore _g4;
              let __assign_444 = "()" in (
                tempResult2 := __assign_444;
                __assign_444
              )
            ) else let __assign_445 = ("ignore (" ^ HxString.toStdString (returnExprToOcaml expr allowedValueIdents arityByIdent tyByIdent)) ^ ")" in (
              tempResult2 := __assign_445;
              __assign_445
            ) else let __assign_446 = ("ignore (" ^ HxString.toStdString (returnExprToOcaml expr allowedValueIdents arityByIdent tyByIdent)) ^ ")" in (
              tempResult2 := __assign_446;
              __assign_446
            )
          ));
        !tempResult2
      ) in (
        stmtToUnit := __assign_433;
        __assign_433
      ));
      let out = ref "()" in (
        ignore (let _g = ref 0 in let _g1 = HxArray.length stmts in while !_g < _g1 do ignore (let i = let __old_447 = !_g in let __new_448 = HxInt.add __old_447 1 in (
          ignore (_g := __new_448);
          __old_447
        ) in let s = HxArray.get stmts (HxInt.sub (HxInt.sub (HxArray.length stmts) 1) i) in if (match s with
          | HxStmt.SBlock (_, _) -> 0
          | HxStmt.SVar (_, _, _, _) -> 1
          | HxStmt.SIf (_, _, _, _) -> 2
          | HxStmt.SReturnVoid _ -> 3
          | HxStmt.SReturn (_, _) -> 4
          | HxStmt.SExpr (_, _) -> 5) = 1 then ignore (let _g2 = match s with
          | HxStmt.SVar (__enum_param_449, _, _, _) -> __enum_param_449
          | _ -> failwith "Unexpected enum parameter" in let _g3 = match s with
          | HxStmt.SVar (_, __enum_param_450, _, _) -> __enum_param_450
          | _ -> failwith "Unexpected enum parameter" in let _g4 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (match s with
          | HxStmt.SVar (_, _, __enum_param_451, _) -> __enum_param_451
          | _ -> failwith "Unexpected enum parameter")) in let _g5 = match s with
          | HxStmt.SVar (_, _, _, __enum_param_452) -> __enum_param_452
          | _ -> failwith "Unexpected enum parameter" in let name = _g2 in (
          ignore _g3;
          let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g4) in (
            ignore _g5;
            let tempString1 = ref "" in (
              ignore (if init == Obj.magic (HxRuntime.hx_null) then let __assign_453 = "(Obj.magic 0)" in (
                tempString1 := __assign_453;
                __assign_453
              ) else let __assign_454 = returnExprToOcaml (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) allowedValueIdents arityByIdent tyByIdent in (
                tempString1 := __assign_454;
                __assign_454
              ));
              let rhs = !tempString1 in let ident = ocamlValueIdent name in let __assign_455 = ((((((("let " ^ HxString.toStdString ident) ^ " = ") ^ HxString.toStdString rhs) ^ " in (ignore ") ^ HxString.toStdString ident) ^ "; (") ^ HxString.toStdString (!out)) ^ "))" in (
                out := __assign_455;
                __assign_455
              )
            )
          )
        )) else ignore (let tempRight = ref "" in (
          ignore (if (!stmtAlwaysReturns) s then let __assign_456 = (!stmtToUnit) s in (
            tempRight := __assign_456;
            __assign_456
          ) else let __assign_457 = ((("(" ^ HxString.toStdString ((!stmtToUnit) s)) ^ "; ") ^ HxString.toStdString (!out)) ^ ")" in (
            tempRight := __assign_457;
            __assign_457
          ));
          let __assign_458 = !tempRight in (
            out := __assign_458;
            __assign_458
          )
        ))) done);
        !out
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_459 -> Obj.obj __ret_459

let emitToDir = fun p outDir emitFullBodies -> (
  ignore (if outDir == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim outDir) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "stage3 emitter: missing outDir") ["Dynamic"; "String"]) else ());
  let outAbs = Haxe_io_Path.normalize outDir in (
    ignore (if not (HxFileSystem.exists outAbs) then ignore (HxFileSystem.createDirectory outAbs) else ());
    let ocamldepSort = fun mlFiles -> try (
      ignore (if mlFiles == Obj.magic (HxRuntime.hx_null) || HxArray.length mlFiles <= 1 then raise (HxRuntime.Hx_return (Obj.repr mlFiles)) else ());
      let tempString = ref "" in (
        ignore (let v = HxSys.getEnv "OCAMLDEP" in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_460 = "ocamldep" in (
          tempString := __assign_460;
          __assign_460
        ) else let __assign_461 = v in (
          tempString := __assign_461;
          __assign_461
        ));
        let ocamldep = !tempString in let p2 = Sys_io_Process.create ocamldep (HxArray.concat (let __arr_462 = HxArray.create () in (
          ignore (HxArray.push __arr_462 "-sort");
          __arr_462
        )) mlFiles) (HxRuntime.hx_null) in let chunks = HxArray.create () in (
          ignore (try while true do ignore (HxArray.push chunks (let __obj_463 = p2.stdout in __obj_463.readLine (Obj.magic __obj_463) ())) done with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_464 -> raise (HxRuntime.Hx_return __ret_464)
            | HxRuntime.Hx_exception (__exn_v_465, __exn_tags_466) -> if HxRuntime.tags_has __exn_tags_466 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_465 : Haxe_io_Eof.t) in (
              ignore _hx;
              ()
            ) else HxRuntime.hx_throw_typed __exn_v_465 __exn_tags_466
            | __exn_467 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_467) : Haxe_io_Eof.t) in (
              ignore _hx;
              ()
            ) else raise (__exn_467));
          let code = Sys_io_Process.exitCode p2 () in (
            ignore (Sys_io_Process.close p2 ());
            ignore (if code <> 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("stage3 emitter: ocamldep -sort failed with exit code " ^ string_of_int code)) ["Dynamic"; "String"]) else ());
            let sorted = HxArray.create () in (
              ignore (let _g = ref 0 in while !_g < HxArray.length chunks do ignore (let c = HxArray.get chunks (!_g) in (
                ignore (let __old_468 = !_g in let __new_469 = HxInt.add __old_468 1 in (
                  ignore (_g := __new_469);
                  __new_469
                ));
                let _g2 = ref 0 in let _g1 = HxString.split c " " in try while !_g2 < HxArray.length _g1 do try ignore (let t = HxArray.get _g1 (!_g2) in (
                  ignore (let __old_470 = !_g2 in let __new_471 = HxInt.add __old_470 1 in (
                    ignore (_g2 := __new_471);
                    __new_471
                  ));
                  let s = StringTools.trim t in (
                    ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_continue) else ());
                    ignore (if not (StringTools.endsWith s ".ml") then raise (HxRuntime.Hx_continue) else ());
                    HxArray.push sorted s
                  )
                )) with
                  | HxRuntime.Hx_continue -> () done with
                  | HxRuntime.Hx_break -> ()
              )) done);
              ignore (if HxArray.length sorted = 0 then raise (HxRuntime.Hx_return (Obj.repr mlFiles)) else ());
              sorted
            )
          )
        )
      )
    ) with
      | HxRuntime.Hx_return __ret_472 -> Obj.obj __ret_472 in let generatedPaths = HxArray.create () in (
      ignore (let _g = ref 0 in let _g1 = MacroExpandedProgram.getGeneratedOcamlModules p () in try while !_g < HxArray.length _g1 do try ignore (let gm = HxArray.get _g1 (!_g) in (
        ignore (let __old_473 = !_g in let __new_474 = HxInt.add __old_473 1 in (
          ignore (_g := __new_474);
          __new_474
        ));
        ignore (if gm == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
        let tempString1 = ref "" in (
          ignore (if Obj.obj (HxAnon.get gm "name") == Obj.magic (HxRuntime.hx_null) then let __assign_475 = "" in (
            tempString1 := __assign_475;
            __assign_475
          ) else let __assign_476 = StringTools.trim (Obj.obj (HxAnon.get gm "name")) in (
            tempString1 := __assign_476;
            __assign_476
          ));
          let name = !tempString1 in (
            ignore (if HxString.length name = 0 then raise (HxRuntime.Hx_continue) else ());
            let path = Haxe_io_Path.join (let __arr_477 = HxArray.create () in (
              ignore (HxArray.push __arr_477 outAbs);
              ignore (HxArray.push __arr_477 (HxString.toStdString name ^ ".ml"));
              __arr_477
            )) in (
              ignore (let tempString2 = ref "" in (
                ignore (if Obj.obj (HxAnon.get gm "source") == Obj.magic (HxRuntime.hx_null) then let __assign_478 = "" in (
                  tempString2 := __assign_478;
                  __assign_478
                ) else let __assign_479 = Obj.obj (HxAnon.get gm "source") in (
                  tempString2 := __assign_479;
                  __assign_479
                ));
                let content = !tempString2 in HxFile.saveContent path content
              ));
              HxArray.push generatedPaths (HxString.toStdString name ^ ".ml")
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (let shimName = "Std" in let shimPath = Haxe_io_Path.join (let __arr_480 = HxArray.create () in (
        ignore (HxArray.push __arr_480 outAbs);
        ignore (HxArray.push __arr_480 (HxString.toStdString shimName ^ ".ml"));
        __arr_480
      )) in if not (HxFileSystem.exists shimPath) then ignore ((
        ignore (HxFile.saveContent shimPath (("(* hxhx(stage3) bootstrap shim: Std *)\n" ^ "let isOfType _ _ = false\n") ^ "let string _ = \"\"\n"));
        HxArray.push generatedPaths (HxString.toStdString shimName ^ ".ml")
      )) else ());
      ignore (let shimName = "Lambda" in let shimPath = Haxe_io_Path.join (let __arr_481 = HxArray.create () in (
        ignore (HxArray.push __arr_481 outAbs);
        ignore (HxArray.push __arr_481 (HxString.toStdString shimName ^ ".ml"));
        __arr_481
      )) in if not (HxFileSystem.exists shimPath) then ignore ((
        ignore (HxFile.saveContent shimPath (((("(* hxhx(stage3) bootstrap shim: Lambda *)\n" ^ "let has _ _ = false\n") ^ "let exists _ _ = false\n") ^ "let iter _ _ = ()\n") ^ "let count _ = 0\n"));
        HxArray.push generatedPaths (HxString.toStdString shimName ^ ".ml")
      )) else ());
      ignore (let shimName = "Reflect" in let shimPath = Haxe_io_Path.join (let __arr_482 = HxArray.create () in (
        ignore (HxArray.push __arr_482 outAbs);
        ignore (HxArray.push __arr_482 (HxString.toStdString shimName ^ ".ml"));
        __arr_482
      )) in if not (HxFileSystem.exists shimPath) then ignore ((
        ignore (HxFile.saveContent shimPath ((("(* hxhx(stage3) bootstrap shim: Reflect *)\n" ^ "let field _ _ = (Obj.magic 0)\n") ^ "let isFunction _ = false\n") ^ "let compare _ _ = 0\n"));
        HxArray.push generatedPaths (HxString.toStdString shimName ^ ".ml")
      )) else ());
      ignore (let shimName = "HxPosInfos" in let shimPath = Haxe_io_Path.join (let __arr_483 = HxArray.create () in (
        ignore (HxArray.push __arr_483 outAbs);
        ignore (HxArray.push __arr_483 (HxString.toStdString shimName ^ ".ml"));
        __arr_483
      )) in if not (HxFileSystem.exists shimPath) then ignore ((
        ignore (HxFile.saveContent shimPath ((((((("(* hxhx(stage3) bootstrap shim: haxe.PosInfos *)\n" ^ "type t = {\n") ^ "  fileName : string;\n") ^ "  lineNumber : int;\n") ^ "  className : string;\n") ^ "  methodName : string;\n") ^ "  customParams : Obj.t;\n") ^ "}\n"));
        HxArray.push generatedPaths (HxString.toStdString shimName ^ ".ml")
      )) else ());
      ignore (let shimName = "HxInt64" in let shimPath = Haxe_io_Path.join (let __arr_484 = HxArray.create () in (
        ignore (HxArray.push __arr_484 outAbs);
        ignore (HxArray.push __arr_484 (HxString.toStdString shimName ^ ".ml"));
        __arr_484
      )) in if not (HxFileSystem.exists shimPath) then ignore ((
        ignore (HxFile.saveContent shimPath (((("(* hxhx(stage3) bootstrap shim: haxe.Int64 (shape-only) *)\n" ^ "type t = {\n") ^ "  low : int;\n") ^ "  high : int;\n") ^ "}\n"));
        HxArray.push generatedPaths (HxString.toStdString shimName ^ ".ml")
      )) else ());
      let typedModules = MacroExpandedProgram.getTypedModules p () in (
        ignore (if HxArray.length typedModules = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "stage3 emitter: empty typed module graph") ["Dynamic"; "String"]) else ());
        let emitModule = fun tm isRoot -> try let decl = ParsedModule.getDecl (TypedModule.getParsed tm ()) () in let mainClass = HxModuleDecl.getMainClass decl in let className = HxClassDecl.getName mainClass in (
          ignore (if className == Obj.magic (HxRuntime.hx_null) || HxString.length className = 0 || HxString.equals className "Unknown" then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
          let parsedFns = HxClassDecl.getFunctions mainClass in let parsedByName = HxMap.create_string () in (
            ignore (let _g = ref 0 in while !_g < HxArray.length parsedFns do ignore (let fn = HxArray.get parsedFns (!_g) in (
              ignore (let __old_485 = !_g in let __new_486 = HxInt.add __old_485 1 in (
                ignore (_g := __new_486);
                __new_486
              ));
              let key = HxFunctionDecl.getName fn in HxMap.set_string parsedByName key fn
            )) done);
            let typedFns = TyClassEnv.getFunctions (TyModuleEnv.getMainClass (TypedModule.getEnv tm ()) ()) () in let arityByName = HxMap.create_string () in (
              ignore (let _g = ref 0 in while !_g < HxArray.length typedFns do ignore (let tf = HxArray.get typedFns (!_g) in (
                ignore (let __old_487 = !_g in let __new_488 = HxInt.add __old_487 1 in (
                  ignore (_g := __new_488);
                  __new_488
                ));
                let key = TyFunctionEnv.getName tf () in let value = HxArray.length (TyFunctionEnv.getParams tf ()) in HxMap.set_string arityByName key value
              )) done);
              let out = HxArray.create () in (
                ignore (HxArray.push out "(* Generated by hxhx(stage3) bootstrap emitter *)");
                ignore (HxArray.push out "");
                let sawMain = ref false in let exceptions = HxArray.create () in (
                  ignore (let _g = ref 0 in let _g1 = HxArray.length typedFns in while !_g < _g1 do ignore (let i = let __old_489 = !_g in let __new_490 = HxInt.add __old_489 1 in (
                    ignore (_g := __new_490);
                    __old_489
                  ) in let tf = HxArray.get typedFns i in let nameRaw = TyFunctionEnv.getName tf () in let name = ocamlValueIdent nameRaw in (
                    ignore (if HxString.equals name "main" then ignore (let __assign_491 = true in (
                      sawMain := __assign_491;
                      __assign_491
                    )) else ());
                    let args = TyFunctionEnv.getParams tf () in let tempString3 = ref "" in (
                      ignore (if HxArray.length args = 0 then let __assign_492 = "()" in (
                        tempString3 := __assign_492;
                        __assign_492
                      ) else let tempArray = ref (Obj.magic ()) in (
                        ignore (let _g2 = let __arr_493 = HxArray.create () in __arr_493 in (
                          ignore (let _g3 = ref 0 in let _g4 = args in while !_g3 < HxArray.length _g4 do ignore (let v = HxArray.get _g4 (!_g3) in (
                            ignore (let __old_494 = !_g3 in let __new_495 = HxInt.add __old_494 1 in (
                              ignore (_g3 := __new_495);
                              __new_495
                            ));
                            HxArray.push _g2 (((("(" ^ HxString.toStdString (ocamlValueIdent (TySymbol.getName v ()))) ^ " : ") ^ HxString.toStdString (ocamlTypeFromTy (TySymbol.getType v ()))) ^ ")")
                          )) done);
                          let __assign_496 = _g2 in (
                            tempArray := __assign_496;
                            __assign_496
                          )
                        ));
                        let __assign_497 = HxArray.join (!tempArray) " " (fun x -> x) in (
                          tempString3 := __assign_497;
                          __assign_497
                        )
                      ));
                      let ocamlArgs = !tempString3 in let parsedFn = HxMap.get_string parsedByName nameRaw in let retTy = ocamlTypeFromTy (TyFunctionEnv.getReturnType tf ()) in let allowed = HxMap.create_string () in let tyByIdent = HxMap.create_string () in (
                        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
                          ignore (let __old_498 = !_g2 in let __new_499 = HxInt.add __old_498 1 in (
                            ignore (_g2 := __new_499);
                            __new_499
                          ));
                          let key = TySymbol.getName a () in HxMap.set_string allowed key true
                        )) done);
                        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
                          ignore (let __old_500 = !_g2 in let __new_501 = HxInt.add __old_500 1 in (
                            ignore (_g2 := __new_501);
                            __new_501
                          ));
                          let key = TySymbol.getName a () in let value = TySymbol.getType a () in HxMap.set_string tyByIdent key value
                        )) done);
                        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length typedFns do ignore (let tf2 = HxArray.get typedFns (!_g2) in (
                          ignore (let __old_502 = !_g2 in let __new_503 = HxInt.add __old_502 1 in (
                            ignore (_g2 := __new_503);
                            __new_503
                          ));
                          let key = TyFunctionEnv.getName tf2 () in HxMap.set_string allowed key true
                        )) done);
                        ignore (if emitFullBodies then ignore ((
                          ignore (let _g2 = ref 0 in let _g3 = TyFunctionEnv.getLocals tf () in while !_g2 < HxArray.length _g3 do ignore (let l = HxArray.get _g3 (!_g2) in (
                            ignore (let __old_504 = !_g2 in let __new_505 = HxInt.add __old_504 1 in (
                              ignore (_g2 := __new_505);
                              __new_505
                            ));
                            let key = TySymbol.getName l () in HxMap.set_string allowed key true
                          )) done);
                          let _g2 = ref 0 in let _g3 = TyFunctionEnv.getLocals tf () in while !_g2 < HxArray.length _g3 do ignore (let l = HxArray.get _g3 (!_g2) in (
                            ignore (let __old_506 = !_g2 in let __new_507 = HxInt.add __old_506 1 in (
                              ignore (_g2 := __new_507);
                              __new_507
                            ));
                            let key = TySymbol.getName l () in let value = TySymbol.getType l () in HxMap.set_string tyByIdent key value
                          )) done
                        )) else ());
                        let tempString4 = ref "" in (
                          ignore (if parsedFn == Obj.magic (HxRuntime.hx_null) then let __assign_508 = "()" in (
                            tempString4 := __assign_508;
                            __assign_508
                          ) else if not (emitFullBodies) then let __assign_509 = returnExprToOcaml (HxFunctionDecl.getFirstReturnExpr parsedFn ()) allowed arityByName tyByIdent in (
                            tempString4 := __assign_509;
                            __assign_509
                          ) else let exc = "HxReturn_" ^ HxString.toStdString (escapeOcamlIdentPart nameRaw) in (
                            ignore (HxArray.push exceptions (("exception " ^ HxString.toStdString exc) ^ " of Obj.t"));
                            let stmts = HxFunctionDecl.getBody parsedFn in let __assign_510 = (((((((("((" ^ "try (let _ = ") ^ HxString.toStdString (stmtListToOcaml stmts allowed exc arityByName tyByIdent)) ^ " in (Obj.magic 0)) ") ^ "with ") ^ HxString.toStdString exc) ^ " v -> (Obj.magic v)") ^ ") : ") ^ HxString.toStdString retTy) ^ ")" in (
                              tempString4 := __assign_510;
                              __assign_510
                            )
                          ));
                          let body = !tempString4 in let tempString5 = ref "" in (
                            ignore (if i = 0 then let __assign_511 = "let rec" in (
                              tempString5 := __assign_511;
                              __assign_511
                            ) else let __assign_512 = "and" in (
                              tempString5 := __assign_512;
                              __assign_512
                            ));
                            let kw = !tempString5 in (
                              ignore (HxArray.push out ((((((((HxString.toStdString kw ^ " ") ^ HxString.toStdString name) ^ " ") ^ HxString.toStdString ocamlArgs) ^ " : ") ^ HxString.toStdString retTy) ^ " = ") ^ HxString.toStdString body));
                              HxArray.push out ""
                            )
                          )
                        )
                      )
                    )
                  )) done);
                  ignore (if emitFullBodies && HxArray.length exceptions > 0 then ignore (HxArray.insert out 2 (HxString.toStdString (HxArray.join exceptions "\n" (fun x -> x)) ^ "\n")) else ());
                  ignore (if isRoot && !sawMain then ignore ((
                    ignore (HxArray.push out "let () = ignore (main ())");
                    HxArray.push out ""
                  )) else ());
                  let mlPath = Haxe_io_Path.join (let __arr_513 = HxArray.create () in (
                    ignore (HxArray.push __arr_513 outAbs);
                    ignore (HxArray.push __arr_513 (HxString.toStdString className ^ ".ml"));
                    __arr_513
                  )) in (
                    ignore (let content = HxArray.join out "\n" (fun x -> x) in HxFile.saveContent mlPath content);
                    HxString.toStdString className ^ ".ml"
                  )
                )
              )
            )
          )
        ) with
          | HxRuntime.Hx_return __ret_514 -> Obj.obj __ret_514 in let emittedModulePaths = HxArray.create () in let deps = HxArray.slice typedModules 1 (HxArray.length typedModules) in (
          ignore (let _g = ref 0 in while !_g < HxArray.length deps do ignore (let tm = HxArray.get deps (!_g) in (
            ignore (let __old_515 = !_g in let __new_516 = HxInt.add __old_515 1 in (
              ignore (_g := __new_516);
              __new_516
            ));
            let path = emitModule tm false in if path != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push emittedModulePaths path) else ()
          )) done);
          let rootPath = emitModule (HxArray.get typedModules 0) true in (
            ignore (if rootPath != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push emittedModulePaths rootPath) else ());
            let exePath = Haxe_io_Path.join (let __arr_517 = HxArray.create () in (
              ignore (HxArray.push __arr_517 outAbs);
              ignore (HxArray.push __arr_517 "out.exe");
              __arr_517
            )) in (
              ignore (try if HxFileSystem.exists exePath then ignore (HxFileSystem.deleteFile exePath) else () with
                | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                | HxRuntime.Hx_return __ret_518 -> raise (HxRuntime.Hx_return __ret_518)
                | HxRuntime.Hx_exception (__exn_v_519, __exn_tags_520) -> if true then let _hx = (__exn_v_519 : Obj.t) in (
                  ignore _hx;
                  ()
                ) else HxRuntime.hx_throw_typed __exn_v_519 __exn_tags_520
                | __exn_521 -> if true then let _hx = (Obj.repr __exn_521 : Obj.t) in (
                  ignore _hx;
                  ()
                ) else raise (__exn_521));
              let tempString6 = ref "" in (
                ignore (let v = HxSys.getEnv "OCAMLOPT" in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_522 = "ocamlopt" in (
                  tempString6 := __assign_522;
                  __assign_522
                ) else let __assign_523 = v in (
                  tempString6 := __assign_523;
                  __assign_523
                ));
                let tempMaybeString = ref (Obj.magic ()) in (
                  ignore (try let __assign_524 = HxSys.getCwd () in (
                    tempMaybeString := __assign_524;
                    __assign_524
                  ) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_525 -> raise (HxRuntime.Hx_return __ret_525)
                    | HxRuntime.Hx_exception (__exn_v_526, __exn_tags_527) -> if true then let _hx = (__exn_v_526 : Obj.t) in (
                      ignore _hx;
                      let __assign_528 = Obj.magic (HxRuntime.hx_null) in (
                        tempMaybeString := __assign_528;
                        __assign_528
                      )
                    ) else HxRuntime.hx_throw_typed __exn_v_526 __exn_tags_527
                    | __exn_529 -> if true then let _hx = (Obj.repr __exn_529 : Obj.t) in (
                      ignore _hx;
                      let __assign_530 = Obj.magic (HxRuntime.hx_null) in (
                        tempMaybeString := __assign_530;
                        __assign_530
                      )
                    ) else raise (__exn_529));
                  let prevCwd = !tempMaybeString in (
                    ignore (if prevCwd == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "stage3 emitter: cannot read current working directory") ["Dynamic"; "String"]) else ());
                    ignore (HxSys.setCwd outAbs);
                    let orderedMl = ocamldepSort (HxArray.concat generatedPaths emittedModulePaths) in let orderedNoRoot = HxArray.create () in (
                      ignore (let _g = ref 0 in while !_g < HxArray.length orderedMl do ignore (let f = HxArray.get orderedMl (!_g) in (
                        ignore (let __old_531 = !_g in let __new_532 = HxInt.add __old_531 1 in (
                          ignore (_g := __new_532);
                          __new_532
                        ));
                        if rootPath == Obj.magic (HxRuntime.hx_null) || not (HxString.equals f rootPath) then ignore (HxArray.push orderedNoRoot f) else ()
                      )) done);
                      ignore (if rootPath != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push orderedNoRoot rootPath) else ());
                      let args = HxArray.create () in (
                        ignore (HxArray.push args "-o");
                        ignore (HxArray.push args "out.exe");
                        ignore (let _g = ref 0 in while !_g < HxArray.length orderedNoRoot do ignore (let p2 = HxArray.get orderedNoRoot (!_g) in (
                          ignore (let __old_533 = !_g in let __new_534 = HxInt.add __old_533 1 in (
                            ignore (_g := __new_534);
                            __new_534
                          ));
                          HxArray.push args p2
                        )) done);
                        let tempNumber = ref 0 in (
                          ignore (try let __assign_535 = HxSys.command (!tempString6) (Some args) in (
                            tempNumber := __assign_535;
                            __assign_535
                          ) with
                            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                            | HxRuntime.Hx_return __ret_536 -> raise (HxRuntime.Hx_return __ret_536)
                            | HxRuntime.Hx_exception (__exn_v_537, __exn_tags_538) -> if true then let e = (__exn_v_537 : Obj.t) in (
                              ignore e;
                              (
                                ignore (HxSys.setCwd prevCwd);
                                HxType.hx_throw_typed_rtti e ["Dynamic"]
                              )
                            ) else HxRuntime.hx_throw_typed __exn_v_537 __exn_tags_538
                            | __exn_539 -> if true then let e = (Obj.repr __exn_539 : Obj.t) in (
                              ignore e;
                              (
                                ignore (HxSys.setCwd prevCwd);
                                HxType.hx_throw_typed_rtti e ["Dynamic"]
                              )
                            ) else raise (__exn_539));
                          let code = !tempNumber in (
                            ignore (HxSys.setCwd prevCwd);
                            ignore (if code <> 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("stage3 emitter: ocamlopt failed with exit code " ^ string_of_int code)) ["Dynamic"; "String"]) else ());
                            ignore (if not (HxFileSystem.exists exePath) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("stage3 emitter: missing built executable: " ^ HxString.toStdString exePath)) ["Dynamic"; "String"]) else ());
                            exePath
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
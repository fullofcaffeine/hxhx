# 1 "hxhx_Hxml.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Hxml *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Hxml" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Hxml" } : t)

let splitIntoUnits = fun tokens -> let units = HxArray.create () in let cur = ref (HxArray.create ()) in let commonPrefix = ref (Obj.magic (HxRuntime.hx_null)) in let _g = ref 0 in (
  ignore (try while !_g < HxArray.length tokens do try ignore (let t = HxArray.get tokens (!_g) in (
    ignore (let __old_9 = !_g in let __new_10 = HxInt.add __old_9 1 in (
      ignore (_g := __new_10);
      __new_10
    ));
    ignore (if HxString.equals t "--each" then ignore ((
      ignore (let __assign_11 = HxArray.copy (!cur) in (
        commonPrefix := __assign_11;
        __assign_11
      ));
      ignore (let __assign_12 = HxArray.copy (!commonPrefix) in (
        cur := __assign_12;
        __assign_12
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if HxString.equals t "--next" then ignore (let tempBool = ref false in (
      ignore (if HxArray.length (!cur) = 0 then let __assign_13 = false in (
        tempBool := __assign_13;
        __assign_13
      ) else if !commonPrefix == Obj.magic (HxRuntime.hx_null) then let __assign_14 = true in (
        tempBool := __assign_14;
        __assign_14
      ) else let __assign_15 = HxArray.length (!cur) > HxArray.length (!commonPrefix) in (
        tempBool := __assign_15;
        __assign_15
      ));
      ignore (if !tempBool then ignore (HxArray.push units (!cur)) else ());
      let tempRight = ref (Obj.magic ()) in (
        ignore (if !commonPrefix == Obj.magic (HxRuntime.hx_null) then let __assign_16 = HxArray.create () in (
          tempRight := __assign_16;
          __assign_16
        ) else let __assign_17 = HxArray.copy (!commonPrefix) in (
          tempRight := __assign_17;
          __assign_17
        ));
        ignore (let __assign_18 = !tempRight in (
          cur := __assign_18;
          __assign_18
        ));
        raise (HxRuntime.Hx_continue)
      )
    )) else ());
    HxArray.push (!cur) t
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let tempBool1 = ref false in (
    ignore (if HxArray.length (!cur) = 0 then let __assign_19 = false in (
      tempBool1 := __assign_19;
      __assign_19
    ) else if !commonPrefix == Obj.magic (HxRuntime.hx_null) then let __assign_20 = true in (
      tempBool1 := __assign_20;
      __assign_20
    ) else let __assign_21 = HxArray.length (!cur) > HxArray.length (!commonPrefix) in (
      tempBool1 := __assign_21;
      __assign_21
    ));
    ignore (if !tempBool1 then ignore (HxArray.push units (!cur)) else ());
    let tempResult = ref (Obj.magic ()) in (
      ignore (if HxArray.length units = 0 then let __assign_22 = let __arr_23 = HxArray.create () in (
        ignore (HxArray.push __arr_23 (let __arr_24 = HxArray.create () in __arr_24));
        __arr_23
      ) in (
        tempResult := __assign_22;
        __assign_22
      ) else let __assign_25 = units in (
        tempResult := __assign_25;
        __assign_25
      ));
      !tempResult
    )
  )
)

let isSpace = fun c -> c = 32 || c = 9 || c = 13

let tokenizeLine = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (let __arr_51 = HxArray.create () in __arr_51))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length line && isSpace (let __nullable_int_52 = HxString.charCodeAt line (!i) in if __nullable_int_52 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_52) do ignore (let __old_53 = !i in let __new_54 = HxInt.add __old_53 1 in (
      ignore (i := __new_54);
      __old_53
    )) done);
    ignore (if !i >= HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (let __arr_55 = HxArray.create () in __arr_55))) else ());
    ignore (if let __nullable_56 = HxString.charCodeAt line (!i) in if __nullable_56 == HxRuntime.hx_null then false else Obj.obj __nullable_56 = 35 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_57 = HxArray.create () in __arr_57))) else ());
    let restOfLineAfter = fun prefix -> try let p = HxString.length prefix in (
      ignore (if HxInt.add (!i) p > HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      ignore (if not (HxString.equals (HxString.substr line (!i) p) prefix) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      let j = HxInt.add (!i) p in (
        ignore (if j < HxString.length line && not (isSpace (let __nullable_int_58 = HxString.charCodeAt line j in if __nullable_int_58 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_58)) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
        let k = ref j in (
          ignore (while !k < HxString.length line && isSpace (let __nullable_int_59 = HxString.charCodeAt line (!k) in if __nullable_int_59 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_59) do ignore (let __old_60 = !k in let __new_61 = HxInt.add __old_60 1 in (
            ignore (k := __new_61);
            __old_60
          )) done);
          let rest = StringTools.rtrim (HxString.substr line (!k) (-1)) in (
            ignore (if HxString.length rest = 0 then ignore ((
              ignore (print_endline ("hxhx(stage1): missing value after " ^ HxString.toStdString prefix));
              raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
            )) else ());
            let __arr_62 = HxArray.create () in (
              ignore (HxArray.push __arr_62 prefix);
              ignore (HxArray.push __arr_62 rest);
              __arr_62
            )
          )
        )
      )
    ) with
      | HxRuntime.Hx_return __ret_63 -> Obj.obj __ret_63 in let macroLine = restOfLineAfter "--macro" in (
      ignore (if macroLine != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr macroLine)) else ());
      let cmdLine = restOfLineAfter "--cmd" in (
        ignore (if cmdLine != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr cmdLine)) else ());
        let cmdLine2 = restOfLineAfter "-cmd" in (
          ignore (if cmdLine2 != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr cmdLine2)) else ());
          let tokens = HxArray.create () in let cur = ref (StringBuf.create ()) in let quote = ref 0 in (
            ignore (try while !i < HxString.length line do try ignore (let c = HxString.charCodeAt line (!i) in (
              ignore (if !quote = 0 && (let __nullable_64 = c in if __nullable_64 == HxRuntime.hx_null then false else Obj.obj __nullable_64 = 35) then raise (HxRuntime.Hx_break) else ());
              ignore (if !quote = 0 && isSpace (let __nullable_int_65 = c in if __nullable_int_65 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_65) then ignore ((
                ignore (if StringBuf.get_length (!cur) () > 0 then ignore ((
                  ignore (HxArray.push tokens (StringBuf.toString (!cur) ()));
                  let __assign_66 = StringBuf.create () in (
                    cur := __assign_66;
                    __assign_66
                  )
                )) else ());
                ignore (while !i < HxString.length line && isSpace (let __nullable_int_67 = HxString.charCodeAt line (!i) in if __nullable_int_67 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_67) do ignore (let __old_68 = !i in let __new_69 = HxInt.add __old_68 1 in (
                  ignore (i := __new_69);
                  __old_68
                )) done);
                raise (HxRuntime.Hx_continue)
              )) else ());
              ignore (if !quote = 0 && StringBuf.get_length (!cur) () = 0 && ((let __nullable_70 = c in if __nullable_70 == HxRuntime.hx_null then false else Obj.obj __nullable_70 = 34) || (let __nullable_71 = c in if __nullable_71 == HxRuntime.hx_null then false else Obj.obj __nullable_71 = 39)) then ignore ((
                ignore (let __assign_72 = let __nullable_int_73 = c in if __nullable_int_73 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_73 in (
                  quote := __assign_72;
                  __assign_72
                ));
                ignore (let __old_74 = !i in let __new_75 = HxInt.add __old_74 1 in (
                  ignore (i := __new_75);
                  __old_74
                ));
                raise (HxRuntime.Hx_continue)
              )) else ());
              ignore (if !quote <> 0 && (let __nullable_76 = c in if __nullable_76 == HxRuntime.hx_null then false else Obj.obj __nullable_76 = !quote) then ignore ((
                ignore (let __assign_77 = 0 in (
                  quote := __assign_77;
                  __assign_77
                ));
                ignore (let __old_78 = !i in let __new_79 = HxInt.add __old_78 1 in (
                  ignore (i := __new_79);
                  __old_78
                ));
                raise (HxRuntime.Hx_continue)
              )) else ());
              ignore (if (let __nullable_80 = c in if __nullable_80 == HxRuntime.hx_null then false else Obj.obj __nullable_80 = 92) && HxInt.add (!i) 1 < HxString.length line then ignore (let n = HxString.charCodeAt line (HxInt.add (!i) 1) in if n == HxRuntime.hx_null then ignore () else ignore (let __switch_82 = n in if __switch_82 == HxRuntime.hx_null then ignore () else match Obj.obj __switch_82 with
                | 34 | 35 | 39 | 92 -> ignore ((
                  ignore (StringBuf.addChar (!cur) (let __nullable_int_83 = n in if __nullable_int_83 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_83));
                  ignore (i := HxInt.add (!i) 2);
                  raise (HxRuntime.Hx_continue)
                ))
                | 110 -> ignore ((
                  ignore (StringBuf.addChar (!cur) 10);
                  ignore (i := HxInt.add (!i) 2);
                  raise (HxRuntime.Hx_continue)
                ))
                | 114 -> ignore ((
                  ignore (StringBuf.addChar (!cur) 13);
                  ignore (i := HxInt.add (!i) 2);
                  raise (HxRuntime.Hx_continue)
                ))
                | 116 -> ignore ((
                  ignore (StringBuf.addChar (!cur) 9);
                  ignore (i := HxInt.add (!i) 2);
                  raise (HxRuntime.Hx_continue)
                ))
                | _ -> ignore ())) else ());
              ignore (StringBuf.addChar (!cur) (let __nullable_int_84 = c in if __nullable_int_84 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_84));
              let __old_85 = !i in let __new_86 = HxInt.add __old_85 1 in (
                ignore (i := __new_86);
                __old_85
              )
            )) with
              | HxRuntime.Hx_continue -> () done with
              | HxRuntime.Hx_break -> ());
            ignore (if !quote <> 0 then ignore ((
              ignore (print_endline ("hxhx(stage1): unterminated quote in hxml line: " ^ HxString.toStdString line));
              raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
            )) else ());
            ignore (if StringBuf.get_length (!cur) () > 0 then ignore ((
              ignore (HxArray.push tokens (StringBuf.toString (!cur) ()));
              let __assign_87 = StringBuf.create () in (
                cur := __assign_87;
                __assign_87
              )
            )) else ());
            tokens
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_88 -> Obj.obj __ret_88

let rec parseFileRec = fun path seen depth allowNext -> try (
  ignore (if depth > 25 then ignore ((
    ignore (print_endline ("hxhx(stage1): hxml include depth exceeded: " ^ HxString.toStdString path));
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  )) else ());
  let norm = Haxe_io_Path.normalize path in (
    ignore (if HxMap.exists_string seen norm then ignore ((
      ignore (print_endline ("hxhx(stage1): hxml include cycle: " ^ HxString.toStdString norm));
      raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
    )) else ());
    ignore (HxMap.set_string seen norm true);
    let tempMaybeString = ref (Obj.magic ()) in (
      ignore (try let __assign_26 = HxFile.getContent norm in (
        tempMaybeString := __assign_26;
        __assign_26
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_27 -> raise (HxRuntime.Hx_return __ret_27)
        | HxRuntime.Hx_exception (__exn_v_28, __exn_tags_29) -> if HxRuntime.tags_has __exn_tags_29 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_28) : Haxe_io_Error.error) in (
          ignore _hx;
          let __assign_31 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_31;
            __assign_31
          )
        ) else if HxRuntime.tags_has __exn_tags_29 "String" then let _hx = (Obj.obj __exn_v_28 : string) in (
          ignore _hx;
          let __assign_30 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_30;
            __assign_30
          )
        ) else HxRuntime.hx_throw_typed __exn_v_28 __exn_tags_29
        | __exn_32 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_32)) : Haxe_io_Error.error) in (
          ignore _hx;
          let __assign_34 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_34;
            __assign_34
          )
        ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_32) : string) in (
          ignore _hx;
          let __assign_33 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_33;
            __assign_33
          )
        ) else raise (__exn_32));
      let content = !tempMaybeString in (
        ignore (if content == Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (print_endline ("hxhx(stage1): failed to read hxml: " ^ HxString.toStdString norm));
          ignore (HxMap.remove_string seen norm);
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        let fileDir0 = Haxe_io_Path.directory norm in let tempString = ref "" in (
          ignore (if fileDir0 == Obj.magic (HxRuntime.hx_null) || HxString.length fileDir0 = 0 then let __assign_35 = "." in (
            tempString := __assign_35;
            __assign_35
          ) else let __assign_36 = fileDir0 in (
            tempString := __assign_36;
            __assign_36
          ));
          let tokens = HxArray.create () in let lines = HxString.split content "\n" in (
            ignore (let _g = ref 0 in while !_g < HxArray.length lines do ignore (let ln = HxArray.get lines (!_g) in (
              ignore (let __old_37 = !_g in let __new_38 = HxInt.add __old_37 1 in (
                ignore (_g := __new_38);
                __new_38
              ));
              let lineTokens = tokenizeLine ln in (
                ignore (if lineTokens == Obj.magic (HxRuntime.hx_null) then ignore ((
                  ignore (HxMap.remove_string seen norm);
                  raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
                )) else ());
                let _g2 = ref 0 in while !_g2 < HxArray.length lineTokens do ignore (let t = HxArray.get lineTokens (!_g2) in (
                  ignore (let __old_39 = !_g2 in let __new_40 = HxInt.add __old_39 1 in (
                    ignore (_g2 := __new_40);
                    __new_40
                  ));
                  HxArray.push tokens t
                )) done
              )
            )) done);
            let i = ref 0 in (
              ignore (while !i < HxArray.length tokens do ignore (let _g = HxArray.get tokens (!i) in match _g with
                | "-cp" | "-p" -> ignore ((
                  ignore (if HxInt.add (!i) 1 < HxArray.length tokens then ignore (let cp = HxArray.get tokens (HxInt.add (!i) 1) in if cp != Obj.magic (HxRuntime.hx_null) && HxString.length cp > 0 && not (Haxe_io_Path.isAbsolute cp) then ignore (let __assign_41 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_42 = HxArray.create () in (
                    ignore (HxArray.push __arr_42 (!tempString));
                    ignore (HxArray.push __arr_42 cp);
                    __arr_42
                  ))) in HxArray.set tokens (HxInt.add (!i) 1) __assign_41) else ()) else ());
                  i := HxInt.add (!i) 2
                ))
                | _ -> ignore (i := HxInt.add (!i) 1)) done);
              let out = HxArray.create () in (
                ignore (let _g = ref 0 in try while !_g < HxArray.length tokens do try ignore (let t = HxArray.get tokens (!_g) in (
                  ignore (let __old_43 = !_g in let __new_44 = HxInt.add __old_43 1 in (
                    ignore (_g := __new_44);
                    __new_44
                  ));
                  ignore (if not (allowNext) && (HxString.equals t "--next" || HxString.equals t "--each") then ignore ((
                    ignore (print_endline ("hxhx(stage1): unsupported hxml directive: " ^ HxString.toStdString t));
                    ignore (HxMap.remove_string seen norm);
                    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
                  )) else ());
                  ignore (if not (StringTools.startsWith t "-") && StringTools.endsWith t ".hxml" then ignore (let tempString1 = ref "" in (
                    ignore (if Haxe_io_Path.isAbsolute t then let __assign_45 = Haxe_io_Path.normalize t in (
                      tempString1 := __assign_45;
                      __assign_45
                    ) else let __assign_46 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_47 = HxArray.create () in (
                      ignore (HxArray.push __arr_47 (!tempString));
                      ignore (HxArray.push __arr_47 t);
                      __arr_47
                    ))) in (
                      tempString1 := __assign_46;
                      __assign_46
                    ));
                    let included = !tempString1 in let expanded = parseFileRec included seen (HxInt.add depth 1) allowNext in (
                      ignore (if expanded == Obj.magic (HxRuntime.hx_null) then ignore ((
                        ignore (HxMap.remove_string seen norm);
                        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
                      )) else ());
                      ignore (let _g2 = ref 0 in while !_g2 < HxArray.length expanded do ignore (let x = HxArray.get expanded (!_g2) in (
                        ignore (let __old_48 = !_g2 in let __new_49 = HxInt.add __old_48 1 in (
                          ignore (_g2 := __new_49);
                          __new_49
                        ));
                        HxArray.push out x
                      )) done);
                      raise (HxRuntime.Hx_continue)
                    )
                  )) else ());
                  HxArray.push out t
                )) with
                  | HxRuntime.Hx_continue -> () done with
                  | HxRuntime.Hx_break -> ());
                ignore (HxMap.remove_string seen norm);
                out
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_50 -> Obj.obj __ret_50

let parseFile = fun path -> let seen = HxMap.create_string () in parseFileRec (Haxe_io_Path.normalize path) seen 0 false

let parseFileUnits = fun path -> try let seen = HxMap.create_string () in let toks = parseFileRec (Haxe_io_Path.normalize path) seen 0 true in (
  ignore (if toks == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  splitIntoUnits toks
) with
  | HxRuntime.Hx_return __ret_1 -> Obj.obj __ret_1

let expandArgsToUnits = fun args -> try (
  ignore (if args == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (let __arr_2 = HxArray.create () in (
    ignore (HxArray.push __arr_2 (let __arr_3 = HxArray.create () in __arr_3));
    __arr_2
  )))) else ());
  let seen = HxMap.create_string () in let toks = HxArray.create () in let _g = ref 0 in (
    ignore (try while !_g < HxArray.length args do try ignore (let a = HxArray.get args (!_g) in (
      ignore (let __old_4 = !_g in let __new_5 = HxInt.add __old_4 1 in (
        ignore (_g := __new_5);
        __new_5
      ));
      ignore (if a != Obj.magic (HxRuntime.hx_null) && HxString.length a > 0 && not (StringTools.startsWith a "-") && StringTools.endsWith a ".hxml" then ignore (let expanded = parseFileRec (Haxe_io_Path.normalize a) seen 0 true in (
        ignore (if expanded == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
        let _g2 = ref 0 in (
          ignore (while !_g2 < HxArray.length expanded do ignore (let t = HxArray.get expanded (!_g2) in (
            ignore (let __old_6 = !_g2 in let __new_7 = HxInt.add __old_6 1 in (
              ignore (_g2 := __new_7);
              __new_7
            ));
            HxArray.push toks t
          )) done);
          raise (HxRuntime.Hx_continue)
        )
      )) else ());
      HxArray.push toks a
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    splitIntoUnits toks
  )
) with
  | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8
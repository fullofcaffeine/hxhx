# 1 "hxhx_Hxml.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Hxml *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Hxml" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Hxml" } : t)

let isSpace = fun c -> c = 32 || c = 9 || c = 13

let tokenizeLine = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (let __arr_24 = HxArray.create () in __arr_24))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length line && isSpace (let __nullable_int_25 = HxString.charCodeAt line (!i) in if __nullable_int_25 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_25) do ignore (let __old_26 = !i in let __new_27 = HxInt.add __old_26 1 in (
      ignore (i := __new_27);
      __old_26
    )) done);
    ignore (if !i >= HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (let __arr_28 = HxArray.create () in __arr_28))) else ());
    ignore (if let __nullable_29 = HxString.charCodeAt line (!i) in if __nullable_29 == HxRuntime.hx_null then false else Obj.obj __nullable_29 = 35 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_30 = HxArray.create () in __arr_30))) else ());
    let tokens = HxArray.create () in let cur = ref (StringBuf.create ()) in let quote = ref 0 in (
      ignore (try while !i < HxString.length line do try ignore (let c = HxString.charCodeAt line (!i) in (
        ignore (if !quote = 0 && (let __nullable_31 = c in if __nullable_31 == HxRuntime.hx_null then false else Obj.obj __nullable_31 = 35) then raise (HxRuntime.Hx_break) else ());
        ignore (if !quote = 0 && isSpace (let __nullable_int_32 = c in if __nullable_int_32 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_32) then ignore ((
          ignore (if StringBuf.get_length (!cur) () > 0 then ignore ((
            ignore (HxArray.push tokens (StringBuf.toString (!cur) ()));
            let __assign_33 = StringBuf.create () in (
              cur := __assign_33;
              __assign_33
            )
          )) else ());
          ignore (while !i < HxString.length line && isSpace (let __nullable_int_34 = HxString.charCodeAt line (!i) in if __nullable_int_34 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_34) do ignore (let __old_35 = !i in let __new_36 = HxInt.add __old_35 1 in (
            ignore (i := __new_36);
            __old_35
          )) done);
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !quote = 0 && StringBuf.get_length (!cur) () = 0 && ((let __nullable_37 = c in if __nullable_37 == HxRuntime.hx_null then false else Obj.obj __nullable_37 = 34) || (let __nullable_38 = c in if __nullable_38 == HxRuntime.hx_null then false else Obj.obj __nullable_38 = 39)) then ignore ((
          ignore (let __assign_39 = let __nullable_int_40 = c in if __nullable_int_40 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_40 in (
            quote := __assign_39;
            __assign_39
          ));
          ignore (let __old_41 = !i in let __new_42 = HxInt.add __old_41 1 in (
            ignore (i := __new_42);
            __old_41
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !quote <> 0 && (let __nullable_43 = c in if __nullable_43 == HxRuntime.hx_null then false else Obj.obj __nullable_43 = !quote) then ignore ((
          ignore (let __assign_44 = 0 in (
            quote := __assign_44;
            __assign_44
          ));
          ignore (let __old_45 = !i in let __new_46 = HxInt.add __old_45 1 in (
            ignore (i := __new_46);
            __old_45
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if (let __nullable_47 = c in if __nullable_47 == HxRuntime.hx_null then false else Obj.obj __nullable_47 = 92) && HxInt.add (!i) 1 < HxString.length line then ignore (let n = HxString.charCodeAt line (HxInt.add (!i) 1) in if n == HxRuntime.hx_null then ignore () else ignore (let __switch_49 = n in if __switch_49 == HxRuntime.hx_null then ignore () else match Obj.obj __switch_49 with
          | 34 | 35 | 39 | 92 -> ignore ((
            ignore (StringBuf.addChar (!cur) (let __nullable_int_50 = n in if __nullable_int_50 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_50));
            ignore (i := HxInt.add (!i) 2);
            raise (HxRuntime.Hx_continue)
          ))
          | 110 -> ignore ((
            ignore (StringBuf.addChar (!cur) 10);
            ignore (i := HxInt.add (!i) 2);
            raise (HxRuntime.Hx_continue)
          ))
          | 114 -> ignore ((
            ignore (StringBuf.addChar (!cur) 13);
            ignore (i := HxInt.add (!i) 2);
            raise (HxRuntime.Hx_continue)
          ))
          | 116 -> ignore ((
            ignore (StringBuf.addChar (!cur) 9);
            ignore (i := HxInt.add (!i) 2);
            raise (HxRuntime.Hx_continue)
          ))
          | _ -> ignore ())) else ());
        ignore (StringBuf.addChar (!cur) (let __nullable_int_51 = c in if __nullable_int_51 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_51));
        let __old_52 = !i in let __new_53 = HxInt.add __old_52 1 in (
          ignore (i := __new_53);
          __old_52
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if !quote <> 0 then ignore ((
        ignore (print_endline ("hxhx(stage1): unterminated quote in hxml line: " ^ HxString.toStdString line));
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )) else ());
      ignore (if StringBuf.get_length (!cur) () > 0 then ignore ((
        ignore (HxArray.push tokens (StringBuf.toString (!cur) ()));
        let __assign_54 = StringBuf.create () in (
          cur := __assign_54;
          __assign_54
        )
      )) else ());
      tokens
    )
  )
) with
  | HxRuntime.Hx_return __ret_55 -> Obj.obj __ret_55

let rec parseFileRec = fun path seen depth -> try (
  ignore (if depth > 25 then ignore ((
    ignore (print_endline ("hxhx(stage1): hxml include depth exceeded: " ^ HxString.toStdString path));
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  )) else ());
  let norm = Haxe_io_Path.normalize path in (
    ignore (if HxMap.exists_string seen norm then ignore ((
      ignore (print_endline ("hxhx(stage1): hxml include cycle: " ^ HxString.toStdString norm));
      raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
    )) else ());
    ignore (HxMap.set_string seen norm true);
    let tempMaybeString = ref (Obj.magic ()) in (
      ignore (try let __assign_1 = HxFile.getContent norm in (
        tempMaybeString := __assign_1;
        __assign_1
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_2 -> raise (HxRuntime.Hx_return __ret_2)
        | HxRuntime.Hx_exception (__exn_v_3, __exn_tags_4) -> if true then let _hx = (__exn_v_3 : Obj.t) in (
          ignore _hx;
          let __assign_5 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_5;
            __assign_5
          )
        ) else HxRuntime.hx_throw_typed __exn_v_3 __exn_tags_4
        | __exn_6 -> if true then let _hx = (Obj.repr __exn_6 : Obj.t) in (
          ignore _hx;
          let __assign_7 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_7;
            __assign_7
          )
        ) else raise (__exn_6));
      let content = !tempMaybeString in (
        ignore (if content == Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (print_endline ("hxhx(stage1): failed to read hxml: " ^ HxString.toStdString norm));
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        let fileDir0 = Haxe_io_Path.directory norm in let tempString = ref "" in (
          ignore (if fileDir0 == Obj.magic (HxRuntime.hx_null) || HxString.length fileDir0 = 0 then let __assign_8 = "." in (
            tempString := __assign_8;
            __assign_8
          ) else let __assign_9 = fileDir0 in (
            tempString := __assign_9;
            __assign_9
          ));
          let tokens = HxArray.create () in let lines = HxString.split content "\n" in (
            ignore (let _g = ref 0 in while !_g < HxArray.length lines do ignore (let ln = HxArray.get lines (!_g) in (
              ignore (let __old_10 = !_g in let __new_11 = HxInt.add __old_10 1 in (
                ignore (_g := __new_11);
                __new_11
              ));
              let lineTokens = tokenizeLine ln in (
                ignore (if lineTokens == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
                let _g2 = ref 0 in while !_g2 < HxArray.length lineTokens do ignore (let t = HxArray.get lineTokens (!_g2) in (
                  ignore (let __old_12 = !_g2 in let __new_13 = HxInt.add __old_12 1 in (
                    ignore (_g2 := __new_13);
                    __new_13
                  ));
                  HxArray.push tokens t
                )) done
              )
            )) done);
            let i = ref 0 in (
              ignore (while !i < HxArray.length tokens do ignore (let _g = HxArray.get tokens (!i) in match _g with
                | "-cp" | "-p" -> ignore ((
                  ignore (if HxInt.add (!i) 1 < HxArray.length tokens then ignore (let cp = HxArray.get tokens (HxInt.add (!i) 1) in if cp != Obj.magic (HxRuntime.hx_null) && HxString.length cp > 0 && not (Haxe_io_Path.isAbsolute cp) then ignore (let __assign_14 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_15 = HxArray.create () in (
                    ignore (HxArray.push __arr_15 (!tempString));
                    ignore (HxArray.push __arr_15 cp);
                    __arr_15
                  ))) in HxArray.set tokens (HxInt.add (!i) 1) __assign_14) else ()) else ());
                  i := HxInt.add (!i) 2
                ))
                | _ -> ignore (i := HxInt.add (!i) 1)) done);
              let out = HxArray.create () in (
                ignore (let _g = ref 0 in try while !_g < HxArray.length tokens do try ignore (let t = HxArray.get tokens (!_g) in (
                  ignore (let __old_16 = !_g in let __new_17 = HxInt.add __old_16 1 in (
                    ignore (_g := __new_17);
                    __new_17
                  ));
                  ignore (if HxString.equals t "--next" || HxString.equals t "--each" then ignore ((
                    ignore (print_endline ("hxhx(stage1): unsupported hxml directive: " ^ HxString.toStdString t));
                    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
                  )) else ());
                  ignore (if not (StringTools.startsWith t "-") && StringTools.endsWith t ".hxml" then ignore (let tempString1 = ref "" in (
                    ignore (if Haxe_io_Path.isAbsolute t then let __assign_18 = Haxe_io_Path.normalize t in (
                      tempString1 := __assign_18;
                      __assign_18
                    ) else let __assign_19 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_20 = HxArray.create () in (
                      ignore (HxArray.push __arr_20 (!tempString));
                      ignore (HxArray.push __arr_20 t);
                      __arr_20
                    ))) in (
                      tempString1 := __assign_19;
                      __assign_19
                    ));
                    let included = !tempString1 in let expanded = parseFileRec included seen (HxInt.add depth 1) in (
                      ignore (if expanded == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
                      ignore (let _g2 = ref 0 in while !_g2 < HxArray.length expanded do ignore (let x = HxArray.get expanded (!_g2) in (
                        ignore (let __old_21 = !_g2 in let __new_22 = HxInt.add __old_21 1 in (
                          ignore (_g2 := __new_22);
                          __new_22
                        ));
                        HxArray.push out x
                      )) done);
                      raise (HxRuntime.Hx_continue)
                    )
                  )) else ());
                  HxArray.push out t
                )) with
                  | HxRuntime.Hx_continue -> () done with
                  | HxRuntime.Hx_break -> ());
                out
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_23 -> Obj.obj __ret_23

let parseFile = fun path -> let seen = HxMap.create_string () in parseFileRec (Haxe_io_Path.normalize path) seen 0
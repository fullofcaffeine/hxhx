# 1 "ParserStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ParserStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ParserStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ParserStage" } : t)

let expectedMainClassFromFile = fun filePath -> try (
  ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let name = Haxe_io_Path.withoutDirectory filePath in let dot = HxString.lastIndexOf name "." (HxString.length name) in let tempResult = ref (Obj.magic ()) in (
    ignore (if dot <= 0 then let __assign_1 = name in (
      tempResult := __assign_1;
      __assign_1
    ) else let __assign_2 = HxString.substr name 0 dot in (
      tempResult := __assign_2;
      __assign_2
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let parseReturnExprText = fun raw -> try let stripNewTypeParams = fun s -> try let tempString = ref "" in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then let __assign_105 = "" in (
    tempString := __assign_105;
    __assign_105
  ) else let __assign_106 = StringTools.trim s in (
    tempString := __assign_106;
    __assign_106
  ));
  let t = !tempString in (
    ignore (if not (StringTools.startsWith t "new") then raise (HxRuntime.Hx_return (Obj.repr s)) else ());
    let norm = ref t in (
      ignore (if HxString.length (!norm) > 3 then ignore (let c3 = HxString.charCodeAt (!norm) 3 in let isWs = (let __nullable_107 = c3 in if __nullable_107 == HxRuntime.hx_null then false else Obj.obj __nullable_107 = 32) || (let __nullable_108 = c3 in if __nullable_108 == HxRuntime.hx_null then false else Obj.obj __nullable_108 = 9) || (let __nullable_109 = c3 in if __nullable_109 == HxRuntime.hx_null then false else Obj.obj __nullable_109 = 10) || (let __nullable_110 = c3 in if __nullable_110 == HxRuntime.hx_null then false else Obj.obj __nullable_110 = 13) in if not (isWs) then ignore (let __assign_111 = "new " ^ HxString.toStdString (HxString.substr (!norm) 3 (-1)) in (
        norm := __assign_111;
        __assign_111
      )) else ()) else ());
      ignore (if not (StringTools.startsWith (!norm) "new ") then raise (HxRuntime.Hx_return (Obj.repr (!norm))) else ());
      let lt = HxString.indexOf (!norm) "<" 0 in let lp = HxString.indexOf (!norm) "(" 0 in (
        ignore (if lt < 0 || lp < 0 || lt > lp then raise (HxRuntime.Hx_return (Obj.repr s)) else ());
        let depth = ref 0 in let i = ref lt in (
          ignore (while !i < HxString.length (!norm) do ignore (let c = HxString.charCodeAt (!norm) (!i) in (
            ignore (if let __nullable_112 = c in if __nullable_112 == HxRuntime.hx_null then false else Obj.obj __nullable_112 = 60 then ignore (let __old_113 = !depth in let __new_114 = HxInt.add __old_113 1 in (
              ignore (depth := __new_114);
              __old_113
            )) else ignore (if let __nullable_115 = c in if __nullable_115 == HxRuntime.hx_null then false else Obj.obj __nullable_115 = 62 then ignore ((
              ignore (let __old_116 = !depth in let __new_117 = HxInt.add __old_116 (-1) in (
                ignore (depth := __new_117);
                __old_116
              ));
              if !depth = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxString.toStdString (HxString.substr (!norm) 0 lt) ^ HxString.toStdString (HxString.substr (!norm) (HxInt.add (!i) 1) (-1))))) else ()
            )) else ()));
            let __old_118 = !i in let __new_119 = HxInt.add __old_118 1 in (
              ignore (i := __new_119);
              __old_118
            )
          )) done);
          !norm
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_120 -> Obj.obj __ret_120 in let s = StringTools.trim raw in let s = stripNewTypeParams s in (
  ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EUnsupported "<empty-return-expr>"))) else ());
  ignore (if HxString.equals s "null" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.ENull))) else ());
  ignore (if HxString.equals s "true" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool true))) else ());
  ignore (if HxString.equals s "false" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool false))) else ());
  ignore (if HxString.length s >= 2 && StringTools.startsWith s "\"" && StringTools.endsWith s "\"" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EString (HxString.substr s 1 (HxInt.sub (HxString.length s) 2))))) else ());
  ignore (let i = ref 0 in let sign = ref 1 in (
    ignore (if HxString.length s > 0 && (let __nullable_121 = HxString.charCodeAt s 0 in if __nullable_121 == HxRuntime.hx_null then false else Obj.obj __nullable_121 = 45) then ignore ((
      ignore (let __assign_122 = -1 in (
        sign := __assign_122;
        __assign_122
      ));
      let __assign_123 = 1 in (
        i := __assign_123;
        __assign_123
      )
    )) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_124 = c in let __nullable_125 = 48 in if __nullable_124 == HxRuntime.hx_null then false else Obj.obj __nullable_124 < __nullable_125) || (let __nullable_126 = c in let __nullable_127 = 57 in if __nullable_126 == HxRuntime.hx_null then false else Obj.obj __nullable_126 > __nullable_127) then ignore ((
          ignore (let __assign_128 = false in (
            saw := __assign_128;
            __assign_128
          ));
          raise (HxRuntime.Hx_break)
        )) else ());
        ignore (let __assign_129 = true in (
          saw := __assign_129;
          __assign_129
        ));
        ignore (let __assign_130 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_131 = c in if __nullable_int_131 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_131) 48) in (
          value := __assign_130;
          __assign_130
        ));
        let __old_132 = !i in let __new_133 = HxInt.add __old_132 1 in (
          ignore (i := __new_133);
          __old_132
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      if !saw && !i = HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EInt (HxInt.mul (!sign) (!value))))) else ()
    )
  ));
  ignore (if HxString.indexOf s "." 0 <> -1 then ignore (let f = Std.parseFloat s in if not (Math.isNaN f) then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EFloat f))) else ()) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (try let __assign_134 = HxParser.parseExprText s in (
      tempResult := __assign_134;
      __assign_134
    ) with
      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
      | HxRuntime.Hx_return __ret_135 -> raise (HxRuntime.Hx_return __ret_135)
      | HxRuntime.Hx_exception (__exn_v_136, __exn_tags_137) -> if true then let _hx = (__exn_v_136 : Obj.t) in (
        ignore _hx;
        let __assign_138 = HxExpr.EUnsupported s in (
          tempResult := __assign_138;
          __assign_138
        )
      ) else HxRuntime.hx_throw_typed __exn_v_136 __exn_tags_137
      | __exn_139 -> if true then let _hx = (Obj.repr __exn_139 : Obj.t) in (
        ignore _hx;
        let __assign_140 = HxExpr.EUnsupported s in (
          tempResult := __assign_140;
          __assign_140
        )
      ) else raise (__exn_139));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_141 -> Obj.obj __ret_141

let decodeMethodPayload = fun payload methodBodySrc -> let parts = HxString.split payload "|" in (
  ignore (while HxArray.length parts < 9 do ignore (HxArray.push parts "") done);
  let name = HxArray.get parts 0 in let tempHxVisibility = ref (Obj.magic ()) in (
    ignore (if HxString.equals (HxArray.get parts 1) "private" then let __assign_47 = HxVisibility.Private in (
      tempHxVisibility := __assign_47;
      __assign_47
    ) else let __assign_48 = HxVisibility.Public in (
      tempHxVisibility := __assign_48;
      __assign_48
    ));
    let vis = !tempHxVisibility in let isStatic = HxString.equals (HxArray.get parts 2) "1" in let argTypes = HxMap.create_string () in let restArgsByName = HxMap.create_string () in let argTypesPayload = HxArray.get parts 7 in (
      ignore (if HxString.length argTypesPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argTypesPayload "," in try while !_g < HxArray.length _g1 do try ignore (let entry = HxArray.get _g1 (!_g) in (
        ignore (let __old_49 = !_g in let __new_50 = HxInt.add __old_49 1 in (
          ignore (_g := __new_50);
          __new_50
        ));
        ignore (if HxString.length entry = 0 then raise (HxRuntime.Hx_continue) else ());
        let idx = HxString.indexOf entry ":" 0 in (
          ignore (if idx <= 0 then raise (HxRuntime.Hx_continue) else ());
          let argName = ref (HxString.substr entry 0 idx) in (
            ignore (if StringTools.startsWith (!argName) "..." then ignore ((
              ignore (let __assign_51 = HxString.substr (!argName) 3 (-1) in (
                argName := __assign_51;
                __assign_51
              ));
              HxMap.set_string restArgsByName (!argName) true
            )) else ());
            let ty = HxString.substr entry (HxInt.add idx 1) (-1) in HxMap.set_string argTypes (!argName) ty
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      let args = HxArray.create () in let argsPayload = HxArray.get parts 3 in (
        ignore (if HxString.length argsPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argsPayload "," in try while !_g < HxArray.length _g1 do try ignore (let a = HxArray.get _g1 (!_g) in (
          ignore (let __old_52 = !_g in let __new_53 = HxInt.add __old_52 1 in (
            ignore (_g := __new_53);
            __new_53
          ));
          ignore (if HxString.length a = 0 then raise (HxRuntime.Hx_continue) else ());
          let rawName = ref a in let isRest = ref false in (
            ignore (if StringTools.startsWith (!rawName) "..." then ignore ((
              ignore (let __assign_54 = true in (
                isRest := __assign_54;
                __assign_54
              ));
              let __assign_55 = HxString.substr (!rawName) 3 (-1) in (
                rawName := __assign_55;
                __assign_55
              )
            )) else ());
            ignore (if not (!isRest) && HxMap.exists_string restArgsByName (!rawName) then ignore (let __assign_56 = true in (
              isRest := __assign_56;
              __assign_56
            )) else ());
            let tempMaybeString = ref (Obj.magic ()) in (
              ignore (if HxMap.exists_string argTypes (!rawName) then let __assign_57 = HxMap.get_string argTypes (!rawName) in (
                tempMaybeString := __assign_57;
                __assign_57
              ) else let __assign_58 = "" in (
                tempMaybeString := __assign_58;
                __assign_58
              ));
              let ty = ref (!tempMaybeString) in let isOptional = ref false in (
                ignore (if !isRest then ignore (let tempMaybeString1 = ref (Obj.magic ()) in (
                  ignore (if !ty == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim (!ty)) = 0 then let __assign_59 = "Dynamic" in (
                    tempMaybeString1 := __assign_59;
                    __assign_59
                  ) else let __assign_60 = !ty in (
                    tempMaybeString1 := __assign_60;
                    __assign_60
                  ));
                  let inner = !tempMaybeString1 in (
                    ignore (let __assign_61 = ("Array<" ^ HxString.toStdString inner) ^ ">" in (
                      ty := __assign_61;
                      __assign_61
                    ));
                    let __assign_62 = true in (
                      isOptional := __assign_62;
                      __assign_62
                    )
                  )
                )) else ());
                HxArray.push args (HxFunctionArg.create (!rawName) (!ty) (HxDefaultValue.NoDefault) (!isOptional) (!isRest))
              )
            )
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ()) else ());
        let returnTypeHint = HxArray.get parts 4 in let retStr = HxArray.get parts 5 in let retId = HxArray.get parts 6 in let retExpr = HxArray.get parts 8 in let body = ref (HxArray.create ()) in let pos = HxPos.unknown () in (
          ignore (if HxString.length retExpr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (parseReturnExprText retExpr, pos))) else ignore (if HxString.length retStr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EString retStr, pos))) else ignore (if HxString.length retId > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EIdent retId, pos))) else ())));
          ignore (if methodBodySrc != Obj.magic (HxRuntime.hx_null) && HxString.length methodBodySrc > 0 then ignore ((
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_HAVE") "1" then ignore (try print_endline ((("body_parse_have=" ^ HxString.toStdString name) ^ " len=") ^ string_of_int (HxString.length methodBodySrc)) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_63 -> raise (HxRuntime.Hx_return __ret_63)
              | HxRuntime.Hx_exception (__exn_v_64, __exn_tags_65) -> if true then let _hx = (__exn_v_64 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_64 __exn_tags_65
              | __exn_66 -> if true then let _hx = (Obj.repr __exn_66 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_66)) else ());
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_SRC") "1" then ignore (try let oneLine = HxArray.join (HxString.split methodBodySrc "\n") "\\n" (fun x -> x) in let max = 300 in let tempString = ref "" in (
              ignore (if HxString.length oneLine > max then let __assign_67 = HxString.toStdString (HxString.substr oneLine 0 max) ^ "..." in (
                tempString := __assign_67;
                __assign_67
              ) else let __assign_68 = oneLine in (
                tempString := __assign_68;
                __assign_68
              ));
              let shown = !tempString in print_endline ((("body_parse_src=" ^ HxString.toStdString name) ^ " ") ^ HxString.toStdString shown)
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_69 -> raise (HxRuntime.Hx_return __ret_69)
              | HxRuntime.Hx_exception (__exn_v_70, __exn_tags_71) -> if true then let _hx = (__exn_v_70 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_70 __exn_tags_71
              | __exn_72 -> if true then let _hx = (Obj.repr __exn_72 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_72)) else ());
            ignore (let __assign_73 = name in (
              HxParser.debugBodyLabel := __assign_73;
              __assign_73
            ));
            ignore (try let __assign_74 = HxParser.parseFunctionBodyText methodBodySrc in (
              body := __assign_74;
              __assign_74
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_75 -> raise (HxRuntime.Hx_return __ret_75)
              | HxRuntime.Hx_exception (__exn_v_76, __exn_tags_77) -> if true then let e = (__exn_v_76 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_78 -> raise (HxRuntime.Hx_return __ret_78)
                    | HxRuntime.Hx_exception (__exn_v_79, __exn_tags_80) -> if true then let _hx = (__exn_v_79 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_79 __exn_tags_80
                    | __exn_81 -> if true then let _hx = (Obj.repr __exn_81 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_81)) else ());
                  let __assign_82 = !body in (
                    body := __assign_82;
                    __assign_82
                  )
                )
              ) else HxRuntime.hx_throw_typed __exn_v_76 __exn_tags_77
              | __exn_83 -> if true then let e = (Obj.repr __exn_83 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_84 -> raise (HxRuntime.Hx_return __ret_84)
                    | HxRuntime.Hx_exception (__exn_v_85, __exn_tags_86) -> if true then let _hx = (__exn_v_85 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_85 __exn_tags_86
                    | __exn_87 -> if true then let _hx = (Obj.repr __exn_87 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_87)) else ());
                  let __assign_88 = !body in (
                    body := __assign_88;
                    __assign_88
                  )
                )
              ) else raise (__exn_83));
            let __assign_89 = "" in (
              HxParser.debugBodyLabel := __assign_89;
              __assign_89
            )
          )) else ());
          HxFunctionDecl.create name vis isStatic args returnTypeHint (!body) retStr
        )
      )
    )
  )
)

let decodeStaticFinalPayload = fun payload -> try (
  ignore (if payload == Obj.magic (HxRuntime.hx_null) || HxString.length payload = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let lines = HxString.split payload "\n" in let tempString = ref "" in (
    ignore (if HxArray.length lines > 0 then let __assign_90 = HxArray.get lines 0 in (
      tempString := __assign_90;
      __assign_90
    ) else let __assign_91 = "" in (
      tempString := __assign_91;
      __assign_91
    ));
    ignore (if HxString.length (!tempString) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let tempString1 = ref "" in (
      ignore (if HxArray.length lines > 1 then let __assign_92 = HxArray.get lines 1 in (
        tempString1 := __assign_92;
        __assign_92
      ) else let __assign_93 = "public" in (
        tempString1 := __assign_93;
        __assign_93
      ));
      let tempHxVisibility = ref (Obj.magic ()) in (
        ignore (if HxString.equals (!tempString1) "private" then let __assign_94 = HxVisibility.Private in (
          tempHxVisibility := __assign_94;
          __assign_94
        ) else let __assign_95 = HxVisibility.Public in (
          tempHxVisibility := __assign_95;
          __assign_95
        ));
        let vis = !tempHxVisibility in let tempString2 = ref "" in (
          ignore (if HxArray.length lines > 2 then let __assign_96 = HxArray.get lines 2 in (
            tempString2 := __assign_96;
            __assign_96
          ) else let __assign_97 = "1" in (
            tempString2 := __assign_97;
            __assign_97
          ));
          let isStatic = HxString.equals (!tempString2) "1" in let tempString3 = ref "" in (
            ignore (if HxArray.length lines > 3 then let __assign_98 = HxArray.get lines 3 in (
              tempString3 := __assign_98;
              __assign_98
            ) else let __assign_99 = "" in (
              tempString3 := __assign_99;
              __assign_99
            ));
            let tempString4 = ref "" in (
              ignore (if HxArray.length lines > 4 then let __assign_100 = HxArray.join (HxArray.slice lines 4 (HxArray.length lines)) "\n" (fun x -> x) in (
                tempString4 := __assign_100;
                __assign_100
              ) else let __assign_101 = "" in (
                tempString4 := __assign_101;
                __assign_101
              ));
              let tempMaybeHxExpr = ref (Obj.magic ()) in (
                ignore (if HxString.length (!tempString4) > 0 then let __assign_102 = HxEnum.box_if_needed "HxExpr" (Obj.repr (parseReturnExprText (!tempString4))) in (
                  tempMaybeHxExpr := __assign_102;
                  __assign_102
                ) else let __assign_103 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null))) in (
                  tempMaybeHxExpr := __assign_103;
                  __assign_103
                ));
                let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (!tempMaybeHxExpr)) in HxFieldDecl.create (!tempString) vis isStatic (!tempString3) (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init))
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_104 -> Obj.obj __ret_104

let parseDecInt = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length s && (let __nullable_157 = HxString.charCodeAt s (!i) in if __nullable_157 == HxRuntime.hx_null then false else Obj.obj __nullable_157 = 32) do ignore (let __old_158 = !i in let __new_159 = HxInt.add __old_158 1 in (
      ignore (i := __new_159);
      __old_158
    )) done);
    ignore (if !i >= HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_160 = c in let __nullable_161 = 48 in if __nullable_160 == HxRuntime.hx_null then false else Obj.obj __nullable_160 < __nullable_161) || (let __nullable_162 = c in let __nullable_163 = 57 in if __nullable_162 == HxRuntime.hx_null then false else Obj.obj __nullable_162 > __nullable_163) then raise (HxRuntime.Hx_break) else ());
        ignore (let __assign_164 = true in (
          saw := __assign_164;
          __assign_164
        ));
        ignore (let __assign_165 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_166 = c in if __nullable_int_166 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_166) 48) in (
          value := __assign_165;
          __assign_165
        ));
        let __old_167 = !i in let __new_168 = HxInt.add __old_167 1 in (
          ignore (i := __new_168);
          __old_167
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let tempResult = ref 0 in (
        ignore (if !saw then let __assign_169 = !value in (
          tempResult := __assign_169;
          __assign_169
        ) else let __assign_170 = -1 in (
          tempResult := __assign_170;
          __assign_170
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_171 -> Obj.obj __ret_171

let unescapePayload = fun s -> let out = StringBuf.create () in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if (let __nullable_172 = c in if __nullable_172 == HxRuntime.hx_null then false else Obj.obj __nullable_172 = 92) && HxInt.add (!i) 1 < HxString.length s then ignore (let n = HxString.charCodeAt s (HxInt.add (!i) 1) in (
      ignore (if n == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_173 = n in if __nullable_int_173 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_173)) else ignore (let __switch_175 = n in if __switch_175 == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_174 = n in if __nullable_int_174 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_174)) else match Obj.obj __switch_175 with
        | 92 -> ignore (StringBuf.addChar out 92)
        | 110 -> ignore (StringBuf.addChar out 10)
        | 114 -> ignore (StringBuf.addChar out 13)
        | 116 -> ignore (StringBuf.addChar out 9)
        | _ -> ignore (StringBuf.addChar out (let __nullable_int_174 = n in if __nullable_int_174 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_174))));
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (StringBuf.addChar out (let __nullable_int_176 = c in if __nullable_int_176 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_176));
    let __old_177 = !i in let __new_178 = HxInt.add __old_177 1 in (
      ignore (i := __new_178);
      __old_177
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  StringBuf.toString out ()
)

let decodeLenPayload = fun s -> try let colon = HxString.indexOf s ":" 0 in (
  ignore (if colon <= 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let len = parseDecInt (HxString.substr s 0 colon) in (
    ignore (if len < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let payload = HxString.substr s (HxInt.add colon 1) (-1) in let raw = HxString.substr payload 0 len in unescapePayload raw
  )
) with
  | HxRuntime.Hx_return __ret_156 -> Obj.obj __ret_156

let splitN = fun s n -> let head = HxArray.create () in let i = ref 0 in let start = ref 0 in (
  ignore (try while HxArray.length head < n && !i <= HxString.length s do try ignore ((
    ignore (if !i = HxString.length s || (let __nullable_179 = HxString.charCodeAt s (!i) in if __nullable_179 == HxRuntime.hx_null then false else Obj.obj __nullable_179 = 32) then ignore ((
      ignore (if !i > !start then ignore (HxArray.push head (HxString.substr s (!start) (HxInt.sub (!i) (!start)))) else ());
      ignore (while !i < HxString.length s && (let __nullable_180 = HxString.charCodeAt s (!i) in if __nullable_180 == HxRuntime.hx_null then false else Obj.obj __nullable_180 = 32) do ignore (let __old_181 = !i in let __new_182 = HxInt.add __old_181 1 in (
        ignore (i := __new_182);
        __old_181
      )) done);
      ignore (let __assign_183 = !i in (
        start := __assign_183;
        __assign_183
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_184 = !i in let __new_185 = HxInt.add __old_184 1 in (
      ignore (i := __new_185);
      __old_184
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (while HxArray.length head < n do ignore (HxArray.push head "") done);
  let tempString = ref "" in (
    ignore (if !start <= HxString.length s then let __assign_186 = HxString.substr s (!start) (-1) in (
      tempString := __assign_186;
      __assign_186
    ) else let __assign_187 = "" in (
      tempString := __assign_187;
      __assign_187
    ));
    ignore (HxArray.push head (!tempString));
    head
  )
)

let throwFromErrLine = fun line -> let parts = splitN line 4 in let tempNumber = ref 0 in (
  ignore (if HxArray.length parts > 1 then let __assign_142 = parseDecInt (HxArray.get parts 1) in (
    tempNumber := __assign_142;
    __assign_142
  ) else let __assign_143 = -1 in (
    tempNumber := __assign_143;
    __assign_143
  ));
  let idx = !tempNumber in let tempNumber1 = ref 0 in (
    ignore (if HxArray.length parts > 2 then let __assign_144 = parseDecInt (HxArray.get parts 2) in (
      tempNumber1 := __assign_144;
      __assign_144
    ) else let __assign_145 = -1 in (
      tempNumber1 := __assign_145;
      __assign_145
    ));
    let ln = !tempNumber1 in let tempNumber2 = ref 0 in (
      ignore (if HxArray.length parts > 3 then let __assign_146 = parseDecInt (HxArray.get parts 3) in (
        tempNumber2 := __assign_146;
        __assign_146
      ) else let __assign_147 = -1 in (
        tempNumber2 := __assign_147;
        __assign_147
      ));
      let col = !tempNumber2 in let tempString = ref "" in (
        ignore (if HxArray.length parts > 4 then let __assign_148 = HxArray.get parts 4 in (
          tempString := __assign_148;
          __assign_148
        ) else let __assign_149 = "" in (
          tempString := __assign_149;
          __assign_149
        ));
        let msg = decodeLenPayload (!tempString) in let tempNumber3 = ref 0 in (
          ignore (if idx < 0 then let __assign_150 = 0 in (
            tempNumber3 := __assign_150;
            __assign_150
          ) else let __assign_151 = idx in (
            tempNumber3 := __assign_151;
            __assign_151
          ));
          let idx0 = !tempNumber3 in let tempNumber4 = ref 0 in (
            ignore (if ln < 0 then let __assign_152 = 0 in (
              tempNumber4 := __assign_152;
              __assign_152
            ) else let __assign_153 = ln in (
              tempNumber4 := __assign_153;
              __assign_153
            ));
            let ln0 = !tempNumber4 in let tempNumber5 = ref 0 in (
              ignore (if col < 0 then let __assign_154 = 0 in (
                tempNumber5 := __assign_154;
                __assign_154
              ) else let __assign_155 = col in (
                tempNumber5 := __assign_155;
                __assign_155
              ));
              let col0 = !tempNumber5 in HxType.hx_throw_typed_rtti (Obj.repr (((((((("Native frontend: " ^ HxString.toStdString msg) ^ " (") ^ string_of_int idx0) ^ ":") ^ string_of_int ln0) ^ ":") ^ string_of_int col0) ^ ")")) ["Dynamic"; "String"]
            )
          )
        )
      )
    )
  )
)

let decodeNativeProtocol = fun encoded -> try let tempArray = ref (Obj.magic ()) in let _this = HxString.split encoded "\n" in (
  ignore (let _g = let __arr_24 = HxArray.create () in __arr_24 in (
    ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
      ignore (let __old_25 = !_g1 in let __new_26 = HxInt.add __old_25 1 in (
        ignore (_g1 := __new_26);
        __new_26
      ));
      if HxString.length v > 0 then ignore (HxArray.push _g v) else ()
    )) done);
    let __assign_27 = _g in (
      tempArray := __assign_27;
      __assign_27
    )
  ));
  ignore (if HxArray.length (!tempArray) = 0 || not (HxString.equals (HxArray.get (!tempArray) 0) "hxhx_frontend_v=1") then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing/invalid protocol header") ["Dynamic"; "String"]) else ());
  let packagePath = ref "" in let imports = HxArray.create () in let className = ref "Unknown" in let headerOnly = ref false in let hasToplevelMain = ref false in let hasStaticMain = ref false in let methodPayloads = HxArray.create () in let staticFinalPayloads = HxArray.create () in let methodBodies = HxMap.create_string () in let functions = HxArray.create () in let fields = HxArray.create () in let sawOk = ref false in (
    ignore (let _g = ref 1 in let _g1 = HxArray.length (!tempArray) in try while !_g < _g1 do try ignore (let i = let __old_28 = !_g in let __new_29 = HxInt.add __old_28 1 in (
      ignore (_g := __new_29);
      __old_28
    ) in let line = HxArray.get (!tempArray) i in (
      ignore (if HxString.equals line "ok" then ignore ((
        ignore (let __assign_30 = true in (
          sawOk := __assign_30;
          __assign_30
        ));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if StringTools.startsWith line "err " then ignore ((
        ignore (throwFromErrLine line);
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )) else ());
      if StringTools.startsWith line "ast " then ignore ((
        ignore (if StringTools.startsWith line "ast static_main " then ignore ((
          ignore (let __assign_31 = HxString.equals (HxString.substr line (HxString.length "ast static_main ") (-1)) "1" in (
            hasStaticMain := __assign_31;
            __assign_31
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        let rest = HxString.substr line (HxString.length "ast ") (-1) in let firstSpace = HxString.indexOf rest " " 0 in (
          ignore (if firstSpace <= 0 then raise (HxRuntime.Hx_continue) else ());
          let key = HxString.substr rest 0 firstSpace in let payload = decodeLenPayload (HxString.substr rest (HxInt.add firstSpace 1) (-1)) in (
            ignore (match key with
              | "class" -> ignore (let __assign_32 = payload in (
                className := __assign_32;
                __assign_32
              ))
              | "header_only" -> ignore (let __assign_33 = HxString.equals payload "1" in (
                headerOnly := __assign_33;
                __assign_33
              ))
              | "imports" -> ignore (if HxString.length payload > 0 then ignore (let _g2 = ref 0 in let _g3 = HxString.split payload "|" in while !_g2 < HxArray.length _g3 do ignore (let p = HxArray.get _g3 (!_g2) in (
                ignore (let __old_34 = !_g2 in let __new_35 = HxInt.add __old_34 1 in (
                  ignore (_g2 := __new_35);
                  __new_35
                ));
                if HxString.length p > 0 then ignore (HxArray.push imports p) else ()
              )) done) else ())
              | "method" -> ignore (HxArray.push methodPayloads payload)
              | "method_body" -> ignore (let nl = HxString.indexOf payload "\n" 0 in if nl > 0 then ignore (let name = HxString.substr payload 0 nl in if not (HxMap.exists_string methodBodies name) then ignore (let value = HxString.substr payload (HxInt.add nl 1) (-1) in HxMap.set_string methodBodies name value) else ()) else ())
              | "package" -> ignore (let __assign_36 = payload in (
                packagePath := __assign_36;
                __assign_36
              ))
              | "static_final" -> ignore (HxArray.push staticFinalPayloads payload)
              | "toplevel_main" -> ignore (let __assign_37 = HxString.equals payload "1" in (
                hasToplevelMain := __assign_37;
                __assign_37
              ))
              | _ -> ignore ());
            raise (HxRuntime.Hx_continue)
          )
        )
      )) else ()
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if not (!sawOk) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing terminal 'ok'") ["Dynamic"; "String"]) else ());
    ignore (let _g = ref 0 in while !_g < HxArray.length methodPayloads do ignore (let mp = HxArray.get methodPayloads (!_g) in (
      ignore (let __old_38 = !_g in let __new_39 = HxInt.add __old_38 1 in (
        ignore (_g := __new_39);
        __new_39
      ));
      let tempString = ref "" in (
        ignore (let parts = HxString.split mp "|" in if HxArray.length parts = 0 then let __assign_40 = "" in (
          tempString := __assign_40;
          __assign_40
        ) else let __assign_41 = HxArray.get parts 0 in (
          tempString := __assign_41;
          __assign_41
        ));
        let name = !tempString in let tempMaybeString = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string methodBodies name then let __assign_42 = HxMap.get_string methodBodies name in (
            tempMaybeString := __assign_42;
            __assign_42
          ) else let __assign_43 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_43;
            __assign_43
          ));
          HxArray.push functions (decodeMethodPayload mp (!tempMaybeString))
        )
      )
    )) done);
    ignore (let _g = ref 0 in while !_g < HxArray.length staticFinalPayloads do ignore (let fp = HxArray.get staticFinalPayloads (!_g) in (
      ignore (let __old_44 = !_g in let __new_45 = HxInt.add __old_44 1 in (
        ignore (_g := __new_45);
        __new_45
      ));
      let f = decodeStaticFinalPayload fp in if f != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push fields f) else ()
    )) done);
    HxModuleDecl.create (!packagePath) imports (HxClassDecl.create (!className) (!hasStaticMain) functions fields) (!headerOnly) (!hasToplevelMain)
  )
) with
  | HxRuntime.Hx_return __ret_46 -> Obj.obj __ret_46

let parseViaNativeHooks = fun source expectedMainClass -> let tempString = ref "" in (
  ignore (if expectedMainClass != Obj.magic (HxRuntime.hx_null) && HxString.length expectedMainClass > 0 then let __assign_22 = HxHxNativeParser.parse_module_decl_with_expected source expectedMainClass in (
    tempString := __assign_22;
    __assign_22
  ) else let __assign_23 = HxHxNativeParser.parse_module_decl source in (
    tempString := __assign_23;
    __assign_23
  ));
  decodeNativeProtocol (!tempString)
)

let parse = fun source filePath -> let expectedMainClass = expectedMainClassFromFile filePath in let tempHxModuleDecl = ref (Obj.magic ()) in let v = HxSys.getEnv "HIH_FORCE_HX_PARSER" in (
  ignore (if HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes" then let __assign_4 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
    tempHxModuleDecl := __assign_4;
    __assign_4
  ) else try let __assign_5 = parseViaNativeHooks source expectedMainClass in (
    tempHxModuleDecl := __assign_5;
    __assign_5
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_6 -> raise (HxRuntime.Hx_return __ret_6)
    | HxRuntime.Hx_exception (__exn_v_7, __exn_tags_8) -> if true then let eNative = (__exn_v_7 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_9 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_9;
          __assign_9
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_10 -> raise (HxRuntime.Hx_return __ret_10)
          | HxRuntime.Hx_exception (__exn_v_11, __exn_tags_12) -> if true then let _hx = (__exn_v_11 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_11 __exn_tags_12
          | __exn_13 -> if true then let _hx = (Obj.repr __exn_13 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_13)
      )
    ) else HxRuntime.hx_throw_typed __exn_v_7 __exn_tags_8
    | __exn_14 -> if true then let eNative = (Obj.repr __exn_14 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_15 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_15;
          __assign_15
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_16 -> raise (HxRuntime.Hx_return __ret_16)
          | HxRuntime.Hx_exception (__exn_v_17, __exn_tags_18) -> if true then let _hx = (__exn_v_17 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_17 __exn_tags_18
          | __exn_19 -> if true then let _hx = (Obj.repr __exn_19 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_19)
      )
    ) else raise (__exn_14));
  let decl = !tempHxModuleDecl in let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_20 = "<memory>" in (
      tempMaybeString := __assign_20;
      __assign_20
    ) else let __assign_21 = filePath in (
      tempMaybeString := __assign_21;
      __assign_21
    ));
    let path = !tempMaybeString in ParsedModule.create source decl path
  )
)
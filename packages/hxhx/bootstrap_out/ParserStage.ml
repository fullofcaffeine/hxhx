# 1 "ParserStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ParserStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ParserStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ParserStage" } : t)

let expectedMainClassFromFile = fun filePath -> try (
  ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let name = Haxe_io_Path.withoutDirectory filePath in let dot = HxString.lastIndexOf name "." (HxString.length name) in let tempResult = ref (Obj.magic ()) in (
    ignore (if dot <= 0 then let __assign_1 = name in (
      tempResult := __assign_1;
      __assign_1
    ) else let __assign_2 = HxString.substr name 0 dot in (
      tempResult := __assign_2;
      __assign_2
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let parseReturnExprText = fun raw -> try let s = StringTools.trim raw in (
  ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EUnsupported "<empty-return-expr>"))) else ());
  ignore (if HxString.equals s "null" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.ENull))) else ());
  ignore (if HxString.equals s "true" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool true))) else ());
  ignore (if HxString.equals s "false" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool false))) else ());
  ignore (if HxString.length s >= 2 && StringTools.startsWith s "\"" && StringTools.endsWith s "\"" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EString (HxString.substr s 1 (HxInt.sub (HxString.length s) 2))))) else ());
  let i = ref 0 in let sign = ref 1 in (
    ignore (if HxString.length s > 0 && (let __nullable_104 = HxString.charCodeAt s 0 in if __nullable_104 == HxRuntime.hx_null then false else Obj.obj __nullable_104 = 45) then ignore ((
      ignore (let __assign_105 = -1 in (
        sign := __assign_105;
        __assign_105
      ));
      let __assign_106 = 1 in (
        i := __assign_106;
        __assign_106
      )
    )) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_107 = c in let __nullable_108 = 48 in if __nullable_107 == HxRuntime.hx_null then false else Obj.obj __nullable_107 < __nullable_108) || (let __nullable_109 = c in let __nullable_110 = 57 in if __nullable_109 == HxRuntime.hx_null then false else Obj.obj __nullable_109 > __nullable_110) then ignore ((
          ignore (let __assign_111 = false in (
            saw := __assign_111;
            __assign_111
          ));
          raise (HxRuntime.Hx_break)
        )) else ());
        ignore (let __assign_112 = true in (
          saw := __assign_112;
          __assign_112
        ));
        ignore (let __assign_113 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_114 = c in if __nullable_int_114 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_114) 48) in (
          value := __assign_113;
          __assign_113
        ));
        let __old_115 = !i in let __new_116 = HxInt.add __old_115 1 in (
          ignore (i := __new_116);
          __old_115
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if !saw && !i = HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EInt (HxInt.mul (!sign) (!value))))) else ());
      ignore (if HxString.indexOf s "." 0 <> -1 then ignore (let f = Std.parseFloat s in if not (Math.isNaN f) then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EFloat f))) else ()) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (try let __assign_117 = HxParser.parseExprText s in (
          tempResult := __assign_117;
          __assign_117
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_118 -> raise (HxRuntime.Hx_return __ret_118)
          | HxRuntime.Hx_exception (__exn_v_119, __exn_tags_120) -> if true then let _hx = (__exn_v_119 : Obj.t) in (
            ignore _hx;
            let __assign_121 = HxExpr.EUnsupported s in (
              tempResult := __assign_121;
              __assign_121
            )
          ) else HxRuntime.hx_throw_typed __exn_v_119 __exn_tags_120
          | __exn_122 -> if true then let _hx = (Obj.repr __exn_122 : Obj.t) in (
            ignore _hx;
            let __assign_123 = HxExpr.EUnsupported s in (
              tempResult := __assign_123;
              __assign_123
            )
          ) else raise (__exn_122));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_124 -> Obj.obj __ret_124

let decodeMethodPayload = fun payload methodBodySrc -> let parts = HxString.split payload "|" in (
  ignore (while HxArray.length parts < 9 do ignore (HxArray.push parts "") done);
  let name = HxArray.get parts 0 in let tempHxVisibility = ref (Obj.magic ()) in (
    ignore (if HxString.equals (HxArray.get parts 1) "private" then let __assign_47 = HxVisibility.Private in (
      tempHxVisibility := __assign_47;
      __assign_47
    ) else let __assign_48 = HxVisibility.Public in (
      tempHxVisibility := __assign_48;
      __assign_48
    ));
    let vis = !tempHxVisibility in let isStatic = HxString.equals (HxArray.get parts 2) "1" in let argTypes = HxMap.create_string () in let argTypesPayload = HxArray.get parts 7 in (
      ignore (if HxString.length argTypesPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argTypesPayload "," in try while !_g < HxArray.length _g1 do try ignore (let entry = HxArray.get _g1 (!_g) in (
        ignore (let __old_49 = !_g in let __new_50 = HxInt.add __old_49 1 in (
          ignore (_g := __new_50);
          __new_50
        ));
        ignore (if HxString.length entry = 0 then raise (HxRuntime.Hx_continue) else ());
        let idx = HxString.indexOf entry ":" 0 in (
          ignore (if idx <= 0 then raise (HxRuntime.Hx_continue) else ());
          let argName = ref (HxString.substr entry 0 idx) in (
            ignore (if StringTools.startsWith (!argName) "..." then ignore (let __assign_51 = HxString.substr (!argName) 3 (-1) in (
              argName := __assign_51;
              __assign_51
            )) else ());
            let ty = HxString.substr entry (HxInt.add idx 1) (-1) in HxMap.set_string argTypes (!argName) ty
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      let args = HxArray.create () in let argsPayload = HxArray.get parts 3 in (
        ignore (if HxString.length argsPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argsPayload "," in try while !_g < HxArray.length _g1 do try ignore (let a = HxArray.get _g1 (!_g) in (
          ignore (let __old_52 = !_g in let __new_53 = HxInt.add __old_52 1 in (
            ignore (_g := __new_53);
            __new_53
          ));
          ignore (if HxString.length a = 0 then raise (HxRuntime.Hx_continue) else ());
          let rawName = ref a in let isRest = ref false in (
            ignore (if StringTools.startsWith (!rawName) "..." then ignore ((
              ignore (let __assign_54 = true in (
                isRest := __assign_54;
                __assign_54
              ));
              let __assign_55 = HxString.substr (!rawName) 3 (-1) in (
                rawName := __assign_55;
                __assign_55
              )
            )) else ());
            let tempMaybeString = ref (Obj.magic ()) in (
              ignore (if HxMap.exists_string argTypes (!rawName) then let __assign_56 = HxMap.get_string argTypes (!rawName) in (
                tempMaybeString := __assign_56;
                __assign_56
              ) else let __assign_57 = "" in (
                tempMaybeString := __assign_57;
                __assign_57
              ));
              let ty = ref (!tempMaybeString) in let isOptional = ref false in (
                ignore (if !isRest then ignore (let tempMaybeString1 = ref (Obj.magic ()) in (
                  ignore (if !ty == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim (!ty)) = 0 then let __assign_58 = "Dynamic" in (
                    tempMaybeString1 := __assign_58;
                    __assign_58
                  ) else let __assign_59 = !ty in (
                    tempMaybeString1 := __assign_59;
                    __assign_59
                  ));
                  let inner = !tempMaybeString1 in (
                    ignore (let __assign_60 = ("Array<" ^ HxString.toStdString inner) ^ ">" in (
                      ty := __assign_60;
                      __assign_60
                    ));
                    let __assign_61 = true in (
                      isOptional := __assign_61;
                      __assign_61
                    )
                  )
                )) else ());
                HxArray.push args (HxFunctionArg.create (!rawName) (!ty) (HxDefaultValue.NoDefault) (!isOptional) (!isRest))
              )
            )
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ()) else ());
        let returnTypeHint = HxArray.get parts 4 in let retStr = HxArray.get parts 5 in let retId = HxArray.get parts 6 in let retExpr = HxArray.get parts 8 in let body = ref (HxArray.create ()) in let pos = HxPos.unknown () in (
          ignore (if HxString.length retExpr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (parseReturnExprText retExpr, pos))) else ignore (if HxString.length retStr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EString retStr, pos))) else ignore (if HxString.length retId > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EIdent retId, pos))) else ())));
          ignore (if methodBodySrc != Obj.magic (HxRuntime.hx_null) && HxString.length methodBodySrc > 0 then ignore ((
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_HAVE") "1" then ignore (try print_endline ((("body_parse_have=" ^ HxString.toStdString name) ^ " len=") ^ string_of_int (HxString.length methodBodySrc)) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_62 -> raise (HxRuntime.Hx_return __ret_62)
              | HxRuntime.Hx_exception (__exn_v_63, __exn_tags_64) -> if true then let _hx = (__exn_v_63 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_63 __exn_tags_64
              | __exn_65 -> if true then let _hx = (Obj.repr __exn_65 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_65)) else ());
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_SRC") "1" then ignore (try let oneLine = HxArray.join (HxString.split methodBodySrc "\n") "\\n" (fun x -> x) in let max = 300 in let tempString = ref "" in (
              ignore (if HxString.length oneLine > max then let __assign_66 = HxString.toStdString (HxString.substr oneLine 0 max) ^ "..." in (
                tempString := __assign_66;
                __assign_66
              ) else let __assign_67 = oneLine in (
                tempString := __assign_67;
                __assign_67
              ));
              let shown = !tempString in print_endline ((("body_parse_src=" ^ HxString.toStdString name) ^ " ") ^ HxString.toStdString shown)
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_68 -> raise (HxRuntime.Hx_return __ret_68)
              | HxRuntime.Hx_exception (__exn_v_69, __exn_tags_70) -> if true then let _hx = (__exn_v_69 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_69 __exn_tags_70
              | __exn_71 -> if true then let _hx = (Obj.repr __exn_71 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_71)) else ());
            ignore (let __assign_72 = name in (
              HxParser.debugBodyLabel := __assign_72;
              __assign_72
            ));
            ignore (try let __assign_73 = HxParser.parseFunctionBodyText methodBodySrc in (
              body := __assign_73;
              __assign_73
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_74 -> raise (HxRuntime.Hx_return __ret_74)
              | HxRuntime.Hx_exception (__exn_v_75, __exn_tags_76) -> if true then let e = (__exn_v_75 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_77 -> raise (HxRuntime.Hx_return __ret_77)
                    | HxRuntime.Hx_exception (__exn_v_78, __exn_tags_79) -> if true then let _hx = (__exn_v_78 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_78 __exn_tags_79
                    | __exn_80 -> if true then let _hx = (Obj.repr __exn_80 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_80)) else ());
                  let __assign_81 = !body in (
                    body := __assign_81;
                    __assign_81
                  )
                )
              ) else HxRuntime.hx_throw_typed __exn_v_75 __exn_tags_76
              | __exn_82 -> if true then let e = (Obj.repr __exn_82 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_83 -> raise (HxRuntime.Hx_return __ret_83)
                    | HxRuntime.Hx_exception (__exn_v_84, __exn_tags_85) -> if true then let _hx = (__exn_v_84 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_84 __exn_tags_85
                    | __exn_86 -> if true then let _hx = (Obj.repr __exn_86 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_86)) else ());
                  let __assign_87 = !body in (
                    body := __assign_87;
                    __assign_87
                  )
                )
              ) else raise (__exn_82));
            let __assign_88 = "" in (
              HxParser.debugBodyLabel := __assign_88;
              __assign_88
            )
          )) else ());
          HxFunctionDecl.create name vis isStatic args returnTypeHint (!body) retStr
        )
      )
    )
  )
)

let decodeStaticFinalPayload = fun payload -> try (
  ignore (if payload == Obj.magic (HxRuntime.hx_null) || HxString.length payload = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let lines = HxString.split payload "\n" in let tempString = ref "" in (
    ignore (if HxArray.length lines > 0 then let __assign_89 = HxArray.get lines 0 in (
      tempString := __assign_89;
      __assign_89
    ) else let __assign_90 = "" in (
      tempString := __assign_90;
      __assign_90
    ));
    ignore (if HxString.length (!tempString) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let tempString1 = ref "" in (
      ignore (if HxArray.length lines > 1 then let __assign_91 = HxArray.get lines 1 in (
        tempString1 := __assign_91;
        __assign_91
      ) else let __assign_92 = "public" in (
        tempString1 := __assign_92;
        __assign_92
      ));
      let tempHxVisibility = ref (Obj.magic ()) in (
        ignore (if HxString.equals (!tempString1) "private" then let __assign_93 = HxVisibility.Private in (
          tempHxVisibility := __assign_93;
          __assign_93
        ) else let __assign_94 = HxVisibility.Public in (
          tempHxVisibility := __assign_94;
          __assign_94
        ));
        let vis = !tempHxVisibility in let tempString2 = ref "" in (
          ignore (if HxArray.length lines > 2 then let __assign_95 = HxArray.get lines 2 in (
            tempString2 := __assign_95;
            __assign_95
          ) else let __assign_96 = "1" in (
            tempString2 := __assign_96;
            __assign_96
          ));
          let isStatic = HxString.equals (!tempString2) "1" in let tempString3 = ref "" in (
            ignore (if HxArray.length lines > 3 then let __assign_97 = HxArray.get lines 3 in (
              tempString3 := __assign_97;
              __assign_97
            ) else let __assign_98 = "" in (
              tempString3 := __assign_98;
              __assign_98
            ));
            let tempString4 = ref "" in (
              ignore (if HxArray.length lines > 4 then let __assign_99 = HxArray.join (HxArray.slice lines 4 (HxArray.length lines)) "\n" (fun x -> x) in (
                tempString4 := __assign_99;
                __assign_99
              ) else let __assign_100 = "" in (
                tempString4 := __assign_100;
                __assign_100
              ));
              let tempMaybeHxExpr = ref (Obj.magic ()) in (
                ignore (if HxString.length (!tempString4) > 0 then let __assign_101 = HxEnum.box_if_needed "HxExpr" (Obj.repr (parseReturnExprText (!tempString4))) in (
                  tempMaybeHxExpr := __assign_101;
                  __assign_101
                ) else let __assign_102 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null))) in (
                  tempMaybeHxExpr := __assign_102;
                  __assign_102
                ));
                let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (!tempMaybeHxExpr)) in HxFieldDecl.create (!tempString) vis isStatic (!tempString3) (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init))
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_103 -> Obj.obj __ret_103

let parseDecInt = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length s && (let __nullable_140 = HxString.charCodeAt s (!i) in if __nullable_140 == HxRuntime.hx_null then false else Obj.obj __nullable_140 = 32) do ignore (let __old_141 = !i in let __new_142 = HxInt.add __old_141 1 in (
      ignore (i := __new_142);
      __old_141
    )) done);
    ignore (if !i >= HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_143 = c in let __nullable_144 = 48 in if __nullable_143 == HxRuntime.hx_null then false else Obj.obj __nullable_143 < __nullable_144) || (let __nullable_145 = c in let __nullable_146 = 57 in if __nullable_145 == HxRuntime.hx_null then false else Obj.obj __nullable_145 > __nullable_146) then raise (HxRuntime.Hx_break) else ());
        ignore (let __assign_147 = true in (
          saw := __assign_147;
          __assign_147
        ));
        ignore (let __assign_148 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_149 = c in if __nullable_int_149 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_149) 48) in (
          value := __assign_148;
          __assign_148
        ));
        let __old_150 = !i in let __new_151 = HxInt.add __old_150 1 in (
          ignore (i := __new_151);
          __old_150
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let tempResult = ref 0 in (
        ignore (if !saw then let __assign_152 = !value in (
          tempResult := __assign_152;
          __assign_152
        ) else let __assign_153 = -1 in (
          tempResult := __assign_153;
          __assign_153
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_154 -> Obj.obj __ret_154

let unescapePayload = fun s -> let out = StringBuf.create () in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if (let __nullable_155 = c in if __nullable_155 == HxRuntime.hx_null then false else Obj.obj __nullable_155 = 92) && HxInt.add (!i) 1 < HxString.length s then ignore (let n = HxString.charCodeAt s (HxInt.add (!i) 1) in (
      ignore (if n == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_156 = n in if __nullable_int_156 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_156)) else ignore (let __switch_158 = n in if __switch_158 == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_157 = n in if __nullable_int_157 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_157)) else match Obj.obj __switch_158 with
        | 92 -> ignore (StringBuf.addChar out 92)
        | 110 -> ignore (StringBuf.addChar out 10)
        | 114 -> ignore (StringBuf.addChar out 13)
        | 116 -> ignore (StringBuf.addChar out 9)
        | _ -> ignore (StringBuf.addChar out (let __nullable_int_157 = n in if __nullable_int_157 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_157))));
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (StringBuf.addChar out (let __nullable_int_159 = c in if __nullable_int_159 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_159));
    let __old_160 = !i in let __new_161 = HxInt.add __old_160 1 in (
      ignore (i := __new_161);
      __old_160
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  StringBuf.toString out ()
)

let decodeLenPayload = fun s -> try let colon = HxString.indexOf s ":" 0 in (
  ignore (if colon <= 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let len = parseDecInt (HxString.substr s 0 colon) in (
    ignore (if len < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let payload = HxString.substr s (HxInt.add colon 1) (-1) in let raw = HxString.substr payload 0 len in unescapePayload raw
  )
) with
  | HxRuntime.Hx_return __ret_139 -> Obj.obj __ret_139

let splitN = fun s n -> let head = HxArray.create () in let i = ref 0 in let start = ref 0 in (
  ignore (try while HxArray.length head < n && !i <= HxString.length s do try ignore ((
    ignore (if !i = HxString.length s || (let __nullable_162 = HxString.charCodeAt s (!i) in if __nullable_162 == HxRuntime.hx_null then false else Obj.obj __nullable_162 = 32) then ignore ((
      ignore (if !i > !start then ignore (HxArray.push head (HxString.substr s (!start) (HxInt.sub (!i) (!start)))) else ());
      ignore (while !i < HxString.length s && (let __nullable_163 = HxString.charCodeAt s (!i) in if __nullable_163 == HxRuntime.hx_null then false else Obj.obj __nullable_163 = 32) do ignore (let __old_164 = !i in let __new_165 = HxInt.add __old_164 1 in (
        ignore (i := __new_165);
        __old_164
      )) done);
      ignore (let __assign_166 = !i in (
        start := __assign_166;
        __assign_166
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_167 = !i in let __new_168 = HxInt.add __old_167 1 in (
      ignore (i := __new_168);
      __old_167
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (while HxArray.length head < n do ignore (HxArray.push head "") done);
  let tempString = ref "" in (
    ignore (if !start <= HxString.length s then let __assign_169 = HxString.substr s (!start) (-1) in (
      tempString := __assign_169;
      __assign_169
    ) else let __assign_170 = "" in (
      tempString := __assign_170;
      __assign_170
    ));
    ignore (HxArray.push head (!tempString));
    head
  )
)

let throwFromErrLine = fun line -> let parts = splitN line 4 in let tempNumber = ref 0 in (
  ignore (if HxArray.length parts > 1 then let __assign_125 = parseDecInt (HxArray.get parts 1) in (
    tempNumber := __assign_125;
    __assign_125
  ) else let __assign_126 = -1 in (
    tempNumber := __assign_126;
    __assign_126
  ));
  let idx = !tempNumber in let tempNumber1 = ref 0 in (
    ignore (if HxArray.length parts > 2 then let __assign_127 = parseDecInt (HxArray.get parts 2) in (
      tempNumber1 := __assign_127;
      __assign_127
    ) else let __assign_128 = -1 in (
      tempNumber1 := __assign_128;
      __assign_128
    ));
    let ln = !tempNumber1 in let tempNumber2 = ref 0 in (
      ignore (if HxArray.length parts > 3 then let __assign_129 = parseDecInt (HxArray.get parts 3) in (
        tempNumber2 := __assign_129;
        __assign_129
      ) else let __assign_130 = -1 in (
        tempNumber2 := __assign_130;
        __assign_130
      ));
      let col = !tempNumber2 in let tempString = ref "" in (
        ignore (if HxArray.length parts > 4 then let __assign_131 = HxArray.get parts 4 in (
          tempString := __assign_131;
          __assign_131
        ) else let __assign_132 = "" in (
          tempString := __assign_132;
          __assign_132
        ));
        let msg = decodeLenPayload (!tempString) in let tempNumber3 = ref 0 in (
          ignore (if idx < 0 then let __assign_133 = 0 in (
            tempNumber3 := __assign_133;
            __assign_133
          ) else let __assign_134 = idx in (
            tempNumber3 := __assign_134;
            __assign_134
          ));
          let idx0 = !tempNumber3 in let tempNumber4 = ref 0 in (
            ignore (if ln < 0 then let __assign_135 = 0 in (
              tempNumber4 := __assign_135;
              __assign_135
            ) else let __assign_136 = ln in (
              tempNumber4 := __assign_136;
              __assign_136
            ));
            let ln0 = !tempNumber4 in let tempNumber5 = ref 0 in (
              ignore (if col < 0 then let __assign_137 = 0 in (
                tempNumber5 := __assign_137;
                __assign_137
              ) else let __assign_138 = col in (
                tempNumber5 := __assign_138;
                __assign_138
              ));
              let col0 = !tempNumber5 in HxType.hx_throw_typed_rtti (Obj.repr (((((((("Native frontend: " ^ HxString.toStdString msg) ^ " (") ^ string_of_int idx0) ^ ":") ^ string_of_int ln0) ^ ":") ^ string_of_int col0) ^ ")")) ["Dynamic"; "String"]
            )
          )
        )
      )
    )
  )
)

let decodeNativeProtocol = fun encoded -> try let tempArray = ref (Obj.magic ()) in let _this = HxString.split encoded "\n" in (
  ignore (let _g = let __arr_24 = HxArray.create () in __arr_24 in (
    ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
      ignore (let __old_25 = !_g1 in let __new_26 = HxInt.add __old_25 1 in (
        ignore (_g1 := __new_26);
        __new_26
      ));
      if HxString.length v > 0 then ignore (HxArray.push _g v) else ()
    )) done);
    let __assign_27 = _g in (
      tempArray := __assign_27;
      __assign_27
    )
  ));
  ignore (if HxArray.length (!tempArray) = 0 || not (HxString.equals (HxArray.get (!tempArray) 0) "hxhx_frontend_v=1") then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing/invalid protocol header") ["Dynamic"; "String"]) else ());
  let packagePath = ref "" in let imports = HxArray.create () in let className = ref "Unknown" in let headerOnly = ref false in let hasToplevelMain = ref false in let hasStaticMain = ref false in let methodPayloads = HxArray.create () in let staticFinalPayloads = HxArray.create () in let methodBodies = HxMap.create_string () in let functions = HxArray.create () in let fields = HxArray.create () in let sawOk = ref false in (
    ignore (let _g = ref 1 in let _g1 = HxArray.length (!tempArray) in try while !_g < _g1 do try ignore (let i = let __old_28 = !_g in let __new_29 = HxInt.add __old_28 1 in (
      ignore (_g := __new_29);
      __old_28
    ) in let line = HxArray.get (!tempArray) i in (
      ignore (if HxString.equals line "ok" then ignore ((
        ignore (let __assign_30 = true in (
          sawOk := __assign_30;
          __assign_30
        ));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if StringTools.startsWith line "err " then ignore ((
        ignore (throwFromErrLine line);
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )) else ());
      if StringTools.startsWith line "ast " then ignore ((
        ignore (if StringTools.startsWith line "ast static_main " then ignore ((
          ignore (let __assign_31 = HxString.equals (HxString.substr line (HxString.length "ast static_main ") (-1)) "1" in (
            hasStaticMain := __assign_31;
            __assign_31
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        let rest = HxString.substr line (HxString.length "ast ") (-1) in let firstSpace = HxString.indexOf rest " " 0 in (
          ignore (if firstSpace <= 0 then raise (HxRuntime.Hx_continue) else ());
          let key = HxString.substr rest 0 firstSpace in let payload = decodeLenPayload (HxString.substr rest (HxInt.add firstSpace 1) (-1)) in (
            ignore (match key with
              | "class" -> ignore (let __assign_32 = payload in (
                className := __assign_32;
                __assign_32
              ))
              | "header_only" -> ignore (let __assign_33 = HxString.equals payload "1" in (
                headerOnly := __assign_33;
                __assign_33
              ))
              | "imports" -> ignore (if HxString.length payload > 0 then ignore (let _g2 = ref 0 in let _g3 = HxString.split payload "|" in while !_g2 < HxArray.length _g3 do ignore (let p = HxArray.get _g3 (!_g2) in (
                ignore (let __old_34 = !_g2 in let __new_35 = HxInt.add __old_34 1 in (
                  ignore (_g2 := __new_35);
                  __new_35
                ));
                if HxString.length p > 0 then ignore (HxArray.push imports p) else ()
              )) done) else ())
              | "method" -> ignore (HxArray.push methodPayloads payload)
              | "method_body" -> ignore (let nl = HxString.indexOf payload "\n" 0 in if nl > 0 then ignore (let name = HxString.substr payload 0 nl in if not (HxMap.exists_string methodBodies name) then ignore (let value = HxString.substr payload (HxInt.add nl 1) (-1) in HxMap.set_string methodBodies name value) else ()) else ())
              | "package" -> ignore (let __assign_36 = payload in (
                packagePath := __assign_36;
                __assign_36
              ))
              | "static_final" -> ignore (HxArray.push staticFinalPayloads payload)
              | "toplevel_main" -> ignore (let __assign_37 = HxString.equals payload "1" in (
                hasToplevelMain := __assign_37;
                __assign_37
              ))
              | _ -> ignore ());
            raise (HxRuntime.Hx_continue)
          )
        )
      )) else ()
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if not (!sawOk) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing terminal 'ok'") ["Dynamic"; "String"]) else ());
    ignore (let _g = ref 0 in while !_g < HxArray.length methodPayloads do ignore (let mp = HxArray.get methodPayloads (!_g) in (
      ignore (let __old_38 = !_g in let __new_39 = HxInt.add __old_38 1 in (
        ignore (_g := __new_39);
        __new_39
      ));
      let tempString = ref "" in (
        ignore (let parts = HxString.split mp "|" in if HxArray.length parts = 0 then let __assign_40 = "" in (
          tempString := __assign_40;
          __assign_40
        ) else let __assign_41 = HxArray.get parts 0 in (
          tempString := __assign_41;
          __assign_41
        ));
        let name = !tempString in let tempMaybeString = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string methodBodies name then let __assign_42 = HxMap.get_string methodBodies name in (
            tempMaybeString := __assign_42;
            __assign_42
          ) else let __assign_43 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_43;
            __assign_43
          ));
          HxArray.push functions (decodeMethodPayload mp (!tempMaybeString))
        )
      )
    )) done);
    ignore (let _g = ref 0 in while !_g < HxArray.length staticFinalPayloads do ignore (let fp = HxArray.get staticFinalPayloads (!_g) in (
      ignore (let __old_44 = !_g in let __new_45 = HxInt.add __old_44 1 in (
        ignore (_g := __new_45);
        __new_45
      ));
      let f = decodeStaticFinalPayload fp in if f != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push fields f) else ()
    )) done);
    HxModuleDecl.create (!packagePath) imports (HxClassDecl.create (!className) (!hasStaticMain) functions fields) (!headerOnly) (!hasToplevelMain)
  )
) with
  | HxRuntime.Hx_return __ret_46 -> Obj.obj __ret_46

let parseViaNativeHooks = fun source expectedMainClass -> let tempString = ref "" in (
  ignore (if expectedMainClass != Obj.magic (HxRuntime.hx_null) && HxString.length expectedMainClass > 0 then let __assign_22 = HxHxNativeParser.parse_module_decl_with_expected source expectedMainClass in (
    tempString := __assign_22;
    __assign_22
  ) else let __assign_23 = HxHxNativeParser.parse_module_decl source in (
    tempString := __assign_23;
    __assign_23
  ));
  decodeNativeProtocol (!tempString)
)

let parse = fun source filePath -> let expectedMainClass = expectedMainClassFromFile filePath in let tempHxModuleDecl = ref (Obj.magic ()) in let v = HxSys.getEnv "HIH_FORCE_HX_PARSER" in (
  ignore (if HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes" then let __assign_4 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
    tempHxModuleDecl := __assign_4;
    __assign_4
  ) else try let __assign_5 = parseViaNativeHooks source expectedMainClass in (
    tempHxModuleDecl := __assign_5;
    __assign_5
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_6 -> raise (HxRuntime.Hx_return __ret_6)
    | HxRuntime.Hx_exception (__exn_v_7, __exn_tags_8) -> if true then let eNative = (__exn_v_7 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_9 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_9;
          __assign_9
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_10 -> raise (HxRuntime.Hx_return __ret_10)
          | HxRuntime.Hx_exception (__exn_v_11, __exn_tags_12) -> if true then let _hx = (__exn_v_11 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_11 __exn_tags_12
          | __exn_13 -> if true then let _hx = (Obj.repr __exn_13 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_13)
      )
    ) else HxRuntime.hx_throw_typed __exn_v_7 __exn_tags_8
    | __exn_14 -> if true then let eNative = (Obj.repr __exn_14 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_15 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_15;
          __assign_15
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_16 -> raise (HxRuntime.Hx_return __ret_16)
          | HxRuntime.Hx_exception (__exn_v_17, __exn_tags_18) -> if true then let _hx = (__exn_v_17 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_17 __exn_tags_18
          | __exn_19 -> if true then let _hx = (Obj.repr __exn_19 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_19)
      )
    ) else raise (__exn_14));
  let decl = !tempHxModuleDecl in let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_20 = "<memory>" in (
      tempMaybeString := __assign_20;
      __assign_20
    ) else let __assign_21 = filePath in (
      tempMaybeString := __assign_21;
      __assign_21
    ));
    let path = !tempMaybeString in ParsedModule.create source decl path
  )
)
# 1 "ParserStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ParserStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ParserStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ParserStage" } : t)

let expectedMainClassFromFile = fun filePath -> try (
  ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let name = Haxe_io_Path.withoutDirectory filePath in let dot = HxString.lastIndexOf name "." (HxString.length name) in let tempResult = ref (Obj.magic ()) in (
    ignore (if dot <= 0 then let __assign_1 = name in (
      tempResult := __assign_1;
      __assign_1
    ) else let __assign_2 = HxString.substr name 0 dot in (
      tempResult := __assign_2;
      __assign_2
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let scanNextToken = fun source start -> try let len = HxString.length source in let i = ref start in (
  ignore (try while !i < len do try ignore (let c = HxString.charCodeAt source (!i) in let tempBool = ref false in (
    ignore (let c2 = let __nullable_int_198 = c in if __nullable_int_198 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_198 in let __assign_199 = c2 = 9 || c2 = 10 || c2 = 13 || c2 = 32 in (
      tempBool := __assign_199;
      __assign_199
    ));
    ignore (if !tempBool then ignore ((
      ignore (i := HxInt.add (!i) 1);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if (let __nullable_200 = c in if __nullable_200 == HxRuntime.hx_null then false else Obj.obj __nullable_200 = 47) && HxInt.add (!i) 1 < len && (let __nullable_201 = HxString.charCodeAt source (HxInt.add (!i) 1) in if __nullable_201 == HxRuntime.hx_null then false else Obj.obj __nullable_201 = 47) then ignore ((
      ignore (i := HxInt.add (!i) 2);
      ignore (try while !i < len do try ignore (let cc = HxString.charCodeAt source (!i) in (
        ignore (i := HxInt.add (!i) 1);
        if let __nullable_202 = cc in if __nullable_202 == HxRuntime.hx_null then false else Obj.obj __nullable_202 = 10 then raise (HxRuntime.Hx_break) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if (let __nullable_203 = c in if __nullable_203 == HxRuntime.hx_null then false else Obj.obj __nullable_203 = 47) && HxInt.add (!i) 1 < len && (let __nullable_204 = HxString.charCodeAt source (HxInt.add (!i) 1) in if __nullable_204 == HxRuntime.hx_null then false else Obj.obj __nullable_204 = 42) then ignore ((
      ignore (i := HxInt.add (!i) 2);
      ignore (try while HxInt.add (!i) 1 < len do try ignore ((
        ignore (if (let __nullable_205 = HxString.charCodeAt source (!i) in if __nullable_205 == HxRuntime.hx_null then false else Obj.obj __nullable_205 = 42) && (let __nullable_206 = HxString.charCodeAt source (HxInt.add (!i) 1) in if __nullable_206 == HxRuntime.hx_null then false else Obj.obj __nullable_206 = 47) then ignore ((
          ignore (i := HxInt.add (!i) 2);
          raise (HxRuntime.Hx_break)
        )) else ());
        i := HxInt.add (!i) 1
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if (let __nullable_207 = c in if __nullable_207 == HxRuntime.hx_null then false else Obj.obj __nullable_207 = 34) || (let __nullable_208 = c in if __nullable_208 == HxRuntime.hx_null then false else Obj.obj __nullable_208 = 39) then ignore (let quote = c in (
      ignore (i := HxInt.add (!i) 1);
      ignore (try while !i < len do try ignore (let cc = HxString.charCodeAt source (!i) in (
        ignore (i := HxInt.add (!i) 1);
        ignore (if let __nullable_209 = cc in if __nullable_209 == HxRuntime.hx_null then false else Obj.obj __nullable_209 = 92 then ignore ((
          ignore (if !i < len then ignore (i := HxInt.add (!i) 1) else ());
          raise (HxRuntime.Hx_continue)
        )) else ());
        if let __nullable_210 = cc in let __nullable_211 = quote in if __nullable_210 == HxRuntime.hx_null then __nullable_210 == HxRuntime.hx_null && __nullable_211 == HxRuntime.hx_null else not (__nullable_211 == HxRuntime.hx_null) && Obj.obj __nullable_210 = Obj.obj __nullable_211 then raise (HxRuntime.Hx_break) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if (let __nullable_212 = c in if __nullable_212 == HxRuntime.hx_null then false else Obj.obj __nullable_212 = 126) && HxInt.add (!i) 1 < len && (let __nullable_213 = HxString.charCodeAt source (HxInt.add (!i) 1) in if __nullable_213 == HxRuntime.hx_null then false else Obj.obj __nullable_213 = 47) then ignore ((
      ignore (i := HxInt.add (!i) 2);
      ignore (try while !i < len do try ignore (let cc = HxString.charCodeAt source (!i) in (
        ignore (i := HxInt.add (!i) 1);
        ignore (if let __nullable_214 = cc in if __nullable_214 == HxRuntime.hx_null then false else Obj.obj __nullable_214 = 92 then ignore ((
          ignore (if !i < len then ignore (i := HxInt.add (!i) 1) else ());
          raise (HxRuntime.Hx_continue)
        )) else ());
        if let __nullable_215 = cc in if __nullable_215 == HxRuntime.hx_null then false else Obj.obj __nullable_215 = 47 then raise (HxRuntime.Hx_break) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (try while true do try ignore (let tempRight = ref false in (
        ignore (let c2 = let __nullable_int_216 = HxString.charCodeAt source (!i) in if __nullable_int_216 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_216 in let __assign_217 = c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || c2 = 95 || c2 >= 48 && c2 <= 57 in (
          tempRight := __assign_217;
          __assign_217
        ));
        ignore (if not (!i < len && !tempRight) then raise (HxRuntime.Hx_break) else ());
        i := HxInt.add (!i) 1
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    let tempBool1 = ref false in (
      ignore (let c2 = let __nullable_int_218 = c in if __nullable_int_218 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_218 in let __assign_219 = c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || c2 = 95 in (
        tempBool1 := __assign_219;
        __assign_219
      ));
      ignore (if !tempBool1 then ignore (let startIdent = !i in (
        ignore (i := HxInt.add (!i) 1);
        ignore (try while true do try ignore (let tempRight1 = ref false in (
          ignore (let c2 = let __nullable_int_220 = HxString.charCodeAt source (!i) in if __nullable_int_220 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_220 in let __assign_221 = c2 >= 65 && c2 <= 90 || c2 >= 97 && c2 <= 122 || c2 = 95 || c2 >= 48 && c2 <= 57 in (
            tempRight1 := __assign_221;
            __assign_221
          ));
          ignore (if not (!i < len && !tempRight1) then raise (HxRuntime.Hx_break) else ());
          i := HxInt.add (!i) 1
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        raise (HxRuntime.Hx_return (Obj.repr (let __anon_222 = HxAnon.create () in (
          ignore (HxAnon.set __anon_222 "isIdent" (Obj.repr true));
          ignore (HxAnon.set __anon_222 "text" (Obj.repr (HxString.substr source startIdent (HxInt.sub (!i) startIdent))));
          ignore (HxAnon.set __anon_222 "nextPos" (Obj.repr (!i)));
          __anon_222
        ))))
      )) else ());
      ignore (if (let __nullable_223 = c in if __nullable_223 == HxRuntime.hx_null then false else Obj.obj __nullable_223 = 46) && HxInt.add (!i) 2 < len && (let __nullable_224 = HxString.charCodeAt source (HxInt.add (!i) 1) in if __nullable_224 == HxRuntime.hx_null then false else Obj.obj __nullable_224 = 46) && (let __nullable_225 = HxString.charCodeAt source (HxInt.add (!i) 2) in if __nullable_225 == HxRuntime.hx_null then false else Obj.obj __nullable_225 = 46) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_226 = HxAnon.create () in (
        ignore (HxAnon.set __anon_226 "isIdent" (Obj.repr false));
        ignore (HxAnon.set __anon_226 "text" (Obj.repr "..."));
        ignore (HxAnon.set __anon_226 "nextPos" (Obj.repr (HxInt.add (!i) 3)));
        __anon_226
      )))) else ());
      raise (HxRuntime.Hx_return (Obj.repr (let __anon_227 = HxAnon.create () in (
        ignore (HxAnon.set __anon_227 "isIdent" (Obj.repr false));
        ignore (HxAnon.set __anon_227 "text" (Obj.repr (HxString.fromCharCode (let __nullable_int_228 = c in if __nullable_int_228 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_228))));
        ignore (HxAnon.set __anon_227 "nextPos" (Obj.repr (HxInt.add (!i) 1)));
        __anon_227
      ))))
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let __anon_229 = HxAnon.create () in (
    ignore (HxAnon.set __anon_229 "isIdent" (Obj.repr false));
    ignore (HxAnon.set __anon_229 "text" (Obj.repr ""));
    ignore (HxAnon.set __anon_229 "nextPos" (Obj.repr len));
    __anon_229
  )
) with
  | HxRuntime.Hx_return __ret_230 -> Obj.obj __ret_230

let scanModuleLocalHelperTypedefs = fun source mainTypeName -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let seen = HxMap.create_string () in (
    ignore (if mainTypeName != Obj.magic (HxRuntime.hx_null) && HxString.length mainTypeName > 0 then ignore (HxMap.set_string seen mainTypeName true) else ());
    let braceDepth = ref 0 in let i = ref 0 in (
      ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
        ignore (let __assign_99 = Obj.obj (HxAnon.get t "nextPos") in (
          i := __assign_99;
          __assign_99
        ));
        ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
        ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
          ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "{" then ignore (braceDepth := HxInt.add (!braceDepth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "}" then ignore (let tempRight = ref 0 in (
            ignore (if !braceDepth > 0 then let __assign_100 = HxInt.sub (!braceDepth) 1 in (
              tempRight := __assign_100;
              __assign_100
            ) else let __assign_101 = 0 in (
              tempRight := __assign_101;
              __assign_101
            ));
            let __assign_102 = !tempRight in (
              braceDepth := __assign_102;
              __assign_102
            )
          )) else ()));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !braceDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get t "text")) "typedef") then raise (HxRuntime.Hx_continue) else ());
        let nameTok = ref (scanNextToken source (!i)) in (
          ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_103 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
            nameTok := __assign_103;
            __assign_103
          )) done);
          ignore (if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
          let typeName = Obj.obj (HxAnon.get (!nameTok) "text") in (
            ignore (let __assign_104 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
              i := __assign_104;
              __assign_104
            ));
            ignore (if typeName == Obj.magic (HxRuntime.hx_null) || HxString.length typeName = 0 then raise (HxRuntime.Hx_continue) else ());
            ignore (if HxMap.exists_string seen typeName then raise (HxRuntime.Hx_continue) else ());
            ignore (HxMap.set_string seen typeName true);
            HxArray.push out (HxClassDecl.create typeName false (let __arr_105 = HxArray.create () in __arr_105) (let __arr_106 = HxArray.create () in __arr_106))
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_107 -> Obj.obj __ret_107

let scanEnumBodyForCtors = fun source start -> let ctors = HxArray.create () in let depth = ref 1 in let i = ref start in (
  ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
    ignore (let __assign_129 = Obj.obj (HxAnon.get t "nextPos") in (
      i := __assign_129;
      __assign_129
    ));
    ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
    ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
      ignore (let _g = Obj.obj (HxAnon.get t "text") in match _g with
        | "{" -> ignore (depth := HxInt.add (!depth) 1)
        | "}" -> ignore ((
          ignore (depth := HxInt.sub (!depth) 1);
          if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
        ))
        | _ -> ignore ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if !depth <> 1 then raise (HxRuntime.Hx_continue) else ());
    let tempBool = ref false in let name = Obj.obj (HxAnon.get t "text") in (
      ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then let __assign_130 = false in (
        tempBool := __assign_130;
        __assign_130
      ) else let c = HxString.charCodeAt name 0 in let __assign_131 = (let __nullable_132 = c in let __nullable_133 = 65 in if __nullable_132 == HxRuntime.hx_null then false else Obj.obj __nullable_132 >= __nullable_133) && (let __nullable_134 = c in let __nullable_135 = 90 in if __nullable_134 == HxRuntime.hx_null then false else Obj.obj __nullable_134 <= __nullable_135) in (
        tempBool := __assign_131;
        __assign_131
      ));
      ignore (if not (!tempBool) then raise (HxRuntime.Hx_continue) else ());
      let ctorName = Obj.obj (HxAnon.get t "text") in let ctorArgs = HxArray.create () in let nt = scanNextToken source (!i) in (
        ignore (if HxString.equals (Obj.obj (HxAnon.get nt "text")) "(" then ignore ((
          ignore (let __assign_136 = Obj.obj (HxAnon.get nt "nextPos") in (
            i := __assign_136;
            __assign_136
          ));
          let parenDepth = ref 1 in let bracketDepth = ref 0 in let braceDepthInArgs = ref 0 in let angleDepth = ref 0 in let expectArg = ref true in let pendingOptional = ref false in let pendingRest = ref false in let argIndex = ref 0 in try while true do try ignore (let at = scanNextToken source (!i) in (
            ignore (let __assign_137 = Obj.obj (HxAnon.get at "nextPos") in (
              i := __assign_137;
              __assign_137
            ));
            ignore (if HxString.length (Obj.obj (HxAnon.get at "text")) = 0 then raise (HxRuntime.Hx_break) else ());
            ignore (if not (Obj.obj (HxAnon.get at "isIdent")) then ignore ((
              ignore (let _g = Obj.obj (HxAnon.get at "text") in match _g with
                | "(" -> ignore (parenDepth := HxInt.add (!parenDepth) 1)
                | ")" -> ignore ((
                  ignore (parenDepth := HxInt.sub (!parenDepth) 1);
                  if !parenDepth <= 0 then raise (HxRuntime.Hx_break) else ()
                ))
                | "," -> ignore (if !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore ((
                  ignore (let __assign_138 = true in (
                    expectArg := __assign_138;
                    __assign_138
                  ));
                  ignore (let __assign_139 = false in (
                    pendingOptional := __assign_139;
                    __assign_139
                  ));
                  let __assign_140 = false in (
                    pendingRest := __assign_140;
                    __assign_140
                  )
                )) else ())
                | "..." -> ignore (if !expectArg && !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore (let __assign_141 = true in (
                  pendingRest := __assign_141;
                  __assign_141
                )) else ())
                | "<" -> ignore (angleDepth := HxInt.add (!angleDepth) 1)
                | ">" -> ignore (if !angleDepth > 0 then ignore (angleDepth := HxInt.sub (!angleDepth) 1) else ())
                | "?" -> ignore (if !expectArg && !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore (let __assign_142 = true in (
                  pendingOptional := __assign_142;
                  __assign_142
                )) else ())
                | "[" -> ignore (bracketDepth := HxInt.add (!bracketDepth) 1)
                | "]" -> ignore (if !bracketDepth > 0 then ignore (bracketDepth := HxInt.sub (!bracketDepth) 1) else ())
                | "{" -> ignore ((
                  ignore (braceDepthInArgs := HxInt.add (!braceDepthInArgs) 1);
                  depth := HxInt.add (!depth) 1
                ))
                | "}" -> ignore ((
                  ignore (if !braceDepthInArgs > 0 then ignore (braceDepthInArgs := HxInt.sub (!braceDepthInArgs) 1) else ());
                  ignore (depth := HxInt.sub (!depth) 1);
                  if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
                ))
                | _ -> ignore ());
              raise (HxRuntime.Hx_continue)
            )) else ());
            ignore (if not (!expectArg) then raise (HxRuntime.Hx_continue) else ());
            ignore (if !parenDepth <> 1 || !bracketDepth <> 0 || !braceDepthInArgs <> 0 || !angleDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
            let nm = Obj.obj (HxAnon.get at "text") in let tempString = ref "" in (
              ignore (if nm == Obj.magic (HxRuntime.hx_null) || HxString.length nm = 0 then let __assign_143 = "arg" ^ string_of_int (!argIndex) in (
                tempString := __assign_143;
                __assign_143
              ) else let __assign_144 = nm in (
                tempString := __assign_144;
                __assign_144
              ));
              let argName = !tempString in (
                ignore (HxArray.push ctorArgs argName);
                ignore (argIndex := HxInt.add (!argIndex) 1);
                ignore (let __assign_145 = false in (
                  expectArg := __assign_145;
                  __assign_145
                ));
                ignore (let __assign_146 = false in (
                  pendingOptional := __assign_146;
                  __assign_146
                ));
                let __assign_147 = false in (
                  pendingRest := __assign_147;
                  __assign_147
                )
              )
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ()
        )) else ());
        ignore (HxArray.push ctors (let __anon_148 = HxAnon.create () in (
          ignore (HxAnon.set __anon_148 "name" (Obj.repr ctorName));
          ignore (HxAnon.set __anon_148 "args" (Obj.repr ctorArgs));
          __anon_148
        )));
        try while true do try ignore (let tt = scanNextToken source (!i) in (
          ignore (let __assign_149 = Obj.obj (HxAnon.get tt "nextPos") in (
            i := __assign_149;
            __assign_149
          ));
          ignore (if HxString.length (Obj.obj (HxAnon.get tt "text")) = 0 then raise (HxRuntime.Hx_break) else ());
          if not (Obj.obj (HxAnon.get tt "isIdent")) then ignore (if HxString.equals (Obj.obj (HxAnon.get tt "text")) "{" then ignore (depth := HxInt.add (!depth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get tt "text")) "}" then ignore ((
            ignore (depth := HxInt.sub (!depth) 1);
            if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
          )) else ignore (if !depth = 1 && (HxString.equals (Obj.obj (HxAnon.get tt "text")) ";" || HxString.equals (Obj.obj (HxAnon.get tt "text")) ",") then raise (HxRuntime.Hx_break) else ()))) else ()
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ()
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let __anon_150 = HxAnon.create () in (
    ignore (HxAnon.set __anon_150 "nextPos" (Obj.repr (!i)));
    ignore (HxAnon.set __anon_150 "ctors" (Obj.repr ctors));
    __anon_150
  )
)

let scanEnumAbstractBodyForValues = fun source start -> let values = HxArray.create () in let depth = ref 1 in let i = ref start in (
  ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
    ignore (let __assign_151 = Obj.obj (HxAnon.get t "nextPos") in (
      i := __assign_151;
      __assign_151
    ));
    ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
    ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
      ignore (let _g = Obj.obj (HxAnon.get t "text") in match _g with
        | "{" -> ignore (depth := HxInt.add (!depth) 1)
        | "}" -> ignore ((
          ignore (depth := HxInt.sub (!depth) 1);
          if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
        ))
        | _ -> ignore ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if !depth <> 1 then raise (HxRuntime.Hx_continue) else ());
    ignore (if not (HxString.equals (Obj.obj (HxAnon.get t "text")) "var") then raise (HxRuntime.Hx_continue) else ());
    let nameTok = ref (scanNextToken source (!i)) in (
      ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_152 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
        nameTok := __assign_152;
        __assign_152
      )) done);
      ignore (if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
      let name = Obj.obj (HxAnon.get (!nameTok) "text") in (
        ignore (let __assign_153 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
          i := __assign_153;
          __assign_153
        ));
        let tempBool = ref false in (
          ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then let __assign_154 = false in (
            tempBool := __assign_154;
            __assign_154
          ) else let c = HxString.charCodeAt name 0 in let __assign_155 = (let __nullable_156 = c in let __nullable_157 = 65 in if __nullable_156 == HxRuntime.hx_null then false else Obj.obj __nullable_156 >= __nullable_157) && (let __nullable_158 = c in let __nullable_159 = 90 in if __nullable_158 == HxRuntime.hx_null then false else Obj.obj __nullable_158 <= __nullable_159) in (
            tempBool := __assign_155;
            __assign_155
          ));
          if !tempBool then ignore (HxArray.push values name) else ()
        )
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let __anon_160 = HxAnon.create () in (
    ignore (HxAnon.set __anon_160 "nextPos" (Obj.repr (!i)));
    ignore (HxAnon.set __anon_160 "values" (Obj.repr values));
    __anon_160
  )
)

let scanModuleLocalHelperEnums = fun source mainTypeName -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let seen = HxMap.create_string () in (
    ignore (if mainTypeName != Obj.magic (HxRuntime.hx_null) && HxString.length mainTypeName > 0 then ignore (HxMap.set_string seen mainTypeName true) else ());
    let braceDepth = ref 0 in let i = ref 0 in (
      ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
        ignore (let __assign_61 = Obj.obj (HxAnon.get t "nextPos") in (
          i := __assign_61;
          __assign_61
        ));
        ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
        ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
          ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "{" then ignore (braceDepth := HxInt.add (!braceDepth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "}" then ignore (let tempRight = ref 0 in (
            ignore (if !braceDepth > 0 then let __assign_62 = HxInt.sub (!braceDepth) 1 in (
              tempRight := __assign_62;
              __assign_62
            ) else let __assign_63 = 0 in (
              tempRight := __assign_63;
              __assign_63
            ));
            let __assign_64 = !tempRight in (
              braceDepth := __assign_64;
              __assign_64
            )
          )) else ()));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !braceDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get t "text")) "enum") then raise (HxRuntime.Hx_continue) else ());
        let isEnumAbstract = ref false in let nameTok = ref (scanNextToken source (!i)) in (
          ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_65 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
            nameTok := __assign_65;
            __assign_65
          )) done);
          ignore (if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
          ignore (if HxString.equals (Obj.obj (HxAnon.get (!nameTok) "text")) "abstract" then ignore ((
            ignore (let __assign_66 = true in (
              isEnumAbstract := __assign_66;
              __assign_66
            ));
            ignore (let __assign_67 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
              nameTok := __assign_67;
              __assign_67
            ));
            ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_68 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
              nameTok := __assign_68;
              __assign_68
            )) done);
            if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ()
          )) else ());
          let enumName = Obj.obj (HxAnon.get (!nameTok) "text") in (
            ignore (let __assign_69 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
              i := __assign_69;
              __assign_69
            ));
            ignore (if enumName == Obj.magic (HxRuntime.hx_null) || HxString.length enumName = 0 then raise (HxRuntime.Hx_continue) else ());
            ignore (if HxMap.exists_string seen enumName then ignore (let headerTok = ref (scanNextToken source (!i)) in (
              ignore (while HxString.length (Obj.obj (HxAnon.get (!headerTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") do ignore (let __assign_70 = scanNextToken source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                headerTok := __assign_70;
                __assign_70
              )) done);
              ignore (if not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") then raise (HxRuntime.Hx_continue) else ());
              ignore (if !isEnumAbstract then ignore (let scanned = scanEnumAbstractBodyForValues source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in let __assign_71 = Obj.obj (HxAnon.get scanned "nextPos") in (
                i := __assign_71;
                __assign_71
              )) else ignore (let scanned = scanEnumBodyForCtors source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in let __assign_72 = Obj.obj (HxAnon.get scanned "nextPos") in (
                i := __assign_72;
                __assign_72
              )));
              raise (HxRuntime.Hx_continue)
            )) else ());
            ignore (HxMap.set_string seen enumName true);
            let headerTok = ref (scanNextToken source (!i)) in (
              ignore (while HxString.length (Obj.obj (HxAnon.get (!headerTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") do ignore (let __assign_73 = scanNextToken source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                headerTok := __assign_73;
                __assign_73
              )) done);
              ignore (if not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") then raise (HxRuntime.Hx_continue) else ());
              let fields = HxArray.create () in let functions = HxArray.create () in (
                ignore (if !isEnumAbstract then ignore (let scanned = scanEnumAbstractBodyForValues source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                  ignore (let __assign_74 = Obj.obj (HxAnon.get scanned "nextPos") in (
                    i := __assign_74;
                    __assign_74
                  ));
                  let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get scanned "values") in try while !_g < HxArray.length _g1 do try ignore (let v = HxArray.get _g1 (!_g) in (
                    ignore (let __old_75 = !_g in let __new_76 = HxInt.add __old_75 1 in (
                      ignore (_g := __new_76);
                      __new_76
                    ));
                    let tempBool = ref false in (
                      ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_77 = false in (
                        tempBool := __assign_77;
                        __assign_77
                      ) else let c = HxString.charCodeAt v 0 in let __assign_78 = (let __nullable_79 = c in let __nullable_80 = 65 in if __nullable_79 == HxRuntime.hx_null then false else Obj.obj __nullable_79 >= __nullable_80) && (let __nullable_81 = c in let __nullable_82 = 90 in if __nullable_81 == HxRuntime.hx_null then false else Obj.obj __nullable_81 <= __nullable_82) in (
                        tempBool := __assign_78;
                        __assign_78
                      ));
                      ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 || not (!tempBool) then raise (HxRuntime.Hx_continue) else ());
                      HxArray.push fields (HxFieldDecl.create v (HxVisibility.Public) true "Dynamic" (HxEnum.box_if_needed "HxExpr" (Obj.repr (HxExpr.EInt 0))))
                    )
                  )) with
                    | HxRuntime.Hx_continue -> () done with
                    | HxRuntime.Hx_break -> ()
                )) else ignore (let scanned = scanEnumBodyForCtors source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                  ignore (let __assign_83 = Obj.obj (HxAnon.get scanned "nextPos") in (
                    i := __assign_83;
                    __assign_83
                  ));
                  let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get scanned "ctors") in try while !_g < HxArray.length _g1 do try ignore (let ctor = HxArray.get _g1 (!_g) in (
                    ignore (let __old_84 = !_g in let __new_85 = HxInt.add __old_84 1 in (
                      ignore (_g := __new_85);
                      __new_85
                    ));
                    ignore (if ctor == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
                    let ctorName = Obj.obj (HxAnon.get ctor "name") in let tempBool1 = ref false in (
                      ignore (if ctorName == Obj.magic (HxRuntime.hx_null) || HxString.length ctorName = 0 then let __assign_86 = false in (
                        tempBool1 := __assign_86;
                        __assign_86
                      ) else let c = HxString.charCodeAt ctorName 0 in let __assign_87 = (let __nullable_88 = c in let __nullable_89 = 65 in if __nullable_88 == HxRuntime.hx_null then false else Obj.obj __nullable_88 >= __nullable_89) && (let __nullable_90 = c in let __nullable_91 = 90 in if __nullable_90 == HxRuntime.hx_null then false else Obj.obj __nullable_90 <= __nullable_91) in (
                        tempBool1 := __assign_87;
                        __assign_87
                      ));
                      ignore (if ctorName == Obj.magic (HxRuntime.hx_null) || HxString.length ctorName = 0 || not (!tempBool1) then raise (HxRuntime.Hx_continue) else ());
                      let tempArray = ref (Obj.magic ()) in (
                        ignore (if Obj.obj (HxAnon.get ctor "args") == Obj.magic (HxRuntime.hx_null) then let __assign_92 = let __arr_93 = HxArray.create () in __arr_93 in (
                          tempArray := __assign_92;
                          __assign_92
                        ) else let __assign_94 = Obj.obj (HxAnon.get ctor "args") in (
                          tempArray := __assign_94;
                          __assign_94
                        ));
                        let argNames = !tempArray in if HxArray.length argNames = 0 then ignore (HxArray.push fields (HxFieldDecl.create ctorName (HxVisibility.Public) true "Dynamic" (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null)))))) else ignore (let args = HxArray.create () in (
                          ignore (let _g2 = ref 0 in while !_g2 < HxArray.length argNames do ignore (let a = HxArray.get argNames (!_g2) in (
                            ignore (let __old_95 = !_g2 in let __new_96 = HxInt.add __old_95 1 in (
                              ignore (_g2 := __new_96);
                              __new_96
                            ));
                            HxArray.push args (HxFunctionArg.create a "" (HxDefaultValue.NoDefault) false false)
                          )) done);
                          HxArray.push functions (HxFunctionDecl.create ctorName (HxVisibility.Public) true args "Dynamic" (let __arr_97 = HxArray.create () in __arr_97) "")
                        ))
                      )
                    )
                  )) with
                    | HxRuntime.Hx_continue -> () done with
                    | HxRuntime.Hx_break -> ()
                )));
                HxArray.push out (HxClassDecl.create enumName false functions fields)
              )
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_98 -> Obj.obj __ret_98

let scanClassBodyForStatics = fun source start -> let fields = HxArray.create () in let functions = HxArray.create () in let depth = ref 1 in let i = ref start in let sawStatic = ref false in let vis = ref (HxVisibility.Public) in (
  ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
    ignore (let __assign_161 = Obj.obj (HxAnon.get t "nextPos") in (
      i := __assign_161;
      __assign_161
    ));
    ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
    ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
      ignore (let _g = Obj.obj (HxAnon.get t "text") in match _g with
        | ";" -> ignore (if !depth = 1 then ignore ((
          ignore (let __assign_162 = false in (
            sawStatic := __assign_162;
            __assign_162
          ));
          let __assign_163 = HxVisibility.Public in (
            vis := __assign_163;
            __assign_163
          )
        )) else ())
        | "{" -> ignore (depth := HxInt.add (!depth) 1)
        | "}" -> ignore ((
          ignore (depth := HxInt.sub (!depth) 1);
          if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
        ))
        | _ -> ignore ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if !depth <> 1 then raise (HxRuntime.Hx_continue) else ());
    let _g = Obj.obj (HxAnon.get t "text") in match _g with
      | "final" | "var" -> ignore ((
        ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "final" then ignore (let isFieldDecl = ref false in let j = ref (!i) in (
          ignore (try while true do try ignore (let nt = scanNextToken source (!j) in (
            ignore (if HxString.length (Obj.obj (HxAnon.get nt "text")) = 0 then ignore ((
              ignore (let __assign_164 = false in (
                isFieldDecl := __assign_164;
                __assign_164
              ));
              raise (HxRuntime.Hx_break)
            )) else ());
            ignore (let __assign_165 = Obj.obj (HxAnon.get nt "nextPos") in (
              j := __assign_165;
              __assign_165
            ));
            ignore (if not (Obj.obj (HxAnon.get nt "isIdent")) then raise (HxRuntime.Hx_continue) else ());
            ignore (let _g2 = Obj.obj (HxAnon.get nt "text") in match _g2 with
              | "extern" | "final" | "inline" | "macro" | "override" | "private" | "public" | "static" -> raise (HxRuntime.Hx_continue)
              | "function" | "var" -> ignore (let __assign_167 = false in (
                isFieldDecl := __assign_167;
                __assign_167
              ))
              | _ -> ignore (let __assign_166 = true in (
                isFieldDecl := __assign_166;
                __assign_166
              )));
            raise (HxRuntime.Hx_break)
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          if not (!isFieldDecl) then raise (HxRuntime.Hx_continue) else ()
        )) else ());
        let wantStatic = !sawStatic in let fieldVis = !vis in let wantName = ref true in let parenDepth = ref 0 in let bracketDepth = ref 0 in let angleDepth = ref 0 in (
          ignore (try while true do try ignore (let ft = scanNextToken source (!i) in (
            ignore (let __assign_168 = Obj.obj (HxAnon.get ft "nextPos") in (
              i := __assign_168;
              __assign_168
            ));
            ignore (if HxString.length (Obj.obj (HxAnon.get ft "text")) = 0 then raise (HxRuntime.Hx_break) else ());
            ignore (if not (Obj.obj (HxAnon.get ft "isIdent")) then ignore ((
              ignore (let _g2 = Obj.obj (HxAnon.get ft "text") in match _g2 with
                | "(" -> ignore (if !depth = 1 then ignore (parenDepth := HxInt.add (!parenDepth) 1) else ())
                | ")" -> ignore (if !depth = 1 && !parenDepth > 0 then ignore (parenDepth := HxInt.sub (!parenDepth) 1) else ())
                | "," -> ignore (if !depth = 1 && !parenDepth = 0 && !bracketDepth = 0 && !angleDepth = 0 then ignore (let __assign_169 = true in (
                  wantName := __assign_169;
                  __assign_169
                )) else ())
                | ";" -> ignore (if !depth = 1 && !parenDepth = 0 && !bracketDepth = 0 && !angleDepth = 0 then raise (HxRuntime.Hx_break) else ())
                | "<" -> ignore (if !depth = 1 then ignore (angleDepth := HxInt.add (!angleDepth) 1) else ())
                | ">" -> ignore (if !depth = 1 && !angleDepth > 0 then ignore (angleDepth := HxInt.sub (!angleDepth) 1) else ())
                | "[" -> ignore (if !depth = 1 then ignore (bracketDepth := HxInt.add (!bracketDepth) 1) else ())
                | "]" -> ignore (if !depth = 1 && !bracketDepth > 0 then ignore (bracketDepth := HxInt.sub (!bracketDepth) 1) else ())
                | "{" -> ignore (depth := HxInt.add (!depth) 1)
                | "}" -> ignore ((
                  ignore (depth := HxInt.sub (!depth) 1);
                  if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
                ))
                | _ -> ignore ());
              raise (HxRuntime.Hx_continue)
            )) else ());
            ignore (if !depth <> 1 then raise (HxRuntime.Hx_continue) else ());
            ignore (if not (!wantName) then raise (HxRuntime.Hx_continue) else ());
            let name = Obj.obj (HxAnon.get ft "text") in (
              ignore (let __assign_170 = false in (
                wantName := __assign_170;
                __assign_170
              ));
              ignore (if not (wantStatic) then raise (HxRuntime.Hx_continue) else ());
              ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_continue) else ());
              HxArray.push fields (HxFieldDecl.create name fieldVis true "" (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null)))))
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ignore (let __assign_171 = false in (
            sawStatic := __assign_171;
            __assign_171
          ));
          let __assign_172 = HxVisibility.Public in (
            vis := __assign_172;
            __assign_172
          )
        )
      ))
      | "function" -> ignore (let wantStaticFn = !sawStatic in let fnVis = !vis in let nameTok = ref (scanNextToken source (!i)) in (
        ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_173 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
          nameTok := __assign_173;
          __assign_173
        )) done);
        let tempString = ref "" in (
          ignore (if Obj.obj (HxAnon.get (!nameTok) "isIdent") && HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 then let __assign_174 = Obj.obj (HxAnon.get (!nameTok) "text") in (
            tempString := __assign_174;
            __assign_174
          ) else let __assign_175 = "" in (
            tempString := __assign_175;
            __assign_175
          ));
          let fnName = !tempString in (
            ignore (let __assign_176 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
              i := __assign_176;
              __assign_176
            ));
            let sigTok = ref (scanNextToken source (!i)) in (
              ignore (while HxString.length (Obj.obj (HxAnon.get (!sigTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!sigTok) "text")) "(") && not (HxString.equals (Obj.obj (HxAnon.get (!sigTok) "text")) "{") && not (HxString.equals (Obj.obj (HxAnon.get (!sigTok) "text")) ";") && not (HxString.equals (Obj.obj (HxAnon.get (!sigTok) "text")) "=") do ignore ((
                ignore (let __assign_177 = Obj.obj (HxAnon.get (!sigTok) "nextPos") in (
                  i := __assign_177;
                  __assign_177
                ));
                let __assign_178 = scanNextToken source (!i) in (
                  sigTok := __assign_178;
                  __assign_178
                )
              )) done);
              let args = HxArray.create () in (
                ignore (if HxString.equals (Obj.obj (HxAnon.get (!sigTok) "text")) "(" then ignore ((
                  ignore (let __assign_179 = Obj.obj (HxAnon.get (!sigTok) "nextPos") in (
                    i := __assign_179;
                    __assign_179
                  ));
                  let parenDepth = ref 1 in let bracketDepth = ref 0 in let braceDepthInArgs = ref 0 in let angleDepth = ref 0 in let expectArg = ref true in let pendingOptional = ref false in let pendingRest = ref false in let argIndex = ref 0 in try while true do try ignore (let at = scanNextToken source (!i) in (
                    ignore (let __assign_180 = Obj.obj (HxAnon.get at "nextPos") in (
                      i := __assign_180;
                      __assign_180
                    ));
                    ignore (if HxString.length (Obj.obj (HxAnon.get at "text")) = 0 then raise (HxRuntime.Hx_break) else ());
                    ignore (if not (Obj.obj (HxAnon.get at "isIdent")) then ignore ((
                      ignore (let _g2 = Obj.obj (HxAnon.get at "text") in match _g2 with
                        | "(" -> ignore (parenDepth := HxInt.add (!parenDepth) 1)
                        | ")" -> ignore ((
                          ignore (parenDepth := HxInt.sub (!parenDepth) 1);
                          if !parenDepth <= 0 then raise (HxRuntime.Hx_break) else ()
                        ))
                        | "," -> ignore (if !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore ((
                          ignore (let __assign_181 = true in (
                            expectArg := __assign_181;
                            __assign_181
                          ));
                          ignore (let __assign_182 = false in (
                            pendingOptional := __assign_182;
                            __assign_182
                          ));
                          let __assign_183 = false in (
                            pendingRest := __assign_183;
                            __assign_183
                          )
                        )) else ())
                        | "..." -> ignore (if !expectArg && !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore (let __assign_184 = true in (
                          pendingRest := __assign_184;
                          __assign_184
                        )) else ())
                        | "<" -> ignore (angleDepth := HxInt.add (!angleDepth) 1)
                        | ">" -> ignore (if !angleDepth > 0 then ignore (angleDepth := HxInt.sub (!angleDepth) 1) else ())
                        | "?" -> ignore (if !expectArg && !parenDepth = 1 && !bracketDepth = 0 && !braceDepthInArgs = 0 && !angleDepth = 0 then ignore (let __assign_185 = true in (
                          pendingOptional := __assign_185;
                          __assign_185
                        )) else ())
                        | "[" -> ignore (bracketDepth := HxInt.add (!bracketDepth) 1)
                        | "]" -> ignore (if !bracketDepth > 0 then ignore (bracketDepth := HxInt.sub (!bracketDepth) 1) else ())
                        | "{" -> ignore ((
                          ignore (braceDepthInArgs := HxInt.add (!braceDepthInArgs) 1);
                          depth := HxInt.add (!depth) 1
                        ))
                        | "}" -> ignore ((
                          ignore (if !braceDepthInArgs > 0 then ignore (braceDepthInArgs := HxInt.sub (!braceDepthInArgs) 1) else ());
                          ignore (depth := HxInt.sub (!depth) 1);
                          if !depth <= 0 then raise (HxRuntime.Hx_break) else ()
                        ))
                        | _ -> ignore ());
                      raise (HxRuntime.Hx_continue)
                    )) else ());
                    ignore (if not (!expectArg) then raise (HxRuntime.Hx_continue) else ());
                    ignore (if !parenDepth <> 1 || !bracketDepth <> 0 || !braceDepthInArgs <> 0 || !angleDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
                    let nm = Obj.obj (HxAnon.get at "text") in let tempString1 = ref "" in (
                      ignore (if nm == Obj.magic (HxRuntime.hx_null) || HxString.length nm = 0 then let __assign_186 = "arg" ^ string_of_int (!argIndex) in (
                        tempString1 := __assign_186;
                        __assign_186
                      ) else let __assign_187 = nm in (
                        tempString1 := __assign_187;
                        __assign_187
                      ));
                      let argName = !tempString1 in (
                        ignore (HxArray.push args (HxFunctionArg.create argName "" (HxDefaultValue.NoDefault) (!pendingOptional) (!pendingRest)));
                        ignore (argIndex := HxInt.add (!argIndex) 1);
                        ignore (let __assign_188 = false in (
                          expectArg := __assign_188;
                          __assign_188
                        ));
                        ignore (let __assign_189 = false in (
                          pendingOptional := __assign_189;
                          __assign_189
                        ));
                        let __assign_190 = false in (
                          pendingRest := __assign_190;
                          __assign_190
                        )
                      )
                    )
                  )) with
                    | HxRuntime.Hx_continue -> () done with
                    | HxRuntime.Hx_break -> ()
                )) else ());
                ignore (if wantStaticFn && HxString.length fnName > 0 && not (HxString.equals fnName "new") then ignore (HxArray.push functions (HxFunctionDecl.create fnName fnVis true args "" (let __arr_191 = HxArray.create () in __arr_191) "")) else ());
                ignore (let __assign_192 = false in (
                  sawStatic := __assign_192;
                  __assign_192
                ));
                let __assign_193 = HxVisibility.Public in (
                  vis := __assign_193;
                  __assign_193
                )
              )
            )
          )
        )
      ))
      | "extern" | "inline" | "macro" | "override" -> ignore ()
      | "private" -> ignore (let __assign_194 = HxVisibility.Private in (
        vis := __assign_194;
        __assign_194
      ))
      | "public" -> ignore (let __assign_195 = HxVisibility.Public in (
        vis := __assign_195;
        __assign_195
      ))
      | "static" -> ignore (let __assign_196 = true in (
        sawStatic := __assign_196;
        __assign_196
      ))
      | _ -> ignore ()
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let __anon_197 = HxAnon.create () in (
    ignore (HxAnon.set __anon_197 "nextPos" (Obj.repr (!i)));
    ignore (HxAnon.set __anon_197 "fields" (Obj.repr fields));
    ignore (HxAnon.set __anon_197 "functions" (Obj.repr functions));
    __anon_197
  )
)

let scanModuleLocalHelperClasses = fun source mainClassName -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let seen = HxMap.create_string () in (
    ignore (if mainClassName != Obj.magic (HxRuntime.hx_null) && HxString.length mainClassName > 0 then ignore (HxMap.set_string seen mainClassName true) else ());
    let braceDepth = ref 0 in let i = ref 0 in (
      ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
        ignore (let __assign_52 = Obj.obj (HxAnon.get t "nextPos") in (
          i := __assign_52;
          __assign_52
        ));
        ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
        ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
          ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "{" then ignore (braceDepth := HxInt.add (!braceDepth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "}" then ignore (let tempRight = ref 0 in (
            ignore (if !braceDepth > 0 then let __assign_53 = HxInt.sub (!braceDepth) 1 in (
              tempRight := __assign_53;
              __assign_53
            ) else let __assign_54 = 0 in (
              tempRight := __assign_54;
              __assign_54
            ));
            let __assign_55 = !tempRight in (
              braceDepth := __assign_55;
              __assign_55
            )
          )) else ()));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !braceDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get t "text")) "class") then raise (HxRuntime.Hx_continue) else ());
        let nameTok = ref (scanNextToken source (!i)) in (
          ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_56 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
            nameTok := __assign_56;
            __assign_56
          )) done);
          ignore (if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
          let className = Obj.obj (HxAnon.get (!nameTok) "text") in (
            ignore (let __assign_57 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
              i := __assign_57;
              __assign_57
            ));
            let isMain = mainClassName != Obj.magic (HxRuntime.hx_null) && HxString.equals className mainClassName in let alreadySeen = HxMap.exists_string seen className in let shouldRecord = not (isMain) && not (alreadySeen) in (
              ignore (if not (alreadySeen) then ignore (HxMap.set_string seen className true) else ());
              let headerTok = ref (scanNextToken source (!i)) in (
                ignore (while HxString.length (Obj.obj (HxAnon.get (!headerTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") do ignore (let __assign_58 = scanNextToken source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                  headerTok := __assign_58;
                  __assign_58
                )) done);
                ignore (if not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") then raise (HxRuntime.Hx_continue) else ());
                let bodyStart = Obj.obj (HxAnon.get (!headerTok) "nextPos") in let scanned = scanClassBodyForStatics source bodyStart in (
                  ignore (let __assign_59 = Obj.obj (HxAnon.get scanned "nextPos") in (
                    i := __assign_59;
                    __assign_59
                  ));
                  if shouldRecord then ignore (HxArray.push out (HxClassDecl.create className false (Obj.obj (HxAnon.get scanned "functions")) (Obj.obj (HxAnon.get scanned "fields")))) else ()
                )
              )
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_60 -> Obj.obj __ret_60

let scanModuleLocalHelperAbstracts = fun source mainTypeName -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let seen = HxMap.create_string () in (
    ignore (if mainTypeName != Obj.magic (HxRuntime.hx_null) && HxString.length mainTypeName > 0 then ignore (HxMap.set_string seen mainTypeName true) else ());
    let braceDepth = ref 0 in let i = ref 0 in (
      ignore (try while true do try ignore (let t = scanNextToken source (!i) in (
        ignore (let __assign_108 = Obj.obj (HxAnon.get t "nextPos") in (
          i := __assign_108;
          __assign_108
        ));
        ignore (if HxString.length (Obj.obj (HxAnon.get t "text")) = 0 then raise (HxRuntime.Hx_break) else ());
        ignore (if not (Obj.obj (HxAnon.get t "isIdent")) then ignore ((
          ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "{" then ignore (braceDepth := HxInt.add (!braceDepth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "}" then ignore (let tempRight = ref 0 in (
            ignore (if !braceDepth > 0 then let __assign_109 = HxInt.sub (!braceDepth) 1 in (
              tempRight := __assign_109;
              __assign_109
            ) else let __assign_110 = 0 in (
              tempRight := __assign_110;
              __assign_110
            ));
            let __assign_111 = !tempRight in (
              braceDepth := __assign_111;
              __assign_111
            )
          )) else ()));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if !braceDepth <> 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if HxString.equals (Obj.obj (HxAnon.get t "text")) "enum" then ignore (let enumNameTok = ref (scanNextToken source (!i)) in (
          ignore (while HxString.length (Obj.obj (HxAnon.get (!enumNameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!enumNameTok) "isIdent")) do ignore (let __assign_112 = scanNextToken source (Obj.obj (HxAnon.get (!enumNameTok) "nextPos")) in (
            enumNameTok := __assign_112;
            __assign_112
          )) done);
          ignore (if not (Obj.obj (HxAnon.get (!enumNameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!enumNameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
          let isEnumAbstract = ref false in (
            ignore (if HxString.equals (Obj.obj (HxAnon.get (!enumNameTok) "text")) "abstract" then ignore ((
              ignore (let __assign_113 = true in (
                isEnumAbstract := __assign_113;
                __assign_113
              ));
              ignore (let __assign_114 = scanNextToken source (Obj.obj (HxAnon.get (!enumNameTok) "nextPos")) in (
                enumNameTok := __assign_114;
                __assign_114
              ));
              ignore (while HxString.length (Obj.obj (HxAnon.get (!enumNameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!enumNameTok) "isIdent")) do ignore (let __assign_115 = scanNextToken source (Obj.obj (HxAnon.get (!enumNameTok) "nextPos")) in (
                enumNameTok := __assign_115;
                __assign_115
              )) done);
              if not (Obj.obj (HxAnon.get (!enumNameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!enumNameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ()
            )) else ());
            ignore (let __assign_116 = Obj.obj (HxAnon.get (!enumNameTok) "nextPos") in (
              i := __assign_116;
              __assign_116
            ));
            let enumHeaderTok = ref (scanNextToken source (!i)) in (
              ignore (while HxString.length (Obj.obj (HxAnon.get (!enumHeaderTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!enumHeaderTok) "text")) "{") && not (HxString.equals (Obj.obj (HxAnon.get (!enumHeaderTok) "text")) ";") do ignore (let __assign_117 = scanNextToken source (Obj.obj (HxAnon.get (!enumHeaderTok) "nextPos")) in (
                enumHeaderTok := __assign_117;
                __assign_117
              )) done);
              ignore (if HxString.equals (Obj.obj (HxAnon.get (!enumHeaderTok) "text")) "{" then ignore (if !isEnumAbstract then ignore (let scanned = scanEnumAbstractBodyForValues source (Obj.obj (HxAnon.get (!enumHeaderTok) "nextPos")) in let __assign_118 = Obj.obj (HxAnon.get scanned "nextPos") in (
                i := __assign_118;
                __assign_118
              )) else ignore (let scanned = scanEnumBodyForCtors source (Obj.obj (HxAnon.get (!enumHeaderTok) "nextPos")) in let __assign_119 = Obj.obj (HxAnon.get scanned "nextPos") in (
                i := __assign_119;
                __assign_119
              ))) else ignore (if HxString.length (Obj.obj (HxAnon.get (!enumHeaderTok) "text")) > 0 then ignore (let __assign_120 = Obj.obj (HxAnon.get (!enumHeaderTok) "nextPos") in (
                i := __assign_120;
                __assign_120
              )) else ()));
              raise (HxRuntime.Hx_continue)
            )
          )
        )) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get t "text")) "abstract") then raise (HxRuntime.Hx_continue) else ());
        let nameTok = ref (scanNextToken source (!i)) in (
          ignore (while HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) > 0 && not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) do ignore (let __assign_121 = scanNextToken source (Obj.obj (HxAnon.get (!nameTok) "nextPos")) in (
            nameTok := __assign_121;
            __assign_121
          )) done);
          ignore (if not (Obj.obj (HxAnon.get (!nameTok) "isIdent")) || HxString.length (Obj.obj (HxAnon.get (!nameTok) "text")) = 0 then raise (HxRuntime.Hx_continue) else ());
          let abstractName = Obj.obj (HxAnon.get (!nameTok) "text") in (
            ignore (let __assign_122 = Obj.obj (HxAnon.get (!nameTok) "nextPos") in (
              i := __assign_122;
              __assign_122
            ));
            let isMain = mainTypeName != Obj.magic (HxRuntime.hx_null) && HxString.equals abstractName mainTypeName in let alreadySeen = HxMap.exists_string seen abstractName in let shouldRecord = not (isMain) && not (alreadySeen) in (
              ignore (if not (alreadySeen) then ignore (HxMap.set_string seen abstractName true) else ());
              let fields = ref (HxArray.create ()) in let functions = ref (HxArray.create ()) in let headerTok = ref (scanNextToken source (!i)) in (
                ignore (while HxString.length (Obj.obj (HxAnon.get (!headerTok) "text")) > 0 && not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{") && not (HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) ";") do ignore (let __assign_123 = scanNextToken source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                  headerTok := __assign_123;
                  __assign_123
                )) done);
                ignore (if HxString.equals (Obj.obj (HxAnon.get (!headerTok) "text")) "{" then ignore (let scanned = scanClassBodyForStatics source (Obj.obj (HxAnon.get (!headerTok) "nextPos")) in (
                  ignore (let __assign_124 = Obj.obj (HxAnon.get scanned "nextPos") in (
                    i := __assign_124;
                    __assign_124
                  ));
                  ignore (let __assign_125 = Obj.obj (HxAnon.get scanned "fields") in (
                    fields := __assign_125;
                    __assign_125
                  ));
                  let __assign_126 = Obj.obj (HxAnon.get scanned "functions") in (
                    functions := __assign_126;
                    __assign_126
                  )
                )) else ignore (if HxString.length (Obj.obj (HxAnon.get (!headerTok) "text")) > 0 then ignore (let __assign_127 = Obj.obj (HxAnon.get (!headerTok) "nextPos") in (
                  i := __assign_127;
                  __assign_127
                )) else ()));
                if shouldRecord then ignore (HxArray.push out (HxClassDecl.create abstractName false (!functions) (!fields))) else ()
              )
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_128 -> Obj.obj __ret_128

let parseRegexLiteral = fun source -> try (
  ignore (if not (StringTools.startsWith source "~/") then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let index = ref 2 in let escaped = ref false in (
    ignore (try while !index < HxString.length source do try ignore (let code = HxString.charCodeAt source (!index) in (
      ignore (if !escaped then ignore ((
        ignore (let __assign_368 = false in (
          escaped := __assign_368;
          __assign_368
        ));
        ignore (let __old_369 = !index in let __new_370 = HxInt.add __old_369 1 in (
          ignore (index := __new_370);
          __old_369
        ));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if let __nullable_371 = code in if __nullable_371 == HxRuntime.hx_null then false else Obj.obj __nullable_371 = 92 then ignore ((
        ignore (let __assign_372 = true in (
          escaped := __assign_372;
          __assign_372
        ));
        ignore (let __old_373 = !index in let __new_374 = HxInt.add __old_373 1 in (
          ignore (index := __new_374);
          __old_373
        ));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if let __nullable_375 = code in if __nullable_375 == HxRuntime.hx_null then false else Obj.obj __nullable_375 = 47 then ignore (let pattern = HxString.substr source 2 (HxInt.sub (!index) 2) in let flags = HxString.substr source (HxInt.add (!index) 1) (-1) in let flagIndex = ref 0 in (
        ignore (while !flagIndex < HxString.length flags do ignore (let flagCode = HxString.charCodeAt flags (!flagIndex) in let isLower = (let __nullable_376 = flagCode in let __nullable_377 = 97 in if __nullable_376 == HxRuntime.hx_null then false else Obj.obj __nullable_376 >= __nullable_377) && (let __nullable_378 = flagCode in let __nullable_379 = 122 in if __nullable_378 == HxRuntime.hx_null then false else Obj.obj __nullable_378 <= __nullable_379) in let isUpper = (let __nullable_380 = flagCode in let __nullable_381 = 65 in if __nullable_380 == HxRuntime.hx_null then false else Obj.obj __nullable_380 >= __nullable_381) && (let __nullable_382 = flagCode in let __nullable_383 = 90 in if __nullable_382 == HxRuntime.hx_null then false else Obj.obj __nullable_382 <= __nullable_383) in (
          ignore (if not (isLower) && not (isUpper) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
          let __old_384 = !flagIndex in let __new_385 = HxInt.add __old_384 1 in (
            ignore (flagIndex := __new_385);
            __old_384
          )
        )) done);
        raise (HxRuntime.Hx_return (Obj.repr (let __anon_386 = HxAnon.create () in (
          ignore (HxAnon.set __anon_386 "pattern" (Obj.repr pattern));
          ignore (HxAnon.set __anon_386 "flags" (Obj.repr flags));
          __anon_386
        ))))
      )) else ());
      let __old_387 = !index in let __new_388 = HxInt.add __old_387 1 in (
        ignore (index := __new_388);
        __old_387
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_389 -> Obj.obj __ret_389

let parseReturnExprText = fun raw -> try let stripNewTypeParams = fun s -> try let tempString = ref "" in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then let __assign_328 = "" in (
    tempString := __assign_328;
    __assign_328
  ) else let __assign_329 = StringTools.trim s in (
    tempString := __assign_329;
    __assign_329
  ));
  let t = !tempString in (
    ignore (if not (StringTools.startsWith t "new") then raise (HxRuntime.Hx_return (Obj.repr s)) else ());
    let norm = ref t in (
      ignore (if HxString.length (!norm) > 3 then ignore (let c3 = HxString.charCodeAt (!norm) 3 in let isWs = (let __nullable_330 = c3 in if __nullable_330 == HxRuntime.hx_null then false else Obj.obj __nullable_330 = 32) || (let __nullable_331 = c3 in if __nullable_331 == HxRuntime.hx_null then false else Obj.obj __nullable_331 = 9) || (let __nullable_332 = c3 in if __nullable_332 == HxRuntime.hx_null then false else Obj.obj __nullable_332 = 10) || (let __nullable_333 = c3 in if __nullable_333 == HxRuntime.hx_null then false else Obj.obj __nullable_333 = 13) in if not (isWs) then ignore (let __assign_334 = "new " ^ HxString.toStdString (HxString.substr (!norm) 3 (-1)) in (
        norm := __assign_334;
        __assign_334
      )) else ()) else ());
      ignore (if not (StringTools.startsWith (!norm) "new ") then raise (HxRuntime.Hx_return (Obj.repr (!norm))) else ());
      let lt = HxString.indexOf (!norm) "<" 0 in let lp = HxString.indexOf (!norm) "(" 0 in (
        ignore (if lt < 0 || lp < 0 || lt > lp then raise (HxRuntime.Hx_return (Obj.repr s)) else ());
        let depth = ref 0 in let i = ref lt in (
          ignore (while !i < HxString.length (!norm) do ignore (let c = HxString.charCodeAt (!norm) (!i) in (
            ignore (if let __nullable_335 = c in if __nullable_335 == HxRuntime.hx_null then false else Obj.obj __nullable_335 = 60 then ignore (let __old_336 = !depth in let __new_337 = HxInt.add __old_336 1 in (
              ignore (depth := __new_337);
              __old_336
            )) else ignore (if let __nullable_338 = c in if __nullable_338 == HxRuntime.hx_null then false else Obj.obj __nullable_338 = 62 then ignore ((
              ignore (let __old_339 = !depth in let __new_340 = HxInt.add __old_339 (-1) in (
                ignore (depth := __new_340);
                __old_339
              ));
              if !depth = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxString.toStdString (HxString.substr (!norm) 0 lt) ^ HxString.toStdString (HxString.substr (!norm) (HxInt.add (!i) 1) (-1))))) else ()
            )) else ()));
            let __old_341 = !i in let __new_342 = HxInt.add __old_341 1 in (
              ignore (i := __new_342);
              __old_341
            )
          )) done);
          !norm
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_343 -> Obj.obj __ret_343 in let s = StringTools.trim raw in let s = stripNewTypeParams s in (
  ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EUnsupported "<empty-return-expr>"))) else ());
  let regexLiteral = parseRegexLiteral s in (
    ignore (if regexLiteral != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.ENew ("EReg", (let __arr_344 = HxArray.create () in (
      ignore (HxArray.push __arr_344 (HxExpr.EString (Obj.obj (HxAnon.get regexLiteral "pattern"))));
      ignore (HxArray.push __arr_344 (HxExpr.EString (Obj.obj (HxAnon.get regexLiteral "flags"))));
      __arr_344
    )))))) else ());
    ignore (if HxString.equals s "null" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.ENull))) else ());
    ignore (if HxString.equals s "true" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool true))) else ());
    ignore (if HxString.equals s "false" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool false))) else ());
    ignore (if HxString.length s >= 2 && StringTools.startsWith s "\"" && StringTools.endsWith s "\"" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EString (HxString.substr s 1 (HxInt.sub (HxString.length s) 2))))) else ());
    ignore (let i = ref 0 in let sign = ref 1 in (
      ignore (if HxString.length s > 0 && (let __nullable_345 = HxString.charCodeAt s 0 in if __nullable_345 == HxRuntime.hx_null then false else Obj.obj __nullable_345 = 45) then ignore ((
        ignore (let __assign_346 = -1 in (
          sign := __assign_346;
          __assign_346
        ));
        let __assign_347 = 1 in (
          i := __assign_347;
          __assign_347
        )
      )) else ());
      let value = ref 0 in let saw = ref false in (
        ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
          ignore (if (let __nullable_348 = c in let __nullable_349 = 48 in if __nullable_348 == HxRuntime.hx_null then false else Obj.obj __nullable_348 < __nullable_349) || (let __nullable_350 = c in let __nullable_351 = 57 in if __nullable_350 == HxRuntime.hx_null then false else Obj.obj __nullable_350 > __nullable_351) then ignore ((
            ignore (let __assign_352 = false in (
              saw := __assign_352;
              __assign_352
            ));
            raise (HxRuntime.Hx_break)
          )) else ());
          ignore (let __assign_353 = true in (
            saw := __assign_353;
            __assign_353
          ));
          ignore (let __assign_354 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_355 = c in if __nullable_int_355 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_355) 48) in (
            value := __assign_354;
            __assign_354
          ));
          let __old_356 = !i in let __new_357 = HxInt.add __old_356 1 in (
            ignore (i := __new_357);
            __old_356
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        if !saw && !i = HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EInt (HxInt.mul (!sign) (!value))))) else ()
      )
    ));
    ignore (if HxString.indexOf s "." 0 <> -1 then ignore (let f = Std.parseFloat s in if not (Math.isNaN f) then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EFloat f))) else ()) else ());
    let tempResult = ref (Obj.magic ()) in (
      ignore (try let __assign_358 = HxParser.parseExprText s in (
        tempResult := __assign_358;
        __assign_358
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_359 -> raise (HxRuntime.Hx_return __ret_359)
        | HxRuntime.Hx_exception (__exn_v_360, __exn_tags_361) -> if HxRuntime.tags_has __exn_tags_361 "HxParseError" then let _hx = (Obj.obj __exn_v_360 : HxParseError.t) in (
          ignore _hx;
          let __assign_363 = HxExpr.EUnsupported s in (
            tempResult := __assign_363;
            __assign_363
          )
        ) else if HxRuntime.tags_has __exn_tags_361 "String" then let _hx = (Obj.obj __exn_v_360 : string) in (
          ignore _hx;
          let __assign_362 = HxExpr.EUnsupported s in (
            tempResult := __assign_362;
            __assign_362
          )
        ) else HxRuntime.hx_throw_typed __exn_v_360 __exn_tags_361
        | __exn_364 -> if HxRuntime.tags_has ["OcamlExn"] "HxParseError" then let _hx = (Obj.obj (Obj.repr __exn_364) : HxParseError.t) in (
          ignore _hx;
          let __assign_366 = HxExpr.EUnsupported s in (
            tempResult := __assign_366;
            __assign_366
          )
        ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_364) : string) in (
          ignore _hx;
          let __assign_365 = HxExpr.EUnsupported s in (
            tempResult := __assign_365;
            __assign_365
          )
        ) else raise (__exn_364));
      !tempResult
    )
  )
) with
  | HxRuntime.Hx_return __ret_367 -> Obj.obj __ret_367

let decodeMethodPayload = fun payload methodBodySrc -> let parts = HxString.split payload "|" in (
  ignore (while HxArray.length parts < 9 do ignore (HxArray.push parts "") done);
  let name = HxArray.get parts 0 in let tempHxVisibility = ref (Obj.magic ()) in (
    ignore (if HxString.equals (HxArray.get parts 1) "private" then let __assign_261 = HxVisibility.Private in (
      tempHxVisibility := __assign_261;
      __assign_261
    ) else let __assign_262 = HxVisibility.Public in (
      tempHxVisibility := __assign_262;
      __assign_262
    ));
    let vis = !tempHxVisibility in let isStatic = HxString.equals (HxArray.get parts 2) "1" in let argTypes = HxMap.create_string () in let restArgsByName = HxMap.create_string () in let argTypesPayload = HxArray.get parts 7 in (
      ignore (if HxString.length argTypesPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argTypesPayload "," in try while !_g < HxArray.length _g1 do try ignore (let entry = HxArray.get _g1 (!_g) in (
        ignore (let __old_263 = !_g in let __new_264 = HxInt.add __old_263 1 in (
          ignore (_g := __new_264);
          __new_264
        ));
        ignore (if HxString.length entry = 0 then raise (HxRuntime.Hx_continue) else ());
        let idx = HxString.indexOf entry ":" 0 in (
          ignore (if idx <= 0 then raise (HxRuntime.Hx_continue) else ());
          let argName = ref (HxString.substr entry 0 idx) in (
            ignore (if StringTools.startsWith (!argName) "..." then ignore ((
              ignore (let __assign_265 = HxString.substr (!argName) 3 (-1) in (
                argName := __assign_265;
                __assign_265
              ));
              HxMap.set_string restArgsByName (!argName) true
            )) else ());
            let ty = HxString.substr entry (HxInt.add idx 1) (-1) in HxMap.set_string argTypes (!argName) ty
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      let args = HxArray.create () in let argsPayload = HxArray.get parts 3 in (
        ignore (if HxString.length argsPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argsPayload "," in try while !_g < HxArray.length _g1 do try ignore (let a = HxArray.get _g1 (!_g) in (
          ignore (let __old_266 = !_g in let __new_267 = HxInt.add __old_266 1 in (
            ignore (_g := __new_267);
            __new_267
          ));
          ignore (if HxString.length a = 0 then raise (HxRuntime.Hx_continue) else ());
          let rawName = ref a in let isRest = ref false in (
            ignore (if StringTools.startsWith (!rawName) "..." then ignore ((
              ignore (let __assign_268 = true in (
                isRest := __assign_268;
                __assign_268
              ));
              let __assign_269 = HxString.substr (!rawName) 3 (-1) in (
                rawName := __assign_269;
                __assign_269
              )
            )) else ());
            ignore (if not (!isRest) && HxMap.exists_string restArgsByName (!rawName) then ignore (let __assign_270 = true in (
              isRest := __assign_270;
              __assign_270
            )) else ());
            let tempMaybeString = ref (Obj.magic ()) in (
              ignore (if HxMap.exists_string argTypes (!rawName) then let __assign_271 = HxMap.get_string argTypes (!rawName) in (
                tempMaybeString := __assign_271;
                __assign_271
              ) else let __assign_272 = "" in (
                tempMaybeString := __assign_272;
                __assign_272
              ));
              let ty = ref (!tempMaybeString) in let isOptional = ref false in (
                ignore (if !isRest then ignore (let tempMaybeString1 = ref (Obj.magic ()) in (
                  ignore (if !ty == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim (!ty)) = 0 then let __assign_273 = "Dynamic" in (
                    tempMaybeString1 := __assign_273;
                    __assign_273
                  ) else let __assign_274 = !ty in (
                    tempMaybeString1 := __assign_274;
                    __assign_274
                  ));
                  let inner = !tempMaybeString1 in (
                    ignore (let __assign_275 = ("Array<" ^ HxString.toStdString inner) ^ ">" in (
                      ty := __assign_275;
                      __assign_275
                    ));
                    let __assign_276 = true in (
                      isOptional := __assign_276;
                      __assign_276
                    )
                  )
                )) else ());
                HxArray.push args (HxFunctionArg.create (!rawName) (!ty) (HxDefaultValue.NoDefault) (!isOptional) (!isRest))
              )
            )
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ()) else ());
        let returnTypeHint = HxArray.get parts 4 in let retStr = HxArray.get parts 5 in let retId = HxArray.get parts 6 in let retExpr = HxArray.get parts 8 in let body = ref (HxArray.create ()) in let pos = HxPos.unknown () in (
          ignore (if HxString.length retExpr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (parseReturnExprText retExpr, pos))) else ignore (if HxString.length retStr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EString retStr, pos))) else ignore (if HxString.length retId > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EIdent retId, pos))) else ())));
          ignore (if methodBodySrc != Obj.magic (HxRuntime.hx_null) && HxString.length methodBodySrc > 0 then ignore ((
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_HAVE") "1" then ignore (try print_endline ((("body_parse_have=" ^ HxString.toStdString name) ^ " len=") ^ string_of_int (HxString.length methodBodySrc)) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_277 -> raise (HxRuntime.Hx_return __ret_277)
              | HxRuntime.Hx_exception (__exn_v_278, __exn_tags_279) -> if HxRuntime.tags_has __exn_tags_279 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_278) : Haxe_io_Error.error) in (
                ignore _hx;
                ()
              ) else if HxRuntime.tags_has __exn_tags_279 "String" then let _hx = (Obj.obj __exn_v_278 : string) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_278 __exn_tags_279
              | __exn_280 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_280)) : Haxe_io_Error.error) in (
                ignore _hx;
                ()
              ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_280) : string) in (
                ignore _hx;
                ()
              ) else raise (__exn_280)) else ());
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_SRC") "1" then ignore (try let oneLine = HxArray.join (HxString.split methodBodySrc "\n") "\\n" (fun x -> x) in let max = 300 in let tempString = ref "" in (
              ignore (if HxString.length oneLine > max then let __assign_281 = HxString.toStdString (HxString.substr oneLine 0 max) ^ "..." in (
                tempString := __assign_281;
                __assign_281
              ) else let __assign_282 = oneLine in (
                tempString := __assign_282;
                __assign_282
              ));
              let shown = !tempString in print_endline ((("body_parse_src=" ^ HxString.toStdString name) ^ " ") ^ HxString.toStdString shown)
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_283 -> raise (HxRuntime.Hx_return __ret_283)
              | HxRuntime.Hx_exception (__exn_v_284, __exn_tags_285) -> if HxRuntime.tags_has __exn_tags_285 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_284) : Haxe_io_Error.error) in (
                ignore _hx;
                ()
              ) else if HxRuntime.tags_has __exn_tags_285 "String" then let _hx = (Obj.obj __exn_v_284 : string) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_284 __exn_tags_285
              | __exn_286 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_286)) : Haxe_io_Error.error) in (
                ignore _hx;
                ()
              ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_286) : string) in (
                ignore _hx;
                ()
              ) else raise (__exn_286)) else ());
            ignore (let __assign_287 = name in (
              HxParser.debugBodyLabel := __assign_287;
              __assign_287
            ));
            ignore (try let __assign_288 = HxParser.parseFunctionBodyText methodBodySrc in (
              body := __assign_288;
              __assign_288
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_289 -> raise (HxRuntime.Hx_return __ret_289)
              | HxRuntime.Hx_exception (__exn_v_290, __exn_tags_291) -> if HxRuntime.tags_has __exn_tags_291 "HxParseError" then let e = (Obj.obj __exn_v_290 : HxParseError.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (e.message)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_297 -> raise (HxRuntime.Hx_return __ret_297)
                    | HxRuntime.Hx_exception (__exn_v_298, __exn_tags_299) -> if HxRuntime.tags_has __exn_tags_299 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_298) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has __exn_tags_299 "String" then let _hx = (Obj.obj __exn_v_298 : string) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_298 __exn_tags_299
                    | __exn_300 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_300)) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_300) : string) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_300)) else ());
                  let __assign_301 = !body in (
                    body := __assign_301;
                    __assign_301
                  )
                )
              ) else if HxRuntime.tags_has __exn_tags_291 "String" then let e = (Obj.obj __exn_v_290 : string) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString e) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_292 -> raise (HxRuntime.Hx_return __ret_292)
                    | HxRuntime.Hx_exception (__exn_v_293, __exn_tags_294) -> if HxRuntime.tags_has __exn_tags_294 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_293) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has __exn_tags_294 "String" then let _hx = (Obj.obj __exn_v_293 : string) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_293 __exn_tags_294
                    | __exn_295 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_295)) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_295) : string) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_295)) else ());
                  let __assign_296 = !body in (
                    body := __assign_296;
                    __assign_296
                  )
                )
              ) else HxRuntime.hx_throw_typed __exn_v_290 __exn_tags_291
              | __exn_302 -> if HxRuntime.tags_has ["OcamlExn"] "HxParseError" then let e = (Obj.obj (Obj.repr __exn_302) : HxParseError.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (e.message)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_308 -> raise (HxRuntime.Hx_return __ret_308)
                    | HxRuntime.Hx_exception (__exn_v_309, __exn_tags_310) -> if HxRuntime.tags_has __exn_tags_310 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_309) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has __exn_tags_310 "String" then let _hx = (Obj.obj __exn_v_309 : string) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_309 __exn_tags_310
                    | __exn_311 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_311)) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_311) : string) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_311)) else ());
                  let __assign_312 = !body in (
                    body := __assign_312;
                    __assign_312
                  )
                )
              ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let e = (Obj.obj (Obj.repr __exn_302) : string) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString e) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_303 -> raise (HxRuntime.Hx_return __ret_303)
                    | HxRuntime.Hx_exception (__exn_v_304, __exn_tags_305) -> if HxRuntime.tags_has __exn_tags_305 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_304) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has __exn_tags_305 "String" then let _hx = (Obj.obj __exn_v_304 : string) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_304 __exn_tags_305
                    | __exn_306 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_306)) : Haxe_io_Error.error) in (
                      ignore _hx;
                      ()
                    ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_306) : string) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_306)) else ());
                  let __assign_307 = !body in (
                    body := __assign_307;
                    __assign_307
                  )
                )
              ) else raise (__exn_302));
            let __assign_313 = "" in (
              HxParser.debugBodyLabel := __assign_313;
              __assign_313
            )
          )) else ());
          HxFunctionDecl.create name vis isStatic args returnTypeHint (!body) retStr
        )
      )
    )
  )
)

let decodeFieldPayload = fun payload -> try (
  ignore (if payload == Obj.magic (HxRuntime.hx_null) || HxString.length payload = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let lines = HxString.split payload "\n" in let tempString = ref "" in (
    ignore (if HxArray.length lines > 0 then let __assign_314 = HxArray.get lines 0 in (
      tempString := __assign_314;
      __assign_314
    ) else let __assign_315 = "" in (
      tempString := __assign_315;
      __assign_315
    ));
    ignore (if HxString.length (!tempString) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let tempString1 = ref "" in (
      ignore (if HxArray.length lines > 1 then let __assign_316 = HxArray.get lines 1 in (
        tempString1 := __assign_316;
        __assign_316
      ) else let __assign_317 = "public" in (
        tempString1 := __assign_317;
        __assign_317
      ));
      let tempHxVisibility = ref (Obj.magic ()) in (
        ignore (if HxString.equals (!tempString1) "private" then let __assign_318 = HxVisibility.Private in (
          tempHxVisibility := __assign_318;
          __assign_318
        ) else let __assign_319 = HxVisibility.Public in (
          tempHxVisibility := __assign_319;
          __assign_319
        ));
        let vis = !tempHxVisibility in let tempString2 = ref "" in (
          ignore (if HxArray.length lines > 2 then let __assign_320 = HxArray.get lines 2 in (
            tempString2 := __assign_320;
            __assign_320
          ) else let __assign_321 = "1" in (
            tempString2 := __assign_321;
            __assign_321
          ));
          let isStatic = HxString.equals (!tempString2) "1" in let tempString3 = ref "" in (
            ignore (if HxArray.length lines > 3 then let __assign_322 = HxArray.get lines 3 in (
              tempString3 := __assign_322;
              __assign_322
            ) else let __assign_323 = "" in (
              tempString3 := __assign_323;
              __assign_323
            ));
            let tempString4 = ref "" in (
              ignore (if HxArray.length lines > 4 then let __assign_324 = HxArray.join (HxArray.slice lines 4 (HxArray.length lines)) "\n" (fun x -> x) in (
                tempString4 := __assign_324;
                __assign_324
              ) else let __assign_325 = "" in (
                tempString4 := __assign_325;
                __assign_325
              ));
              let init = ref (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null)))) in (
                ignore (if HxString.length (!tempString4) > 0 then ignore (let __assign_326 = HxEnum.box_if_needed "HxExpr" (Obj.repr (parseReturnExprText (!tempString4))) in (
                  init := __assign_326;
                  __assign_326
                )) else ());
                HxFieldDecl.create (!tempString) vis isStatic (!tempString3) (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (!init)))
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_327 -> Obj.obj __ret_327

let decodeStaticFinalPayload = fun payload -> decodeFieldPayload payload

let parseDecInt = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length s && (let __nullable_405 = HxString.charCodeAt s (!i) in if __nullable_405 == HxRuntime.hx_null then false else Obj.obj __nullable_405 = 32) do ignore (let __old_406 = !i in let __new_407 = HxInt.add __old_406 1 in (
      ignore (i := __new_407);
      __old_406
    )) done);
    ignore (if !i >= HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_408 = c in let __nullable_409 = 48 in if __nullable_408 == HxRuntime.hx_null then false else Obj.obj __nullable_408 < __nullable_409) || (let __nullable_410 = c in let __nullable_411 = 57 in if __nullable_410 == HxRuntime.hx_null then false else Obj.obj __nullable_410 > __nullable_411) then raise (HxRuntime.Hx_break) else ());
        ignore (let __assign_412 = true in (
          saw := __assign_412;
          __assign_412
        ));
        ignore (let __assign_413 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_414 = c in if __nullable_int_414 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_414) 48) in (
          value := __assign_413;
          __assign_413
        ));
        let __old_415 = !i in let __new_416 = HxInt.add __old_415 1 in (
          ignore (i := __new_416);
          __old_415
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let tempResult = ref 0 in (
        ignore (if !saw then let __assign_417 = !value in (
          tempResult := __assign_417;
          __assign_417
        ) else let __assign_418 = -1 in (
          tempResult := __assign_418;
          __assign_418
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_419 -> Obj.obj __ret_419

let unescapePayload = fun s -> let out = StringBuf.create () in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if (let __nullable_420 = c in if __nullable_420 == HxRuntime.hx_null then false else Obj.obj __nullable_420 = 92) && HxInt.add (!i) 1 < HxString.length s then ignore (let n = HxString.charCodeAt s (HxInt.add (!i) 1) in (
      ignore (if n == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_421 = n in if __nullable_int_421 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_421)) else ignore (let __switch_423 = n in if __switch_423 == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_422 = n in if __nullable_int_422 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_422)) else match Obj.obj __switch_423 with
        | 92 -> ignore (StringBuf.addChar out 92)
        | 110 -> ignore (StringBuf.addChar out 10)
        | 114 -> ignore (StringBuf.addChar out 13)
        | 116 -> ignore (StringBuf.addChar out 9)
        | _ -> ignore (StringBuf.addChar out (let __nullable_int_422 = n in if __nullable_int_422 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_422))));
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (StringBuf.addChar out (let __nullable_int_424 = c in if __nullable_int_424 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_424));
    let __old_425 = !i in let __new_426 = HxInt.add __old_425 1 in (
      ignore (i := __new_426);
      __old_425
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  StringBuf.toString out ()
)

let decodeLenPayload = fun s -> try let colon = HxString.indexOf s ":" 0 in (
  ignore (if colon <= 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let len = parseDecInt (HxString.substr s 0 colon) in (
    ignore (if len < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let payload = HxString.substr s (HxInt.add colon 1) (-1) in let raw = HxString.substr payload 0 len in unescapePayload raw
  )
) with
  | HxRuntime.Hx_return __ret_404 -> Obj.obj __ret_404

let splitN = fun s n -> let head = HxArray.create () in let i = ref 0 in let start = ref 0 in (
  ignore (try while HxArray.length head < n && !i <= HxString.length s do try ignore ((
    ignore (if !i = HxString.length s || (let __nullable_427 = HxString.charCodeAt s (!i) in if __nullable_427 == HxRuntime.hx_null then false else Obj.obj __nullable_427 = 32) then ignore ((
      ignore (if !i > !start then ignore (HxArray.push head (HxString.substr s (!start) (HxInt.sub (!i) (!start)))) else ());
      ignore (while !i < HxString.length s && (let __nullable_428 = HxString.charCodeAt s (!i) in if __nullable_428 == HxRuntime.hx_null then false else Obj.obj __nullable_428 = 32) do ignore (let __old_429 = !i in let __new_430 = HxInt.add __old_429 1 in (
        ignore (i := __new_430);
        __old_429
      )) done);
      ignore (let __assign_431 = !i in (
        start := __assign_431;
        __assign_431
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_432 = !i in let __new_433 = HxInt.add __old_432 1 in (
      ignore (i := __new_433);
      __old_432
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (while HxArray.length head < n do ignore (HxArray.push head "") done);
  let tempString = ref "" in (
    ignore (if !start <= HxString.length s then let __assign_434 = HxString.substr s (!start) (-1) in (
      tempString := __assign_434;
      __assign_434
    ) else let __assign_435 = "" in (
      tempString := __assign_435;
      __assign_435
    ));
    ignore (HxArray.push head (!tempString));
    head
  )
)

let throwFromErrLine = fun line -> let parts = splitN line 4 in let tempNumber = ref 0 in (
  ignore (if HxArray.length parts > 1 then let __assign_390 = parseDecInt (HxArray.get parts 1) in (
    tempNumber := __assign_390;
    __assign_390
  ) else let __assign_391 = -1 in (
    tempNumber := __assign_391;
    __assign_391
  ));
  let idx = !tempNumber in let tempNumber1 = ref 0 in (
    ignore (if HxArray.length parts > 2 then let __assign_392 = parseDecInt (HxArray.get parts 2) in (
      tempNumber1 := __assign_392;
      __assign_392
    ) else let __assign_393 = -1 in (
      tempNumber1 := __assign_393;
      __assign_393
    ));
    let ln = !tempNumber1 in let tempNumber2 = ref 0 in (
      ignore (if HxArray.length parts > 3 then let __assign_394 = parseDecInt (HxArray.get parts 3) in (
        tempNumber2 := __assign_394;
        __assign_394
      ) else let __assign_395 = -1 in (
        tempNumber2 := __assign_395;
        __assign_395
      ));
      let col = !tempNumber2 in let tempString = ref "" in (
        ignore (if HxArray.length parts > 4 then let __assign_396 = HxArray.get parts 4 in (
          tempString := __assign_396;
          __assign_396
        ) else let __assign_397 = "" in (
          tempString := __assign_397;
          __assign_397
        ));
        let msg = decodeLenPayload (!tempString) in let tempNumber3 = ref 0 in (
          ignore (if idx < 0 then let __assign_398 = 0 in (
            tempNumber3 := __assign_398;
            __assign_398
          ) else let __assign_399 = idx in (
            tempNumber3 := __assign_399;
            __assign_399
          ));
          let idx0 = !tempNumber3 in let tempNumber4 = ref 0 in (
            ignore (if ln < 0 then let __assign_400 = 0 in (
              tempNumber4 := __assign_400;
              __assign_400
            ) else let __assign_401 = ln in (
              tempNumber4 := __assign_401;
              __assign_401
            ));
            let ln0 = !tempNumber4 in let tempNumber5 = ref 0 in (
              ignore (if col < 0 then let __assign_402 = 0 in (
                tempNumber5 := __assign_402;
                __assign_402
              ) else let __assign_403 = col in (
                tempNumber5 := __assign_403;
                __assign_403
              ));
              let col0 = !tempNumber5 in HxType.hx_throw_typed_rtti (Obj.repr (((((((("Native frontend: " ^ HxString.toStdString msg) ^ " (") ^ string_of_int idx0) ^ ":") ^ string_of_int ln0) ^ ":") ^ string_of_int col0) ^ ")")) ["Dynamic"; "String"]
            )
          )
        )
      )
    )
  )
)

let decodeNativeProtocol = fun encoded -> try let tempArray = ref (Obj.magic ()) in let _this = HxString.split encoded "\n" in (
  ignore (let _g = let __arr_231 = HxArray.create () in __arr_231 in (
    ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
      ignore (let __old_232 = !_g1 in let __new_233 = HxInt.add __old_232 1 in (
        ignore (_g1 := __new_233);
        __new_233
      ));
      if HxString.length v > 0 then ignore (HxArray.push _g v) else ()
    )) done);
    let __assign_234 = _g in (
      tempArray := __assign_234;
      __assign_234
    )
  ));
  ignore (if HxArray.length (!tempArray) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing/invalid protocol header") ["Dynamic"; "String"]) else ());
  let header = HxArray.get (!tempArray) 0 in (
    ignore (if not (HxString.equals header "hxhx_frontend_v=1") && not (HxString.equals header "hxhx_frontend_v=2") then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing/invalid protocol header") ["Dynamic"; "String"]) else ());
    let packagePath = ref "" in let imports = HxArray.create () in let className = ref "Unknown" in let headerOnly = ref false in let hasToplevelMain = ref false in let hasStaticMain = ref false in let methodPayloads = HxArray.create () in let fieldPayloads = HxArray.create () in let staticFinalPayloads = HxArray.create () in let methodBodies = HxMap.create_string () in let functions = HxArray.create () in let fields = HxArray.create () in let sawOk = ref false in (
      ignore (let _g = ref 1 in let _g1 = HxArray.length (!tempArray) in try while !_g < _g1 do try ignore (let i = let __old_235 = !_g in let __new_236 = HxInt.add __old_235 1 in (
        ignore (_g := __new_236);
        __old_235
      ) in let line = HxArray.get (!tempArray) i in (
        ignore (if HxString.equals line "ok" then ignore ((
          ignore (let __assign_237 = true in (
            sawOk := __assign_237;
            __assign_237
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if StringTools.startsWith line "err " then ignore ((
          ignore (throwFromErrLine line);
          raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
        )) else ());
        if StringTools.startsWith line "ast " then ignore ((
          ignore (if StringTools.startsWith line "ast static_main " then ignore ((
            ignore (let __assign_238 = HxString.equals (HxString.substr line (HxString.length "ast static_main ") (-1)) "1" in (
              hasStaticMain := __assign_238;
              __assign_238
            ));
            raise (HxRuntime.Hx_continue)
          )) else ());
          let rest = HxString.substr line (HxString.length "ast ") (-1) in let firstSpace = HxString.indexOf rest " " 0 in (
            ignore (if firstSpace <= 0 then raise (HxRuntime.Hx_continue) else ());
            let key = HxString.substr rest 0 firstSpace in let payload = decodeLenPayload (HxString.substr rest (HxInt.add firstSpace 1) (-1)) in (
              ignore (match key with
                | "class" -> ignore (let __assign_239 = payload in (
                  className := __assign_239;
                  __assign_239
                ))
                | "field" -> ignore (HxArray.push fieldPayloads payload)
                | "header_only" -> ignore (let __assign_240 = HxString.equals payload "1" in (
                  headerOnly := __assign_240;
                  __assign_240
                ))
                | "imports" -> ignore (if HxString.length payload > 0 then ignore (let _g2 = ref 0 in let _g3 = HxString.split payload "|" in while !_g2 < HxArray.length _g3 do ignore (let p = HxArray.get _g3 (!_g2) in (
                  ignore (let __old_241 = !_g2 in let __new_242 = HxInt.add __old_241 1 in (
                    ignore (_g2 := __new_242);
                    __new_242
                  ));
                  if HxString.length p > 0 then ignore (HxArray.push imports p) else ()
                )) done) else ())
                | "method" -> ignore (HxArray.push methodPayloads payload)
                | "method_body" -> ignore (let nl = HxString.indexOf payload "\n" 0 in if nl > 0 then ignore (let name = HxString.substr payload 0 nl in if not (HxMap.exists_string methodBodies name) then ignore (let value = HxString.substr payload (HxInt.add nl 1) (-1) in HxMap.set_string methodBodies name value) else ()) else ())
                | "package" -> ignore (let __assign_243 = payload in (
                  packagePath := __assign_243;
                  __assign_243
                ))
                | "static_final" -> ignore (HxArray.push staticFinalPayloads payload)
                | "toplevel_main" -> ignore (let __assign_244 = HxString.equals payload "1" in (
                  hasToplevelMain := __assign_244;
                  __assign_244
                ))
                | _ -> ignore ());
              raise (HxRuntime.Hx_continue)
            )
          )
        )) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if not (!sawOk) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing terminal 'ok'") ["Dynamic"; "String"]) else ());
      ignore (let _g = ref 0 in while !_g < HxArray.length methodPayloads do ignore (let mp = HxArray.get methodPayloads (!_g) in (
        ignore (let __old_245 = !_g in let __new_246 = HxInt.add __old_245 1 in (
          ignore (_g := __new_246);
          __new_246
        ));
        let tempString = ref "" in (
          ignore (let parts = HxString.split mp "|" in if HxArray.length parts = 0 then let __assign_247 = "" in (
            tempString := __assign_247;
            __assign_247
          ) else let __assign_248 = HxArray.get parts 0 in (
            tempString := __assign_248;
            __assign_248
          ));
          let name = !tempString in let tempMaybeString = ref (Obj.magic ()) in (
            ignore (if HxMap.exists_string methodBodies name then let __assign_249 = HxMap.get_string methodBodies name in (
              tempMaybeString := __assign_249;
              __assign_249
            ) else let __assign_250 = Obj.magic (HxRuntime.hx_null) in (
              tempMaybeString := __assign_250;
              __assign_250
            ));
            HxArray.push functions (decodeMethodPayload mp (!tempMaybeString))
          )
        )
      )) done);
      let seenFields = HxMap.create_string () in (
        ignore (let _g = ref 0 in while !_g < HxArray.length fieldPayloads do ignore (let fp = HxArray.get fieldPayloads (!_g) in (
          ignore (let __old_251 = !_g in let __new_252 = HxInt.add __old_251 1 in (
            ignore (_g := __new_252);
            __new_252
          ));
          let f = decodeFieldPayload fp in if f == Obj.magic (HxRuntime.hx_null) then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (let tempString1 = ref "" in (
            ignore (if f.isStatic then let __assign_253 = "1" in (
              tempString1 := __assign_253;
              __assign_253
            ) else let __assign_254 = "0" in (
              tempString1 := __assign_254;
              __assign_254
            ));
            let key = (HxString.toStdString (f.name) ^ "|") ^ HxString.toStdString (!tempString1) in if HxMap.exists_string seenFields key then ignore (Obj.magic (HxRuntime.hx_null)) else ignore ((
              ignore (HxMap.set_string seenFields key true);
              HxArray.push fields f
            ))
          ))
        )) done);
        ignore (let _g = ref 0 in while !_g < HxArray.length staticFinalPayloads do ignore (let fp = HxArray.get staticFinalPayloads (!_g) in (
          ignore (let __old_255 = !_g in let __new_256 = HxInt.add __old_255 1 in (
            ignore (_g := __new_256);
            __new_256
          ));
          let f = decodeFieldPayload fp in if f == Obj.magic (HxRuntime.hx_null) then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (let tempString2 = ref "" in (
            ignore (if f.isStatic then let __assign_257 = "1" in (
              tempString2 := __assign_257;
              __assign_257
            ) else let __assign_258 = "0" in (
              tempString2 := __assign_258;
              __assign_258
            ));
            let key = (HxString.toStdString (f.name) ^ "|") ^ HxString.toStdString (!tempString2) in if HxMap.exists_string seenFields key then ignore (Obj.magic (HxRuntime.hx_null)) else ignore ((
              ignore (HxMap.set_string seenFields key true);
              HxArray.push fields f
            ))
          ))
        )) done);
        let cls = HxClassDecl.create (!className) (!hasStaticMain) functions fields in HxModuleDecl.create (!packagePath) imports cls (let __arr_259 = HxArray.create () in (
          ignore (HxArray.push __arr_259 cls);
          __arr_259
        )) (!headerOnly) (!hasToplevelMain)
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_260 -> Obj.obj __ret_260

let parseViaNativeHooks = fun source expectedMainClass -> let tempString = ref "" in (
  ignore (if expectedMainClass != Obj.magic (HxRuntime.hx_null) && HxString.length expectedMainClass > 0 then let __assign_50 = HxHxNativeParser.parse_module_decl_with_expected source expectedMainClass in (
    tempString := __assign_50;
    __assign_50
  ) else let __assign_51 = HxHxNativeParser.parse_module_decl source in (
    tempString := __assign_51;
    __assign_51
  ));
  decodeNativeProtocol (!tempString)
)

let parse = fun source filePath -> let expectedMainClass = expectedMainClassFromFile filePath in let tempHxModuleDecl = ref (Obj.magic ()) in let enrichNativeDecl = fun nativeDecl -> try let main = ref (HxModuleDecl.getMainClass nativeDecl) in let mainName = ref (HxClassDecl.getName (!main)) in let enumDeclsAll = scanModuleLocalHelperEnums source (Obj.magic (HxRuntime.hx_null)) in let typedefDeclsAll = scanModuleLocalHelperTypedefs source (Obj.magic (HxRuntime.hx_null)) in let abstractDeclsAll = scanModuleLocalHelperAbstracts source (Obj.magic (HxRuntime.hx_null)) in (
  ignore (if (!mainName == Obj.magic (HxRuntime.hx_null) || HxString.length (!mainName) = 0 || HxString.equals (!mainName) "Unknown") && expectedMainClass != Obj.magic (HxRuntime.hx_null) then ignore (let tryPickMainFrom = fun candidates -> try (
    ignore (if candidates == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
    ignore (let _g = ref 0 in while !_g < HxArray.length candidates do ignore (let c = HxArray.get candidates (!_g) in (
      ignore (let __old_4 = !_g in let __new_5 = HxInt.add __old_4 1 in (
        ignore (_g := __new_5);
        __new_5
      ));
      let nm = HxClassDecl.getName c in if nm != Obj.magic (HxRuntime.hx_null) && HxString.equals nm expectedMainClass then ignore ((
        ignore (let __assign_6 = c in (
          main := __assign_6;
          __assign_6
        ));
        ignore (let __assign_7 = nm in (
          mainName := __assign_7;
          __assign_7
        ));
        raise (HxRuntime.Hx_return (Obj.repr true))
      )) else ()
    )) done);
    false
  ) with
    | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8 in if not (tryPickMainFrom enumDeclsAll) then ignore (if not (tryPickMainFrom typedefDeclsAll) then ignore (tryPickMainFrom abstractDeclsAll) else ()) else ()) else ());
  let existingClasses = HxModuleDecl.getClasses nativeDecl in let existingNames = HxMap.create_string () in (
    ignore (let _g = ref 0 in while !_g < HxArray.length existingClasses do ignore (let c = HxArray.get existingClasses (!_g) in (
      ignore (let __old_9 = !_g in let __new_10 = HxInt.add __old_9 1 in (
        ignore (_g := __new_10);
        __new_10
      ));
      let tempMaybeString = ref (Obj.magic ()) in (
        ignore (if c == Obj.magic (HxRuntime.hx_null) then let __assign_11 = Obj.magic (HxRuntime.hx_null) in (
          tempMaybeString := __assign_11;
          __assign_11
        ) else let __assign_12 = HxClassDecl.getName c in (
          tempMaybeString := __assign_12;
          __assign_12
        ));
        let nm = !tempMaybeString in if nm != Obj.magic (HxRuntime.hx_null) && HxString.length nm > 0 then ignore (HxMap.set_string existingNames nm true) else ()
      )
    )) done);
    let isMissingAndNotMain = fun c -> let tempMaybeString1 = ref (Obj.magic ()) in (
      ignore (if c == Obj.magic (HxRuntime.hx_null) then let __assign_13 = Obj.magic (HxRuntime.hx_null) in (
        tempMaybeString1 := __assign_13;
        __assign_13
      ) else let __assign_14 = HxClassDecl.getName c in (
        tempMaybeString1 := __assign_14;
        __assign_14
      ));
      let nm = !tempMaybeString1 in nm != Obj.magic (HxRuntime.hx_null) && HxString.length nm > 0 && not (HxString.equals nm (!mainName)) && not (HxMap.exists_string existingNames nm)
    ) in let extras = HxArray.create () in (
      ignore (let _g = ref 0 in let _g1 = scanModuleLocalHelperClasses source (!mainName) in while !_g < HxArray.length _g1 do ignore (let c = HxArray.get _g1 (!_g) in (
        ignore (let __old_15 = !_g in let __new_16 = HxInt.add __old_15 1 in (
          ignore (_g := __new_16);
          __new_16
        ));
        if isMissingAndNotMain c then ignore (HxArray.push extras c) else ()
      )) done);
      let enumDecls = HxArray.create () in (
        ignore (let _g = ref 0 in while !_g < HxArray.length enumDeclsAll do ignore (let c = HxArray.get enumDeclsAll (!_g) in (
          ignore (let __old_17 = !_g in let __new_18 = HxInt.add __old_17 1 in (
            ignore (_g := __new_18);
            __new_18
          ));
          if isMissingAndNotMain c then ignore (HxArray.push enumDecls c) else ()
        )) done);
        let typedefDecls = HxArray.create () in (
          ignore (let _g = ref 0 in while !_g < HxArray.length typedefDeclsAll do ignore (let c = HxArray.get typedefDeclsAll (!_g) in (
            ignore (let __old_19 = !_g in let __new_20 = HxInt.add __old_19 1 in (
              ignore (_g := __new_20);
              __new_20
            ));
            if isMissingAndNotMain c then ignore (HxArray.push typedefDecls c) else ()
          )) done);
          let abstractDecls = HxArray.create () in (
            ignore (let _g = ref 0 in while !_g < HxArray.length abstractDeclsAll do ignore (let c = HxArray.get abstractDeclsAll (!_g) in (
              ignore (let __old_21 = !_g in let __new_22 = HxInt.add __old_21 1 in (
                ignore (_g := __new_22);
                __new_22
              ));
              if isMissingAndNotMain c then ignore (HxArray.push abstractDecls c) else ()
            )) done);
            ignore (if HxArray.length extras = 0 && HxArray.length enumDecls = 0 && HxArray.length typedefDecls = 0 && HxArray.length abstractDecls = 0 && Obj.repr (!main) == Obj.repr (HxModuleDecl.getMainClass nativeDecl) then raise (HxRuntime.Hx_return (Obj.repr nativeDecl)) else ());
            let classes = HxArray.create () in let seen = HxMap.create_string () in let pushUnique = fun c -> try (
              ignore (if c == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
              let nm = HxClassDecl.getName c in (
                ignore (if nm != Obj.magic (HxRuntime.hx_null) && HxString.length nm > 0 && HxMap.exists_string seen nm then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
                ignore (HxArray.push classes c);
                if nm != Obj.magic (HxRuntime.hx_null) && HxString.length nm > 0 then ignore (HxMap.set_string seen nm true) else ()
              )
            ) with
              | HxRuntime.Hx_return __ret_23 -> Obj.obj __ret_23 in (
              ignore (pushUnique (!main));
              ignore (let _g = ref 0 in while !_g < HxArray.length existingClasses do ignore (let c = HxArray.get existingClasses (!_g) in (
                ignore (let __old_24 = !_g in let __new_25 = HxInt.add __old_24 1 in (
                  ignore (_g := __new_25);
                  __new_25
                ));
                pushUnique c
              )) done);
              ignore (let _g = ref 0 in while !_g < HxArray.length extras do ignore (let c = HxArray.get extras (!_g) in (
                ignore (let __old_26 = !_g in let __new_27 = HxInt.add __old_26 1 in (
                  ignore (_g := __new_27);
                  __new_27
                ));
                pushUnique c
              )) done);
              ignore (let _g = ref 0 in while !_g < HxArray.length enumDecls do ignore (let c = HxArray.get enumDecls (!_g) in (
                ignore (let __old_28 = !_g in let __new_29 = HxInt.add __old_28 1 in (
                  ignore (_g := __new_29);
                  __new_29
                ));
                pushUnique c
              )) done);
              ignore (let _g = ref 0 in while !_g < HxArray.length typedefDecls do ignore (let c = HxArray.get typedefDecls (!_g) in (
                ignore (let __old_30 = !_g in let __new_31 = HxInt.add __old_30 1 in (
                  ignore (_g := __new_31);
                  __new_31
                ));
                pushUnique c
              )) done);
              ignore (let _g = ref 0 in while !_g < HxArray.length abstractDecls do ignore (let c = HxArray.get abstractDecls (!_g) in (
                ignore (let __old_32 = !_g in let __new_33 = HxInt.add __old_32 1 in (
                  ignore (_g := __new_33);
                  __new_33
                ));
                pushUnique c
              )) done);
              HxModuleDecl.create (HxModuleDecl.getPackagePath nativeDecl) (HxModuleDecl.getImports nativeDecl) (!main) classes (HxModuleDecl.getHeaderOnly nativeDecl) (HxModuleDecl.getHasToplevelMain nativeDecl)
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_34 -> Obj.obj __ret_34 in let v = HxSys.getEnv "HIH_FORCE_HX_PARSER" in (
  ignore (if HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes" then let __assign_35 = enrichNativeDecl (HxParser.parseModule (HxParser.create source) expectedMainClass) in (
    tempHxModuleDecl := __assign_35;
    __assign_35
  ) else let fallbackAfterNativeFailure = fun nativeError -> try let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
    ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti (Obj.repr nativeError) ["Dynamic"; "String"]) else ());
    try raise (HxRuntime.Hx_return (Obj.repr (enrichNativeDecl (HxParser.parseModule (HxParser.create source) expectedMainClass)))) with
      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
      | HxRuntime.Hx_return __ret_36 -> raise (HxRuntime.Hx_return __ret_36)
      | HxRuntime.Hx_exception (__exn_v_37, __exn_tags_38) -> if HxRuntime.tags_has __exn_tags_38 "HxParseError" then let _hx = (Obj.obj __exn_v_37 : HxParseError.t) in (
        ignore _hx;
        HxType.hx_throw_typed_rtti (Obj.repr nativeError) ["Dynamic"; "String"]
      ) else if HxRuntime.tags_has __exn_tags_38 "String" then let _hx = (Obj.obj __exn_v_37 : string) in (
        ignore _hx;
        HxType.hx_throw_typed_rtti (Obj.repr nativeError) ["Dynamic"; "String"]
      ) else HxRuntime.hx_throw_typed __exn_v_37 __exn_tags_38
      | __exn_39 -> if HxRuntime.tags_has ["OcamlExn"] "HxParseError" then let _hx = (Obj.obj (Obj.repr __exn_39) : HxParseError.t) in (
        ignore _hx;
        HxType.hx_throw_typed_rtti (Obj.repr nativeError) ["Dynamic"; "String"]
      ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_39) : string) in (
        ignore _hx;
        HxType.hx_throw_typed_rtti (Obj.repr nativeError) ["Dynamic"; "String"]
      ) else raise (__exn_39)
  ) with
    | HxRuntime.Hx_return __ret_40 -> Obj.obj __ret_40 in try let __assign_41 = enrichNativeDecl (parseViaNativeHooks source expectedMainClass) in (
    tempHxModuleDecl := __assign_41;
    __assign_41
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_42 -> raise (HxRuntime.Hx_return __ret_42)
    | HxRuntime.Hx_exception (__exn_v_43, __exn_tags_44) -> if HxRuntime.tags_has __exn_tags_44 "String" then let eNative = (Obj.obj __exn_v_43 : string) in (
      ignore eNative;
      let __assign_45 = fallbackAfterNativeFailure eNative in (
        tempHxModuleDecl := __assign_45;
        __assign_45
      )
    ) else HxRuntime.hx_throw_typed __exn_v_43 __exn_tags_44
    | __exn_46 -> if HxRuntime.tags_has ["OcamlExn"] "String" then let eNative = (Obj.obj (Obj.repr __exn_46) : string) in (
      ignore eNative;
      let __assign_47 = fallbackAfterNativeFailure eNative in (
        tempHxModuleDecl := __assign_47;
        __assign_47
      )
    ) else raise (__exn_46));
  let decl = !tempHxModuleDecl in let tempMaybeString2 = ref (Obj.magic ()) in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_48 = "<memory>" in (
      tempMaybeString2 := __assign_48;
      __assign_48
    ) else let __assign_49 = filePath in (
      tempMaybeString2 := __assign_49;
      __assign_49
    ));
    let path = !tempMaybeString2 in ParsedModule.create source decl path
  )
)
# 1 "ParserStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ParserStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ParserStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ParserStage" } : t)

let expectedMainClassFromFile = fun filePath -> try (
  ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let name = Haxe_io_Path.withoutDirectory filePath in let dot = HxString.lastIndexOf name "." (HxString.length name) in let tempResult = ref (Obj.magic ()) in (
    ignore (if dot <= 0 then let __assign_1 = name in (
      tempResult := __assign_1;
      __assign_1
    ) else let __assign_2 = HxString.substr name 0 dot in (
      tempResult := __assign_2;
      __assign_2
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let parseReturnExprText = fun raw -> try let s = StringTools.trim raw in (
  ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EUnsupported "<empty-return-expr>"))) else ());
  ignore (if HxString.equals s "null" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.ENull))) else ());
  ignore (if HxString.equals s "true" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool true))) else ());
  ignore (if HxString.equals s "false" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EBool false))) else ());
  ignore (if HxString.length s >= 2 && StringTools.startsWith s "\"" && StringTools.endsWith s "\"" then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EString (HxString.substr s 1 (HxInt.sub (HxString.length s) 2))))) else ());
  let i = ref 0 in let sign = ref 1 in (
    ignore (if HxString.length s > 0 && (let __nullable_80 = HxString.charCodeAt s 0 in if __nullable_80 == HxRuntime.hx_null then false else Obj.obj __nullable_80 = 45) then ignore ((
      ignore (let __assign_81 = -1 in (
        sign := __assign_81;
        __assign_81
      ));
      let __assign_82 = 1 in (
        i := __assign_82;
        __assign_82
      )
    )) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_83 = c in let __nullable_84 = 48 in if __nullable_83 == HxRuntime.hx_null then false else Obj.obj __nullable_83 < __nullable_84) || (let __nullable_85 = c in let __nullable_86 = 57 in if __nullable_85 == HxRuntime.hx_null then false else Obj.obj __nullable_85 > __nullable_86) then ignore ((
          ignore (let __assign_87 = false in (
            saw := __assign_87;
            __assign_87
          ));
          raise (HxRuntime.Hx_break)
        )) else ());
        ignore (let __assign_88 = true in (
          saw := __assign_88;
          __assign_88
        ));
        ignore (let __assign_89 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_90 = c in if __nullable_int_90 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_90) 48) in (
          value := __assign_89;
          __assign_89
        ));
        let __old_91 = !i in let __new_92 = HxInt.add __old_91 1 in (
          ignore (i := __new_92);
          __old_91
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if !saw && !i = HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EInt (HxInt.mul (!sign) (!value))))) else ());
      ignore (if HxString.indexOf s "." 0 <> -1 then ignore (let f = Std.parseFloat s in if not (Math.isNaN f) then raise (HxRuntime.Hx_return (Obj.repr (HxExpr.EFloat f))) else ()) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (try let __assign_93 = HxParser.parseExprText s in (
          tempResult := __assign_93;
          __assign_93
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_94 -> raise (HxRuntime.Hx_return __ret_94)
          | HxRuntime.Hx_exception (__exn_v_95, __exn_tags_96) -> if true then let _hx = (__exn_v_95 : Obj.t) in (
            ignore _hx;
            let __assign_97 = HxExpr.EUnsupported s in (
              tempResult := __assign_97;
              __assign_97
            )
          ) else HxRuntime.hx_throw_typed __exn_v_95 __exn_tags_96
          | __exn_98 -> if true then let _hx = (Obj.repr __exn_98 : Obj.t) in (
            ignore _hx;
            let __assign_99 = HxExpr.EUnsupported s in (
              tempResult := __assign_99;
              __assign_99
            )
          ) else raise (__exn_98));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_100 -> Obj.obj __ret_100

let decodeMethodPayload = fun payload methodBodySrc -> let parts = HxString.split payload "|" in (
  ignore (while HxArray.length parts < 9 do ignore (HxArray.push parts "") done);
  let name = HxArray.get parts 0 in let tempHxVisibility = ref (Obj.magic ()) in (
    ignore (if HxString.equals (HxArray.get parts 1) "private" then let __assign_45 = HxVisibility.Private in (
      tempHxVisibility := __assign_45;
      __assign_45
    ) else let __assign_46 = HxVisibility.Public in (
      tempHxVisibility := __assign_46;
      __assign_46
    ));
    let vis = !tempHxVisibility in let isStatic = HxString.equals (HxArray.get parts 2) "1" in let argTypes = HxMap.create_string () in let argTypesPayload = HxArray.get parts 7 in (
      ignore (if HxString.length argTypesPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argTypesPayload "," in try while !_g < HxArray.length _g1 do try ignore (let entry = HxArray.get _g1 (!_g) in (
        ignore (let __old_47 = !_g in let __new_48 = HxInt.add __old_47 1 in (
          ignore (_g := __new_48);
          __new_48
        ));
        ignore (if HxString.length entry = 0 then raise (HxRuntime.Hx_continue) else ());
        let idx = HxString.indexOf entry ":" 0 in (
          ignore (if idx <= 0 then raise (HxRuntime.Hx_continue) else ());
          let argName = HxString.substr entry 0 idx in let ty = HxString.substr entry (HxInt.add idx 1) (-1) in HxMap.set_string argTypes argName ty
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      let args = HxArray.create () in let argsPayload = HxArray.get parts 3 in (
        ignore (if HxString.length argsPayload > 0 then ignore (let _g = ref 0 in let _g1 = HxString.split argsPayload "," in try while !_g < HxArray.length _g1 do try ignore (let a = HxArray.get _g1 (!_g) in (
          ignore (let __old_49 = !_g in let __new_50 = HxInt.add __old_49 1 in (
            ignore (_g := __new_50);
            __new_50
          ));
          ignore (if HxString.length a = 0 then raise (HxRuntime.Hx_continue) else ());
          let tempMaybeString = ref (Obj.magic ()) in (
            ignore (if HxMap.exists_string argTypes a then let __assign_51 = HxMap.get_string argTypes a in (
              tempMaybeString := __assign_51;
              __assign_51
            ) else let __assign_52 = "" in (
              tempMaybeString := __assign_52;
              __assign_52
            ));
            let ty = !tempMaybeString in HxArray.push args (HxFunctionArg.create a ty (HxDefaultValue.NoDefault) (Obj.magic (HxRuntime.hx_null)))
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ()) else ());
        let returnTypeHint = HxArray.get parts 4 in let retStr = HxArray.get parts 5 in let retId = HxArray.get parts 6 in let retExpr = HxArray.get parts 8 in let body = ref (HxArray.create ()) in let pos = HxPos.unknown () in (
          ignore (if HxString.length retExpr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (parseReturnExprText retExpr, pos))) else ignore (if HxString.length retStr > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EString retStr, pos))) else ignore (if HxString.length retId > 0 then ignore (HxArray.push (!body) (HxStmt.SReturn (HxExpr.EIdent retId, pos))) else ())));
          ignore (if methodBodySrc != Obj.magic (HxRuntime.hx_null) && HxString.length methodBodySrc > 0 then ignore ((
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_HAVE") "1" then ignore (try print_endline ((("body_parse_have=" ^ HxString.toStdString name) ^ " len=") ^ string_of_int (HxString.length methodBodySrc)) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_53 -> raise (HxRuntime.Hx_return __ret_53)
              | HxRuntime.Hx_exception (__exn_v_54, __exn_tags_55) -> if true then let _hx = (__exn_v_54 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_54 __exn_tags_55
              | __exn_56 -> if true then let _hx = (Obj.repr __exn_56 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_56)) else ());
            ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_SRC") "1" then ignore (try let oneLine = HxArray.join (HxString.split methodBodySrc "\n") "\\n" (fun x -> x) in let max = 300 in let tempString = ref "" in (
              ignore (if HxString.length oneLine > max then let __assign_57 = HxString.toStdString (HxString.substr oneLine 0 max) ^ "..." in (
                tempString := __assign_57;
                __assign_57
              ) else let __assign_58 = oneLine in (
                tempString := __assign_58;
                __assign_58
              ));
              let shown = !tempString in print_endline ((("body_parse_src=" ^ HxString.toStdString name) ^ " ") ^ HxString.toStdString shown)
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_59 -> raise (HxRuntime.Hx_return __ret_59)
              | HxRuntime.Hx_exception (__exn_v_60, __exn_tags_61) -> if true then let _hx = (__exn_v_60 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_60 __exn_tags_61
              | __exn_62 -> if true then let _hx = (Obj.repr __exn_62 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_62)) else ());
            ignore (let __assign_63 = name in (
              HxParser.debugBodyLabel := __assign_63;
              __assign_63
            ));
            ignore (try let __assign_64 = HxParser.parseFunctionBodyText methodBodySrc in (
              body := __assign_64;
              __assign_64
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_65 -> raise (HxRuntime.Hx_return __ret_65)
              | HxRuntime.Hx_exception (__exn_v_66, __exn_tags_67) -> if true then let e = (__exn_v_66 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_68 -> raise (HxRuntime.Hx_return __ret_68)
                    | HxRuntime.Hx_exception (__exn_v_69, __exn_tags_70) -> if true then let _hx = (__exn_v_69 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_69 __exn_tags_70
                    | __exn_71 -> if true then let _hx = (Obj.repr __exn_71 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_71)) else ());
                  let __assign_72 = !body in (
                    body := __assign_72;
                    __assign_72
                  )
                )
              ) else HxRuntime.hx_throw_typed __exn_v_66 __exn_tags_67
              | __exn_73 -> if true then let e = (Obj.repr __exn_73 : Obj.t) in (
                ignore e;
                (
                  ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_BODY_PARSE_FAIL") "1" then ignore (try print_endline ((("body_parse_fail=" ^ HxString.toStdString name) ^ " err=") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)) with
                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                    | HxRuntime.Hx_return __ret_74 -> raise (HxRuntime.Hx_return __ret_74)
                    | HxRuntime.Hx_exception (__exn_v_75, __exn_tags_76) -> if true then let _hx = (__exn_v_75 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else HxRuntime.hx_throw_typed __exn_v_75 __exn_tags_76
                    | __exn_77 -> if true then let _hx = (Obj.repr __exn_77 : Obj.t) in (
                      ignore _hx;
                      ()
                    ) else raise (__exn_77)) else ());
                  let __assign_78 = !body in (
                    body := __assign_78;
                    __assign_78
                  )
                )
              ) else raise (__exn_73));
            let __assign_79 = "" in (
              HxParser.debugBodyLabel := __assign_79;
              __assign_79
            )
          )) else ());
          HxFunctionDecl.create name vis isStatic args returnTypeHint (!body) retStr
        )
      )
    )
  )
)

let parseDecInt = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let i = ref 0 in (
    ignore (while !i < HxString.length s && (let __nullable_116 = HxString.charCodeAt s (!i) in if __nullable_116 == HxRuntime.hx_null then false else Obj.obj __nullable_116 = 32) do ignore (let __old_117 = !i in let __new_118 = HxInt.add __old_117 1 in (
      ignore (i := __new_118);
      __old_117
    )) done);
    ignore (if !i >= HxString.length s then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let value = ref 0 in let saw = ref false in (
      ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
        ignore (if (let __nullable_119 = c in let __nullable_120 = 48 in if __nullable_119 == HxRuntime.hx_null then false else Obj.obj __nullable_119 < __nullable_120) || (let __nullable_121 = c in let __nullable_122 = 57 in if __nullable_121 == HxRuntime.hx_null then false else Obj.obj __nullable_121 > __nullable_122) then raise (HxRuntime.Hx_break) else ());
        ignore (let __assign_123 = true in (
          saw := __assign_123;
          __assign_123
        ));
        ignore (let __assign_124 = HxInt.add (HxInt.mul (!value) 10) (HxInt.sub (let __nullable_int_125 = c in if __nullable_int_125 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_125) 48) in (
          value := __assign_124;
          __assign_124
        ));
        let __old_126 = !i in let __new_127 = HxInt.add __old_126 1 in (
          ignore (i := __new_127);
          __old_126
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let tempResult = ref 0 in (
        ignore (if !saw then let __assign_128 = !value in (
          tempResult := __assign_128;
          __assign_128
        ) else let __assign_129 = -1 in (
          tempResult := __assign_129;
          __assign_129
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_130 -> Obj.obj __ret_130

let unescapePayload = fun s -> let out = StringBuf.create () in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if (let __nullable_131 = c in if __nullable_131 == HxRuntime.hx_null then false else Obj.obj __nullable_131 = 92) && HxInt.add (!i) 1 < HxString.length s then ignore (let n = HxString.charCodeAt s (HxInt.add (!i) 1) in (
      ignore (if n == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_132 = n in if __nullable_int_132 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_132)) else ignore (let __switch_134 = n in if __switch_134 == HxRuntime.hx_null then ignore (StringBuf.addChar out (let __nullable_int_133 = n in if __nullable_int_133 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_133)) else match Obj.obj __switch_134 with
        | 92 -> ignore (StringBuf.addChar out 92)
        | 110 -> ignore (StringBuf.addChar out 10)
        | 114 -> ignore (StringBuf.addChar out 13)
        | 116 -> ignore (StringBuf.addChar out 9)
        | _ -> ignore (StringBuf.addChar out (let __nullable_int_133 = n in if __nullable_int_133 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_133))));
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (StringBuf.addChar out (let __nullable_int_135 = c in if __nullable_int_135 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_135));
    let __old_136 = !i in let __new_137 = HxInt.add __old_136 1 in (
      ignore (i := __new_137);
      __old_136
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  StringBuf.toString out ()
)

let decodeLenPayload = fun s -> try let colon = HxString.indexOf s ":" 0 in (
  ignore (if colon <= 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let len = parseDecInt (HxString.substr s 0 colon) in (
    ignore (if len < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let payload = HxString.substr s (HxInt.add colon 1) (-1) in let raw = HxString.substr payload 0 len in unescapePayload raw
  )
) with
  | HxRuntime.Hx_return __ret_115 -> Obj.obj __ret_115

let splitN = fun s n -> let head = HxArray.create () in let i = ref 0 in let start = ref 0 in (
  ignore (try while HxArray.length head < n && !i <= HxString.length s do try ignore ((
    ignore (if !i = HxString.length s || (let __nullable_138 = HxString.charCodeAt s (!i) in if __nullable_138 == HxRuntime.hx_null then false else Obj.obj __nullable_138 = 32) then ignore ((
      ignore (if !i > !start then ignore (HxArray.push head (HxString.substr s (!start) (HxInt.sub (!i) (!start)))) else ());
      ignore (while !i < HxString.length s && (let __nullable_139 = HxString.charCodeAt s (!i) in if __nullable_139 == HxRuntime.hx_null then false else Obj.obj __nullable_139 = 32) do ignore (let __old_140 = !i in let __new_141 = HxInt.add __old_140 1 in (
        ignore (i := __new_141);
        __old_140
      )) done);
      ignore (let __assign_142 = !i in (
        start := __assign_142;
        __assign_142
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_143 = !i in let __new_144 = HxInt.add __old_143 1 in (
      ignore (i := __new_144);
      __old_143
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (while HxArray.length head < n do ignore (HxArray.push head "") done);
  let tempString = ref "" in (
    ignore (if !start <= HxString.length s then let __assign_145 = HxString.substr s (!start) (-1) in (
      tempString := __assign_145;
      __assign_145
    ) else let __assign_146 = "" in (
      tempString := __assign_146;
      __assign_146
    ));
    ignore (HxArray.push head (!tempString));
    head
  )
)

let throwFromErrLine = fun line -> let parts = splitN line 4 in let tempNumber = ref 0 in (
  ignore (if HxArray.length parts > 1 then let __assign_101 = parseDecInt (HxArray.get parts 1) in (
    tempNumber := __assign_101;
    __assign_101
  ) else let __assign_102 = -1 in (
    tempNumber := __assign_102;
    __assign_102
  ));
  let idx = !tempNumber in let tempNumber1 = ref 0 in (
    ignore (if HxArray.length parts > 2 then let __assign_103 = parseDecInt (HxArray.get parts 2) in (
      tempNumber1 := __assign_103;
      __assign_103
    ) else let __assign_104 = -1 in (
      tempNumber1 := __assign_104;
      __assign_104
    ));
    let ln = !tempNumber1 in let tempNumber2 = ref 0 in (
      ignore (if HxArray.length parts > 3 then let __assign_105 = parseDecInt (HxArray.get parts 3) in (
        tempNumber2 := __assign_105;
        __assign_105
      ) else let __assign_106 = -1 in (
        tempNumber2 := __assign_106;
        __assign_106
      ));
      let col = !tempNumber2 in let tempString = ref "" in (
        ignore (if HxArray.length parts > 4 then let __assign_107 = HxArray.get parts 4 in (
          tempString := __assign_107;
          __assign_107
        ) else let __assign_108 = "" in (
          tempString := __assign_108;
          __assign_108
        ));
        let msg = decodeLenPayload (!tempString) in let tempNumber3 = ref 0 in (
          ignore (if idx < 0 then let __assign_109 = 0 in (
            tempNumber3 := __assign_109;
            __assign_109
          ) else let __assign_110 = idx in (
            tempNumber3 := __assign_110;
            __assign_110
          ));
          let idx0 = !tempNumber3 in let tempNumber4 = ref 0 in (
            ignore (if ln < 0 then let __assign_111 = 0 in (
              tempNumber4 := __assign_111;
              __assign_111
            ) else let __assign_112 = ln in (
              tempNumber4 := __assign_112;
              __assign_112
            ));
            let ln0 = !tempNumber4 in let tempNumber5 = ref 0 in (
              ignore (if col < 0 then let __assign_113 = 0 in (
                tempNumber5 := __assign_113;
                __assign_113
              ) else let __assign_114 = col in (
                tempNumber5 := __assign_114;
                __assign_114
              ));
              let col0 = !tempNumber5 in HxType.hx_throw_typed_rtti (Obj.repr (((((((("Native frontend: " ^ HxString.toStdString msg) ^ " (") ^ string_of_int idx0) ^ ":") ^ string_of_int ln0) ^ ":") ^ string_of_int col0) ^ ")")) ["Dynamic"; "String"]
            )
          )
        )
      )
    )
  )
)

let decodeNativeProtocol = fun encoded -> try let tempArray = ref (Obj.magic ()) in let _this = HxString.split encoded "\n" in (
  ignore (let _g = let __arr_24 = HxArray.create () in __arr_24 in (
    ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
      ignore (let __old_25 = !_g1 in let __new_26 = HxInt.add __old_25 1 in (
        ignore (_g1 := __new_26);
        __new_26
      ));
      if HxString.length v > 0 then ignore (HxArray.push _g v) else ()
    )) done);
    let __assign_27 = _g in (
      tempArray := __assign_27;
      __assign_27
    )
  ));
  ignore (if HxArray.length (!tempArray) = 0 || not (HxString.equals (HxArray.get (!tempArray) 0) "hxhx_frontend_v=1") then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing/invalid protocol header") ["Dynamic"; "String"]) else ());
  let packagePath = ref "" in let imports = HxArray.create () in let className = ref "Unknown" in let headerOnly = ref false in let hasToplevelMain = ref false in let hasStaticMain = ref false in let methodPayloads = HxArray.create () in let methodBodies = HxMap.create_string () in let functions = HxArray.create () in let sawOk = ref false in (
    ignore (let _g = ref 1 in let _g1 = HxArray.length (!tempArray) in try while !_g < _g1 do try ignore (let i = let __old_28 = !_g in let __new_29 = HxInt.add __old_28 1 in (
      ignore (_g := __new_29);
      __old_28
    ) in let line = HxArray.get (!tempArray) i in (
      ignore (if HxString.equals line "ok" then ignore ((
        ignore (let __assign_30 = true in (
          sawOk := __assign_30;
          __assign_30
        ));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if StringTools.startsWith line "err " then ignore ((
        ignore (throwFromErrLine line);
        raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
      )) else ());
      if StringTools.startsWith line "ast " then ignore ((
        ignore (if StringTools.startsWith line "ast static_main " then ignore ((
          ignore (let __assign_31 = HxString.equals (HxString.substr line (HxString.length "ast static_main ") (-1)) "1" in (
            hasStaticMain := __assign_31;
            __assign_31
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        let rest = HxString.substr line (HxString.length "ast ") (-1) in let firstSpace = HxString.indexOf rest " " 0 in (
          ignore (if firstSpace <= 0 then raise (HxRuntime.Hx_continue) else ());
          let key = HxString.substr rest 0 firstSpace in let payload = decodeLenPayload (HxString.substr rest (HxInt.add firstSpace 1) (-1)) in (
            ignore (match key with
              | "class" -> ignore (let __assign_32 = payload in (
                className := __assign_32;
                __assign_32
              ))
              | "header_only" -> ignore (let __assign_33 = HxString.equals payload "1" in (
                headerOnly := __assign_33;
                __assign_33
              ))
              | "imports" -> ignore (if HxString.length payload > 0 then ignore (let _g2 = ref 0 in let _g3 = HxString.split payload "|" in while !_g2 < HxArray.length _g3 do ignore (let p = HxArray.get _g3 (!_g2) in (
                ignore (let __old_34 = !_g2 in let __new_35 = HxInt.add __old_34 1 in (
                  ignore (_g2 := __new_35);
                  __new_35
                ));
                if HxString.length p > 0 then ignore (HxArray.push imports p) else ()
              )) done) else ())
              | "method" -> ignore (HxArray.push methodPayloads payload)
              | "method_body" -> ignore (let nl = HxString.indexOf payload "\n" 0 in if nl > 0 then ignore (let name = HxString.substr payload 0 nl in if not (HxMap.exists_string methodBodies name) then ignore (let value = HxString.substr payload (HxInt.add nl 1) (-1) in HxMap.set_string methodBodies name value) else ()) else ())
              | "package" -> ignore (let __assign_36 = payload in (
                packagePath := __assign_36;
                __assign_36
              ))
              | "toplevel_main" -> ignore (let __assign_37 = HxString.equals payload "1" in (
                hasToplevelMain := __assign_37;
                __assign_37
              ))
              | _ -> ignore ());
            raise (HxRuntime.Hx_continue)
          )
        )
      )) else ()
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if not (!sawOk) then ignore (HxType.hx_throw_typed_rtti (Obj.repr "Native frontend: missing terminal 'ok'") ["Dynamic"; "String"]) else ());
    ignore (let _g = ref 0 in while !_g < HxArray.length methodPayloads do ignore (let mp = HxArray.get methodPayloads (!_g) in (
      ignore (let __old_38 = !_g in let __new_39 = HxInt.add __old_38 1 in (
        ignore (_g := __new_39);
        __new_39
      ));
      let tempString = ref "" in (
        ignore (let parts = HxString.split mp "|" in if HxArray.length parts = 0 then let __assign_40 = "" in (
          tempString := __assign_40;
          __assign_40
        ) else let __assign_41 = HxArray.get parts 0 in (
          tempString := __assign_41;
          __assign_41
        ));
        let name = !tempString in let tempMaybeString = ref (Obj.magic ()) in (
          ignore (if HxMap.exists_string methodBodies name then let __assign_42 = HxMap.get_string methodBodies name in (
            tempMaybeString := __assign_42;
            __assign_42
          ) else let __assign_43 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_43;
            __assign_43
          ));
          HxArray.push functions (decodeMethodPayload mp (!tempMaybeString))
        )
      )
    )) done);
    HxModuleDecl.create (!packagePath) imports (HxClassDecl.create (!className) (!hasStaticMain) functions (Obj.magic (HxRuntime.hx_null))) (!headerOnly) (!hasToplevelMain)
  )
) with
  | HxRuntime.Hx_return __ret_44 -> Obj.obj __ret_44

let parseViaNativeHooks = fun source expectedMainClass -> let tempString = ref "" in (
  ignore (if expectedMainClass != Obj.magic (HxRuntime.hx_null) && HxString.length expectedMainClass > 0 then let __assign_22 = HxHxNativeParser.parse_module_decl_with_expected source expectedMainClass in (
    tempString := __assign_22;
    __assign_22
  ) else let __assign_23 = HxHxNativeParser.parse_module_decl source in (
    tempString := __assign_23;
    __assign_23
  ));
  decodeNativeProtocol (!tempString)
)

let parse = fun source filePath -> let expectedMainClass = expectedMainClassFromFile filePath in let tempHxModuleDecl = ref (Obj.magic ()) in let v = HxSys.getEnv "HIH_FORCE_HX_PARSER" in (
  ignore (if HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes" then let __assign_4 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
    tempHxModuleDecl := __assign_4;
    __assign_4
  ) else try let __assign_5 = parseViaNativeHooks source expectedMainClass in (
    tempHxModuleDecl := __assign_5;
    __assign_5
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_6 -> raise (HxRuntime.Hx_return __ret_6)
    | HxRuntime.Hx_exception (__exn_v_7, __exn_tags_8) -> if true then let eNative = (__exn_v_7 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_9 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_9;
          __assign_9
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_10 -> raise (HxRuntime.Hx_return __ret_10)
          | HxRuntime.Hx_exception (__exn_v_11, __exn_tags_12) -> if true then let _hx = (__exn_v_11 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_11 __exn_tags_12
          | __exn_13 -> if true then let _hx = (Obj.repr __exn_13 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_13)
      )
    ) else HxRuntime.hx_throw_typed __exn_v_7 __exn_tags_8
    | __exn_14 -> if true then let eNative = (Obj.repr __exn_14 : Obj.t) in (
      ignore eNative;
      let strict = HxSys.getEnv "HIH_NATIVE_PARSER_STRICT" in (
        ignore (if HxString.equals strict "1" || HxString.equals strict "true" || HxString.equals strict "yes" then ignore (HxType.hx_throw_typed_rtti eNative ["Dynamic"]) else ());
        try let __assign_15 = HxParser.parseModule (HxParser.create source) expectedMainClass in (
          tempHxModuleDecl := __assign_15;
          __assign_15
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_16 -> raise (HxRuntime.Hx_return __ret_16)
          | HxRuntime.Hx_exception (__exn_v_17, __exn_tags_18) -> if true then let _hx = (__exn_v_17 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else HxRuntime.hx_throw_typed __exn_v_17 __exn_tags_18
          | __exn_19 -> if true then let _hx = (Obj.repr __exn_19 : Obj.t) in (
            ignore _hx;
            HxType.hx_throw_typed_rtti eNative ["Dynamic"]
          ) else raise (__exn_19)
      )
    ) else raise (__exn_14));
  let decl = !tempHxModuleDecl in let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_20 = "<memory>" in (
      tempMaybeString := __assign_20;
      __assign_20
    ) else let __assign_21 = filePath in (
      tempMaybeString := __assign_21;
      __assign_21
    ));
    let path = !tempMaybeString in ParsedModule.create source decl path
  )
)
# 1 "backend_js_JsFunctionScope.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: backend.js.JsFunctionScope *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable locals : string HxMap.string_map; mutable used : bool HxMap.string_map; mutable classRefs : string HxMap.string_map; mutable tempCounter : int }

let create = fun classRefs2 -> let self = ({ __hx_type = HxType.class_ "backend.js.JsFunctionScope"; locals = HxMap.create_string (); used = HxMap.create_string (); classRefs = Obj.magic (); tempCounter = 0 } : t) in (
  ignore ((
    ignore (let __assign_1 = 0 in (
      self.tempCounter <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = HxMap.create_string () in (
      self.used <- __assign_2;
      __assign_2
    ));
    ignore (let __assign_3 = HxMap.create_string () in (
      self.locals <- __assign_3;
      __assign_3
    ));
    let tempRight = ref (Obj.magic ()) in (
      ignore (if classRefs2 == Obj.magic (HxRuntime.hx_null) then let __assign_4 = HxMap.create_string () in (
        tempRight := __assign_4;
        __assign_4
      ) else let __assign_5 = classRefs2 in (
        tempRight := __assign_5;
        __assign_5
      ));
      let __assign_6 = !tempRight in (
        self.classRefs <- __assign_6;
        __assign_6
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "backend.js.JsFunctionScope"; locals = HxMap.create_string (); used = HxMap.create_string (); classRefs = Obj.magic (); tempCounter = 0 } : t)

let reserve = fun self (name : string) -> try let candidate = ref (Backend_js_JsNameMangler.identifier name) in (
  ignore (if HxString.length (!candidate) = 0 then ignore (let __assign_7 = "_" in (
    candidate := __assign_7;
    __assign_7
  )) else ());
  ignore (if not (HxMap.exists_string (self.used) (!candidate)) then ignore ((
    ignore (HxMap.set_string (self.used) (!candidate) true);
    raise (HxRuntime.Hx_return (Obj.repr (!candidate)))
  )) else ());
  let suffix = ref 1 in (
    ignore (while HxMap.exists_string (self.used) ((HxString.toStdString (!candidate) ^ "_") ^ string_of_int (!suffix)) do ignore (let __old_8 = !suffix in let __new_9 = HxInt.add __old_8 1 in (
      ignore (suffix := __new_9);
      __old_8
    )) done);
    let unique = (HxString.toStdString (!candidate) ^ "_") ^ string_of_int (!suffix) in (
      ignore (HxMap.set_string (self.used) unique true);
      unique
    )
  )
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10

let declareLocal = fun self (raw : string) -> try let existing = HxMap.get_string (self.locals) raw in (
  ignore (if existing != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr existing)) else ());
  let safe = reserve self raw in (
    ignore (HxMap.set_string (self.locals) raw safe);
    safe
  )
) with
  | HxRuntime.Hx_return __ret_11 -> Obj.obj __ret_11

let resolveLocal = fun self (raw : string) -> HxMap.get_string (self.locals) raw

let resolveClassRef = fun self (raw : string) -> HxMap.get_string (self.classRefs) raw

let freshTemp = fun self (prefix : string) -> try let tempString = ref "" in (
  ignore (if prefix == Obj.magic (HxRuntime.hx_null) || HxString.length prefix = 0 then let __assign_12 = "__tmp" in (
    tempString := __assign_12;
    __assign_12
  ) else let __assign_13 = prefix in (
    tempString := __assign_13;
    __assign_13
  ));
  ignore (while true do ignore (let name = reserve self ((HxString.toStdString (!tempString) ^ "_") ^ string_of_int (self.tempCounter)) in (
    ignore (let __obj_14 = self in let __old_15 = __obj_14.tempCounter in let __new_16 = HxInt.add __old_15 1 in (
      ignore (__obj_14.tempCounter <- __new_16);
      __old_15
    ));
    if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then raise (HxRuntime.Hx_return (Obj.repr name)) else ()
  )) done);
  reserve self "__tmp_fallback"
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17

let exprScope = fun self () -> let self = self in let __anon_18 = HxAnon.create () in (
  ignore (HxAnon.set __anon_18 "resolveLocal" (Obj.repr (fun name -> resolveLocal self name)));
  ignore (HxAnon.set __anon_18 "resolveClassRef" (Obj.repr (fun name -> resolveClassRef self name)));
  __anon_18
)
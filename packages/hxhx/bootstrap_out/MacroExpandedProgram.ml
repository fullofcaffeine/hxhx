# 1 "MacroExpandedProgram.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: MacroExpandedProgram *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable macroMode : bool; mutable typedModules : TypedModule.t HxArray.t; mutable generatedOcamlModules : Obj.t HxArray.t }

let create = fun typedModules2 macroMode2 generatedOcamlModules2 -> let self = ({ __hx_type = HxType.class_ "MacroExpandedProgram"; macroMode = false; typedModules = Obj.magic (); generatedOcamlModules = Obj.magic () } : t) in (
  ignore (let tempRight = ref (Obj.magic ()) in (
    ignore (if typedModules2 == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
      tempRight := __assign_1;
      __assign_1
    ) else let __assign_3 = typedModules2 in (
      tempRight := __assign_3;
      __assign_3
    ));
    ignore (let __assign_4 = !tempRight in (
      self.typedModules <- __assign_4;
      __assign_4
    ));
    ignore (let __assign_5 = macroMode2 in (
      self.macroMode <- __assign_5;
      __assign_5
    ));
    let tempRight1 = ref (Obj.magic ()) in (
      ignore (if generatedOcamlModules2 == Obj.magic (HxRuntime.hx_null) then let __assign_6 = let __arr_7 = HxArray.create () in __arr_7 in (
        tempRight1 := __assign_6;
        __assign_6
      ) else let __assign_8 = generatedOcamlModules2 in (
        tempRight1 := __assign_8;
        __assign_8
      ));
      let __assign_9 = !tempRight1 in (
        self.generatedOcamlModules <- __assign_9;
        __assign_9
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "MacroExpandedProgram"; macroMode = false; typedModules = Obj.magic (); generatedOcamlModules = Obj.magic () } : t)

let getTypedModules = fun self () -> self.typedModules

let getGeneratedOcamlModules = fun self () -> self.generatedOcamlModules
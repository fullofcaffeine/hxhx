# 1 "backend_js_JsStmtEmitter.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: backend.js.JsStmtEmitter *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "backend.js.JsStmtEmitter" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "backend.js.JsStmtEmitter" } : t)

let normalizeCatchType = fun typeHint -> try (
  ignore (if typeHint == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let hint = ref (StringTools.trim typeHint) in (
    ignore (if HxString.length (!hint) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    ignore (let __assign_9 = StringTools.replace (!hint) " " "" in (
      hint := __assign_9;
      __assign_9
    ));
    ignore (let __assign_10 = StringTools.replace (!hint) "\t" "" in (
      hint := __assign_10;
      __assign_10
    ));
    ignore (let __assign_11 = StringTools.replace (!hint) "\n" "" in (
      hint := __assign_11;
      __assign_11
    ));
    ignore (let __assign_12 = StringTools.replace (!hint) "\r" "" in (
      hint := __assign_12;
      __assign_12
    ));
    ignore (while StringTools.startsWith (!hint) "Null<" && StringTools.endsWith (!hint) ">" do ignore (let __assign_13 = HxString.substr (!hint) 5 (HxInt.sub (HxString.length (!hint)) 6) in (
      hint := __assign_13;
      __assign_13
    )) done);
    let genericAt = HxString.indexOf (!hint) "<" 0 in (
      ignore (if genericAt >= 0 then ignore (let __assign_14 = HxString.substr (!hint) 0 genericAt in (
        hint := __assign_14;
        __assign_14
      )) else ());
      !hint
    )
  )
) with
  | HxRuntime.Hx_return __ret_15 -> Obj.obj __ret_15

let simpleTypeName = fun fullName -> try (
  ignore (if fullName == Obj.magic (HxRuntime.hx_null) || HxString.length fullName = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let parts = HxString.split fullName "." in HxArray.get parts (HxInt.sub (HxArray.length parts) 1)
) with
  | HxRuntime.Hx_return __ret_16 -> Obj.obj __ret_16

let emitCatchCondition = fun typeHint errRef -> try let normalized = normalizeCatchType typeHint in (
  ignore (if HxString.length normalized = 0 || HxString.equals normalized "Dynamic" || HxString.equals normalized "Any" then raise (HxRuntime.Hx_return (Obj.repr "true")) else ());
  let tempResult = ref "" in (
    ignore (match normalized with
      | "Array" | "StdTypes.Array" -> let __assign_18 = ("Array.isArray(" ^ HxString.toStdString errRef) ^ ")" in (
        tempResult := __assign_18;
        __assign_18
      )
      | "Bool" | "StdTypes.Bool" -> let __assign_19 = ("(typeof " ^ HxString.toStdString errRef) ^ " === \"boolean\")" in (
        tempResult := __assign_19;
        __assign_19
      )
      | "Float" | "StdTypes.Float" -> let __assign_20 = ("(typeof " ^ HxString.toStdString errRef) ^ " === \"number\")" in (
        tempResult := __assign_20;
        __assign_20
      )
      | "Int" | "StdTypes.Int" -> let __assign_21 = ((((("(typeof " ^ HxString.toStdString errRef) ^ " === \"number\" && ((") ^ HxString.toStdString errRef) ^ " | 0) === ") ^ HxString.toStdString errRef) ^ "))" in (
        tempResult := __assign_21;
        __assign_21
      )
      | "StdTypes.String" | "String" -> let __assign_22 = ((("(typeof " ^ HxString.toStdString errRef) ^ " === \"string\" || ") ^ HxString.toStdString errRef) ^ " instanceof String)" in (
        tempResult := __assign_22;
        __assign_22
      )
      | _ -> let simple = simpleTypeName normalized in let normalizedQuoted = Backend_js_JsNameMangler.quoteString normalized in let simpleQuoted = Backend_js_JsNameMangler.quoteString simple in let __assign_17 = ((((((((((((((((((((("(" ^ HxString.toStdString errRef) ^ " != null && typeof ") ^ HxString.toStdString errRef) ^ " === \"object\" && (") ^ HxString.toStdString errRef) ^ ".__hx_name === ") ^ HxString.toStdString normalizedQuoted) ^ " || ") ^ HxString.toStdString errRef) ^ ".__hx_name === ") ^ HxString.toStdString simpleQuoted) ^ " || (") ^ HxString.toStdString errRef) ^ ".constructor != null && (") ^ HxString.toStdString errRef) ^ ".constructor.__hx_name === ") ^ HxString.toStdString normalizedQuoted) ^ " || ") ^ HxString.toStdString errRef) ^ ".constructor.__hx_name === ") ^ HxString.toStdString simpleQuoted) ^ "))))" in (
        tempResult := __assign_17;
        __assign_17
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_23 -> Obj.obj __ret_23

let rec emitStmtBlockContent = fun writer stmt scope -> if (match stmt with
  | HxStmt.SBlock (_, _) -> 0
  | HxStmt.SVar (_, _, _, _) -> 1
  | HxStmt.SIf (_, _, _, _) -> 2
  | HxStmt.SForIn (_, _, _, _) -> 3
  | HxStmt.SWhile (_, _, _) -> 4
  | HxStmt.SDoWhile (_, _, _) -> 5
  | HxStmt.SSwitch (_, _, _) -> 6
  | HxStmt.STry (_, _, _) -> 7
  | HxStmt.SBreak _ -> 8
  | HxStmt.SContinue _ -> 9
  | HxStmt.SThrow (_, _) -> 10
  | HxStmt.SReturnVoid _ -> 11
  | HxStmt.SReturn (_, _) -> 12
  | HxStmt.SExpr (_, _) -> 13) = 0 then ignore (let _g = match stmt with
  | HxStmt.SBlock (__enum_param_3, _) -> __enum_param_3
  | _ -> failwith "Unexpected enum parameter" in (
  ignore (match stmt with
    | HxStmt.SBlock (_, __enum_param_4) -> __enum_param_4
    | _ -> failwith "Unexpected enum parameter");
  let stmts = _g in let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let s = HxArray.get stmts (!_g2) in (
    ignore (let __old_5 = !_g2 in let __new_6 = HxInt.add __old_5 1 in (
      ignore (_g2 := __new_6);
      __new_6
    ));
    emitStmt writer s scope
  )) done
)) else ignore (emitStmt writer stmt scope)
and emitStmt = fun writer stmt scope -> match stmt with
  | HxStmt.SBlock (_p0, _p1) -> ignore (let _g = _p0 in (
    ignore _p1;
    let stmts = _g in (
      ignore (Backend_js_JsWriter.writeln writer "{");
      ignore (Backend_js_JsWriter.pushIndent writer ());
      ignore (let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let s = HxArray.get stmts (!_g2) in (
        ignore (let __old_7 = !_g2 in let __new_8 = HxInt.add __old_7 1 in (
          ignore (_g2 := __new_8);
          __new_8
        ));
        emitStmt writer s scope
      )) done);
      ignore (Backend_js_JsWriter.popIndent writer ());
      Backend_js_JsWriter.writeln writer "}"
    )
  ))
  | HxStmt.SVar (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in (
    ignore _p3;
    let name = _g in (
      ignore _g1;
      let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in let local = Backend_js_JsFunctionScope.declareLocal scope name in if init != Obj.magic (HxRuntime.hx_null) then ignore (Backend_js_JsWriter.writeln writer (((("var " ^ HxString.toStdString local) ^ " = ") ^ HxString.toStdString (Backend_js_JsExprEmitter.emit (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ";")) else ignore (Backend_js_JsWriter.writeln writer (("var " ^ HxString.toStdString local) ^ ";"))
    )
  ))
  | HxStmt.SIf (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in (
    ignore _p3;
    let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
      ignore (Backend_js_JsWriter.writeln writer (("if (" ^ HxString.toStdString (Backend_js_JsExprEmitter.emit cond (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ") {"));
      ignore (Backend_js_JsWriter.pushIndent writer ());
      ignore (emitStmtBlockContent writer thenBranch scope);
      ignore (Backend_js_JsWriter.popIndent writer ());
      if elseBranch == Obj.magic (HxRuntime.hx_null) then ignore (Backend_js_JsWriter.writeln writer "}") else ignore ((
        ignore (Backend_js_JsWriter.writeln writer "} else {");
        ignore (Backend_js_JsWriter.pushIndent writer ());
        ignore (emitStmtBlockContent writer (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) scope);
        ignore (Backend_js_JsWriter.popIndent writer ());
        Backend_js_JsWriter.writeln writer "}"
      ))
    )
  ))
  | HxStmt.SForIn (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in (
    ignore _p3;
    let name = _g in let iterable = _g1 in let body = _g2 in emitForIn writer name iterable body scope
  ))
  | HxStmt.SWhile (_p0, _p1, _p2) -> ignore (let _g = _p0 in let _g1 = _p1 in (
    ignore _p2;
    let cond = _g in let body = _g1 in (
      ignore (Backend_js_JsWriter.writeln writer (("while (" ^ HxString.toStdString (Backend_js_JsExprEmitter.emit cond (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ") {"));
      ignore (Backend_js_JsWriter.pushIndent writer ());
      ignore (emitStmtBlockContent writer body scope);
      ignore (Backend_js_JsWriter.popIndent writer ());
      Backend_js_JsWriter.writeln writer "}"
    )
  ))
  | HxStmt.SDoWhile (_p0, _p1, _p2) -> ignore (let _g = _p0 in let _g1 = _p1 in (
    ignore _p2;
    let body = _g in let cond = _g1 in (
      ignore (Backend_js_JsWriter.writeln writer "do {");
      ignore (Backend_js_JsWriter.pushIndent writer ());
      ignore (emitStmtBlockContent writer body scope);
      ignore (Backend_js_JsWriter.popIndent writer ());
      Backend_js_JsWriter.writeln writer (("} while (" ^ HxString.toStdString (Backend_js_JsExprEmitter.emit cond (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ");")
    )
  ))
  | HxStmt.SSwitch (_p0, _p1, _p2) -> ignore (let _g = _p0 in let _g1 = _p1 in (
    ignore _p2;
    let scrutinee = _g in let cases = _g1 in emitSwitch writer scrutinee cases scope
  ))
  | HxStmt.STry (_p0, _p1, _p2) -> ignore (let _g = _p0 in let _g1 = _p1 in (
    ignore _p2;
    let tryBody = _g in let catches = _g1 in emitTry writer tryBody catches scope
  ))
  | HxStmt.SBreak _p0 -> ignore ((
    ignore _p0;
    Backend_js_JsWriter.writeln writer "break;"
  ))
  | HxStmt.SContinue _p0 -> ignore ((
    ignore _p0;
    Backend_js_JsWriter.writeln writer "continue;"
  ))
  | HxStmt.SThrow (_p0, _p1) -> ignore (let _g = _p0 in (
    ignore _p1;
    let expr = _g in Backend_js_JsWriter.writeln writer (("throw " ^ HxString.toStdString (Backend_js_JsExprEmitter.emit expr (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ";")
  ))
  | HxStmt.SReturnVoid _p0 -> ignore ((
    ignore _p0;
    Backend_js_JsWriter.writeln writer "return;"
  ))
  | HxStmt.SReturn (_p0, _p1) -> ignore (let _g = _p0 in (
    ignore _p1;
    let expr = _g in Backend_js_JsWriter.writeln writer (("return " ^ HxString.toStdString (Backend_js_JsExprEmitter.emit expr (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ";")
  ))
  | HxStmt.SExpr (_p0, _p1) -> ignore (let _g = _p0 in (
    ignore _p1;
    let expr = _g in Backend_js_JsWriter.writeln writer (HxString.toStdString (Backend_js_JsExprEmitter.emit expr (Backend_js_JsFunctionScope.exprScope scope ())) ^ ";")
  ))
and emitTry = fun writer tryBody catches scope -> (
  ignore (Backend_js_JsWriter.writeln writer "try {");
  ignore (Backend_js_JsWriter.pushIndent writer ());
  ignore (emitStmtBlockContent writer tryBody scope);
  ignore (Backend_js_JsWriter.popIndent writer ());
  ignore (Backend_js_JsWriter.writeln writer "} catch (__hx_err) {");
  ignore (Backend_js_JsWriter.pushIndent writer ());
  ignore (if catches == Obj.magic (HxRuntime.hx_null) || HxArray.length catches = 0 then ignore (Backend_js_JsWriter.writeln writer "throw __hx_err;") else ignore (let _g = ref 0 in let _g1 = HxArray.length catches in (
    ignore (while !_g < _g1 do ignore (let i = let __old_24 = !_g in let __new_25 = HxInt.add __old_24 1 in (
      ignore (_g := __new_25);
      __old_24
    ) in let c = HxArray.get catches i in let tempString = ref "" in (
      ignore (if i = 0 then let __assign_26 = "if" in (
        tempString := __assign_26;
        __assign_26
      ) else let __assign_27 = "else if" in (
        tempString := __assign_27;
        __assign_27
      ));
      let head = !tempString in let condition = emitCatchCondition (Obj.obj (HxAnon.get c "typeHint")) "__hx_err" in (
        ignore (Backend_js_JsWriter.writeln writer (((HxString.toStdString head ^ " (") ^ HxString.toStdString condition) ^ ") {"));
        ignore (Backend_js_JsWriter.pushIndent writer ());
        let bind = Backend_js_JsFunctionScope.declareLocal scope (Obj.obj (HxAnon.get c "name")) in (
          ignore (Backend_js_JsWriter.writeln writer (("var " ^ HxString.toStdString bind) ^ " = __hx_err;"));
          ignore (emitStmtBlockContent writer (Obj.obj (HxAnon.get c "body")) scope);
          ignore (Backend_js_JsWriter.popIndent writer ());
          Backend_js_JsWriter.writeln writer "}"
        )
      )
    )) done);
    ignore (Backend_js_JsWriter.writeln writer "else {");
    ignore (Backend_js_JsWriter.pushIndent writer ());
    ignore (Backend_js_JsWriter.writeln writer "throw __hx_err;");
    ignore (Backend_js_JsWriter.popIndent writer ());
    Backend_js_JsWriter.writeln writer "}"
  )));
  ignore (Backend_js_JsWriter.popIndent writer ());
  Backend_js_JsWriter.writeln writer "}"
)
and emitForIn = fun writer name iterable body scope -> if (match iterable with
  | HxExpr.ENull -> 0
  | HxExpr.EBool _ -> 1
  | HxExpr.EString _ -> 2
  | HxExpr.EInt _ -> 3
  | HxExpr.EFloat _ -> 4
  | HxExpr.EEnumValue _ -> 5
  | HxExpr.EThis -> 6
  | HxExpr.ESuper -> 7
  | HxExpr.EIdent _ -> 8
  | HxExpr.EField (_, _) -> 9
  | HxExpr.ECall (_, _) -> 10
  | HxExpr.ELambda (_, _) -> 11
  | HxExpr.ETryCatchRaw _ -> 12
  | HxExpr.ESwitchRaw _ -> 13
  | HxExpr.ESwitch (_, _) -> 14
  | HxExpr.ENew (_, _) -> 15
  | HxExpr.EUnop (_, _) -> 16
  | HxExpr.EBinop (_, _, _) -> 17
  | HxExpr.ETernary (_, _, _) -> 18
  | HxExpr.EAnon (_, _) -> 19
  | HxExpr.EArrayComprehension (_, _, _) -> 20
  | HxExpr.EArrayDecl _ -> 21
  | HxExpr.EArrayAccess (_, _) -> 22
  | HxExpr.ERange (_, _) -> 23
  | HxExpr.ECast (_, _) -> 24
  | HxExpr.EUntyped _ -> 25
  | HxExpr.EUnsupported _ -> 26) = 23 then ignore (let _g = match iterable with
  | HxExpr.ERange (__enum_param_28, _) -> __enum_param_28
  | _ -> failwith "Unexpected enum parameter" in let _g1 = match iterable with
  | HxExpr.ERange (_, __enum_param_29) -> __enum_param_29
  | _ -> failwith "Unexpected enum parameter" in let start = _g in let hx_end = _g1 in let local = Backend_js_JsFunctionScope.declareLocal scope name in (
  ignore (Backend_js_JsWriter.writeln writer (((((((((("for (var " ^ HxString.toStdString local) ^ " = ") ^ HxString.toStdString (Backend_js_JsExprEmitter.emit start (Backend_js_JsFunctionScope.exprScope scope ()))) ^ "; ") ^ HxString.toStdString local) ^ " < ") ^ HxString.toStdString (Backend_js_JsExprEmitter.emit hx_end (Backend_js_JsFunctionScope.exprScope scope ()))) ^ "; ") ^ HxString.toStdString local) ^ "++) {"));
  ignore (Backend_js_JsWriter.pushIndent writer ());
  ignore (emitStmtBlockContent writer body scope);
  ignore (Backend_js_JsWriter.popIndent writer ());
  Backend_js_JsWriter.writeln writer "}"
)) else ignore (let sourceVar = Backend_js_JsFunctionScope.freshTemp scope "__iter" in let indexVar = Backend_js_JsFunctionScope.freshTemp scope "__i" in let local = Backend_js_JsFunctionScope.declareLocal scope name in (
  ignore (Backend_js_JsWriter.writeln writer (((("var " ^ HxString.toStdString sourceVar) ^ " = ") ^ HxString.toStdString (Backend_js_JsExprEmitter.emit iterable (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ";"));
  ignore (Backend_js_JsWriter.writeln writer (((((((("for (var " ^ HxString.toStdString indexVar) ^ " = 0; ") ^ HxString.toStdString indexVar) ^ " < ") ^ HxString.toStdString sourceVar) ^ ".length; ") ^ HxString.toStdString indexVar) ^ "++) {"));
  ignore (Backend_js_JsWriter.pushIndent writer ());
  ignore (Backend_js_JsWriter.writeln writer (((((("var " ^ HxString.toStdString local) ^ " = ") ^ HxString.toStdString sourceVar) ^ "[") ^ HxString.toStdString indexVar) ^ "];"));
  ignore (emitStmtBlockContent writer body scope);
  ignore (Backend_js_JsWriter.popIndent writer ());
  Backend_js_JsWriter.writeln writer "}"
))
and emitSwitch = fun writer scrutinee cases scope -> let scrutineeVar = Backend_js_JsFunctionScope.freshTemp scope "__sw" in (
  ignore (Backend_js_JsWriter.writeln writer (((("var " ^ HxString.toStdString scrutineeVar) ^ " = ") ^ HxString.toStdString (Backend_js_JsExprEmitter.emit scrutinee (Backend_js_JsFunctionScope.exprScope scope ()))) ^ ";"));
  let isFirst = ref true in let _g = ref 0 in while !_g < HxArray.length cases do ignore (let c = HxArray.get cases (!_g) in (
    ignore (let __old_30 = !_g in let __new_31 = HxInt.add __old_30 1 in (
      ignore (_g := __new_31);
      __new_31
    ));
    let lowered = Backend_js_JsSwitchPatternLowering.lower (Obj.obj (HxAnon.get c "pattern")) scrutineeVar in let tempString = ref "" in (
      ignore (if !isFirst then let __assign_32 = "if" in (
        tempString := __assign_32;
        __assign_32
      ) else let __assign_33 = "else if" in (
        tempString := __assign_33;
        __assign_33
      ));
      let head = !tempString in (
        ignore (Backend_js_JsWriter.writeln writer (((HxString.toStdString head ^ " (") ^ HxString.toStdString (Obj.obj (HxAnon.get lowered "cond"))) ^ ") {"));
        ignore (Backend_js_JsWriter.pushIndent writer ());
        ignore (if Obj.obj (HxAnon.get lowered "bindName") != Obj.magic (HxRuntime.hx_null) then ignore (let bind = Backend_js_JsFunctionScope.declareLocal scope (Obj.obj (HxAnon.get lowered "bindName")) in Backend_js_JsWriter.writeln writer (((("var " ^ HxString.toStdString bind) ^ " = ") ^ HxString.toStdString scrutineeVar) ^ ";")) else ());
        ignore (emitStmtBlockContent writer (Obj.obj (HxAnon.get c "body")) scope);
        ignore (Backend_js_JsWriter.popIndent writer ());
        ignore (Backend_js_JsWriter.writeln writer "}");
        let __assign_34 = false in (
          isFirst := __assign_34;
          __assign_34
        )
      )
    )
  )) done
)

let emitFunctionBody = fun writer body scope -> let _g = ref 0 in while !_g < HxArray.length body do ignore (let s = HxArray.get body (!_g) in (
  ignore (let __old_1 = !_g in let __new_2 = HxInt.add __old_1 1 in (
    ignore (_g := __new_2);
    __new_2
  ));
  emitStmt writer s scope
)) done
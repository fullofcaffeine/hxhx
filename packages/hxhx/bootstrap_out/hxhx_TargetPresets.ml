# 1 "hxhx_TargetPresets.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx._TargetPresets.ArgScan *)

let __reflaxe_ocaml__ = ()

type argscan_t = { __hx_type : Obj.t }

let argscan_create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx._TargetPresets.ArgScan" } : argscan_t) in (
  ignore ();
  self
)

let argscan___empty = fun () -> ({ __hx_type = HxType.class_ "hxhx._TargetPresets.ArgScan" } : argscan_t)

let argscan_hasLib = fun args name -> try let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in (
    ignore (if (HxString.equals a "-lib" || HxString.equals a "--library") && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) name then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
    let __old_1 = !i in let __new_2 = HxInt.add __old_1 1 in (
      ignore (i := __new_2);
      __old_1
    )
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let argscan_hasMacro = fun args macroExpr -> try let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore ((
    ignore (if HxString.equals (HxArray.get args (!i)) "--macro" && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) macroExpr then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
    let __old_4 = !i in let __new_5 = HxInt.add __old_4 1 in (
      ignore (i := __new_5);
      __old_4
    )
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_6 -> Obj.obj __ret_6

let argscan_addMacroIfMissing = fun args macroExpr -> try (
  ignore (if argscan_hasMacro args macroExpr then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "--macro");
  HxArray.push args macroExpr
) with
  | HxRuntime.Hx_return __ret_7 -> Obj.obj __ret_7

let argscan_getDefineValue = fun args name -> try let i = ref 0 in (
  ignore (try while !i < HxArray.length args do try ignore (let a = HxArray.get args (!i) in (
    ignore (if HxString.equals a "-D" && HxInt.add (!i) 1 < HxArray.length args then ignore (let d = HxArray.get args (HxInt.add (!i) 1) in (
      ignore (if HxString.equals d name then raise (HxRuntime.Hx_return (Obj.repr "1")) else ());
      ignore (if StringTools.startsWith d (HxString.toStdString name ^ "=") then raise (HxRuntime.Hx_return (Obj.repr (HxString.substr d (HxString.length (HxString.toStdString name ^ "=")) (-1)))) else ());
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_11 = !i in let __new_12 = HxInt.add __old_11 1 in (
      ignore (i := __new_12);
      __old_11
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  Obj.magic (HxRuntime.hx_null)
) with
  | HxRuntime.Hx_return __ret_13 -> Obj.obj __ret_13

let argscan_hasDefine = fun args name -> argscan_getDefineValue args name != Obj.magic (HxRuntime.hx_null)

let argscan_addDefineIfMissing = fun args define -> try let eq = HxString.indexOf define "=" 0 in let tempString = ref "" in (
  ignore (if eq = -1 then let __assign_8 = define in (
    tempString := __assign_8;
    __assign_8
  ) else let __assign_9 = HxString.substr define 0 eq in (
    tempString := __assign_9;
    __assign_9
  ));
  ignore (if argscan_hasDefine args (!tempString) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "-D");
  HxArray.push args define
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10

let argscan_addCpIfExists = fun args path -> try (
  ignore (if not (HxFileSystem.exists path) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxArray.indexOf args path 0 <> -1 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "-cp");
  HxArray.push args path
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

let argscan_stripLib = fun args name -> let i = ref 0 in try while !i < HxArray.length args do try ignore (let a = HxArray.get args (!i) in (
  ignore (if (HxString.equals a "-lib" || HxString.equals a "--library") && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) name then ignore ((
    ignore (HxArray.splice args (!i) 2);
    raise (HxRuntime.Hx_continue)
  )) else ());
  let __old_15 = !i in let __new_16 = HxInt.add __old_15 1 in (
    ignore (i := __new_16);
    __old_15
  )
)) with
  | HxRuntime.Hx_continue -> () done with
  | HxRuntime.Hx_break -> ()

let argscan_stripMacro = fun args macroExpr -> let i = ref 0 in try while !i < HxArray.length args do try ignore ((
  ignore (if HxString.equals (HxArray.get args (!i)) "--macro" && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) macroExpr then ignore ((
    ignore (HxArray.splice args (!i) 2);
    raise (HxRuntime.Hx_continue)
  )) else ());
  let __old_17 = !i in let __new_18 = HxInt.add __old_17 1 in (
    ignore (i := __new_18);
    __old_17
  )
)) with
  | HxRuntime.Hx_continue -> () done with
  | HxRuntime.Hx_break -> ()

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.TargetPresets *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.TargetPresets" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.TargetPresets" } : t)

let listTargets = fun () -> let __arr_1 = HxArray.create () in (
  ignore (HxArray.push __arr_1 "ocaml");
  ignore (HxArray.push __arr_1 "ocaml-stage3");
  __arr_1
)

let applyOcamlStage3 = fun forwarded -> let out = HxArray.copy forwarded in let reflaxeTarget = argscan_getDefineValue out "reflaxe-target" in (
  ignore (if reflaxeTarget != Obj.magic (HxRuntime.hx_null) && not (HxString.equals reflaxeTarget "ocaml") then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("Contradiction: --target ocaml-stage3 but -D reflaxe-target=" ^ HxString.toStdString reflaxeTarget)) ["Dynamic"; "String"]) else ());
  ignore (argscan_stripLib out "reflaxe.ocaml");
  ignore (argscan_stripMacro out "reflaxe.ocaml.CompilerInit.Start()");
  ignore (argscan_stripMacro out "reflaxe.ReflectCompiler.Start()");
  ignore (argscan_stripMacro out "nullSafety(\"reflaxe\")");
  out
)

let findBundledLibRoot = fun () -> try try let exe = HxSys.programPath () in (
  ignore (if exe == Obj.magic (HxRuntime.hx_null) || HxString.length exe = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let abs = HxFileSystem.fullPath exe in let root = Haxe_io_Path.directory (Haxe_io_Path.directory abs) in let libRoot = Haxe_io_Path.join (let __arr_10 = HxArray.create () in (
    ignore (HxArray.push __arr_10 root);
    ignore (HxArray.push __arr_10 "lib");
    __arr_10
  )) in (
    ignore (if not (HxFileSystem.exists (Haxe_io_Path.join (let __arr_11 = HxArray.create () in (
      ignore (HxArray.push __arr_11 libRoot);
      ignore (HxArray.push __arr_11 "reflaxe");
      ignore (HxArray.push __arr_11 "src");
      __arr_11
    )))) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if not (HxFileSystem.exists (Haxe_io_Path.join (let __arr_12 = HxArray.create () in (
      ignore (HxArray.push __arr_12 libRoot);
      ignore (HxArray.push __arr_12 "reflaxe.ocaml");
      ignore (HxArray.push __arr_12 "src");
      __arr_12
    )))) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    raise (HxRuntime.Hx_return (Obj.repr libRoot))
  )
) with
  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
  | HxRuntime.Hx_return __ret_13 -> raise (HxRuntime.Hx_return __ret_13)
  | HxRuntime.Hx_exception (__exn_v_14, __exn_tags_15) -> if true then let _hx = (__exn_v_14 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else HxRuntime.hx_throw_typed __exn_v_14 __exn_tags_15
  | __exn_16 -> if true then let _hx = (Obj.repr __exn_16 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else raise (__exn_16) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17

let applyOcaml = fun forwarded -> let out = HxArray.copy forwarded in let reflaxeTarget = argscan_getDefineValue out "reflaxe-target" in (
  ignore (if reflaxeTarget != Obj.magic (HxRuntime.hx_null) && not (HxString.equals reflaxeTarget "ocaml") then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("Contradiction: --target ocaml but -D reflaxe-target=" ^ HxString.toStdString reflaxeTarget)) ["Dynamic"; "String"]) else ());
  let hasLib = argscan_hasLib out "reflaxe.ocaml" in let hasInitMacro = argscan_hasMacro out "reflaxe.ocaml.CompilerInit.Start()" in (
    ignore (if not (hasLib) && not (hasInitMacro) then ignore (let bundled = findBundledLibRoot () in if bundled != Obj.magic (HxRuntime.hx_null) then ignore (let reflaxeRoot = Haxe_io_Path.join (let __arr_6 = HxArray.create () in (
      ignore (HxArray.push __arr_6 bundled);
      ignore (HxArray.push __arr_6 "reflaxe");
      __arr_6
    )) in let ocamlRoot = Haxe_io_Path.join (let __arr_7 = HxArray.create () in (
      ignore (HxArray.push __arr_7 bundled);
      ignore (HxArray.push __arr_7 "reflaxe.ocaml");
      __arr_7
    )) in (
      ignore (argscan_addCpIfExists out (Haxe_io_Path.join (let __arr_8 = HxArray.create () in (
        ignore (HxArray.push __arr_8 reflaxeRoot);
        ignore (HxArray.push __arr_8 "src");
        __arr_8
      ))));
      ignore (argscan_addCpIfExists out (Haxe_io_Path.join (let __arr_9 = HxArray.create () in (
        ignore (HxArray.push __arr_9 ocamlRoot);
        ignore (HxArray.push __arr_9 "src");
        __arr_9
      ))));
      ignore (argscan_addMacroIfMissing out "nullSafety(\"reflaxe\")");
      ignore (argscan_addMacroIfMissing out "reflaxe.ReflectCompiler.Start()");
      argscan_addMacroIfMissing out "reflaxe.ocaml.CompilerInit.Start()"
    )) else ignore ((
      ignore (HxArray.unshift out "reflaxe.ocaml");
      HxArray.unshift out "-lib"
    ))) else ());
    ignore (if not (argscan_hasDefine out "ocaml_output") then ignore ((
      ignore (HxArray.push out "-D");
      HxArray.push out "ocaml_output=out"
    )) else ());
    ignore (argscan_addDefineIfMissing out "reflaxe-target=ocaml");
    ignore (argscan_addDefineIfMissing out "reflaxe-target-code-injection=ocaml");
    ignore (argscan_addDefineIfMissing out "retain-untyped-meta");
    out
  )
)

let resolve = fun targetId forwarded -> let tempResult = ref (Obj.magic ()) in (
  ignore (match targetId with
    | "ocaml" -> let __assign_2 = let __anon_3 = HxAnon.create () in (
      ignore (HxAnon.set __anon_3 "id" (Obj.repr "ocaml"));
      ignore (HxAnon.set __anon_3 "kind" (Obj.repr "both"));
      ignore (HxAnon.set __anon_3 "runMode" (Obj.repr "delegate_stage0"));
      ignore (HxAnon.set __anon_3 "describe" (Obj.repr "Reflaxe OCaml backend via stage0 delegation"));
      ignore (HxAnon.set __anon_3 "forwarded" (Obj.repr (applyOcaml forwarded)));
      __anon_3
    ) in (
      tempResult := __assign_2;
      __assign_2
    )
    | "ocaml-stage3" -> let __assign_4 = let __anon_5 = HxAnon.create () in (
      ignore (HxAnon.set __anon_5 "id" (Obj.repr "ocaml-stage3"));
      ignore (HxAnon.set __anon_5 "kind" (Obj.repr "builtin"));
      ignore (HxAnon.set __anon_5 "runMode" (Obj.repr "builtin_stage3"));
      ignore (HxAnon.set __anon_5 "describe" (Obj.repr "Linked Stage3 OCaml emitter fast-path (no --library required)"));
      ignore (HxAnon.set __anon_5 "forwarded" (Obj.repr (applyOcamlStage3 forwarded)));
      __anon_5
    ) in (
      tempResult := __assign_4;
      __assign_4
    )
    | _ -> HxType.hx_throw_typed_rtti (Obj.repr ("Unknown target: " ^ HxString.toStdString targetId)) ["Dynamic"; "String"]);
  !tempResult
)

let apply = fun targetId forwarded -> Obj.obj (HxAnon.get (resolve targetId forwarded) "forwarded")
# 1 "hxhx_TargetPresets.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx._TargetPresets.ArgScan *)

let __reflaxe_ocaml__ = ()

type argscan_t = { __hx_type : Obj.t }

let argscan_create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx._TargetPresets.ArgScan" } : argscan_t) in (
  ignore ();
  self
)

let argscan___empty = fun () -> ({ __hx_type = HxType.class_ "hxhx._TargetPresets.ArgScan" } : argscan_t)

let argscan_hasLib = fun args name -> try let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in (
    ignore (if (HxString.equals a "-lib" || HxString.equals a "--library") && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) name then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
    let __old_1 = !i in let __new_2 = HxInt.add __old_1 1 in (
      ignore (i := __new_2);
      __old_1
    )
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let argscan_hasMacro = fun args macroExpr -> try let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore ((
    ignore (if HxString.equals (HxArray.get args (!i)) "--macro" && HxInt.add (!i) 1 < HxArray.length args && HxString.equals (HxArray.get args (HxInt.add (!i) 1)) macroExpr then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
    let __old_4 = !i in let __new_5 = HxInt.add __old_4 1 in (
      ignore (i := __new_5);
      __old_4
    )
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_6 -> Obj.obj __ret_6

let argscan_addMacroIfMissing = fun args macroExpr -> try (
  ignore (if argscan_hasMacro args macroExpr then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "--macro");
  HxArray.push args macroExpr
) with
  | HxRuntime.Hx_return __ret_7 -> Obj.obj __ret_7

let argscan_getDefineValue = fun args name -> try let i = ref 0 in (
  ignore (try while !i < HxArray.length args do try ignore (let a = HxArray.get args (!i) in (
    ignore (if HxString.equals a "-D" && HxInt.add (!i) 1 < HxArray.length args then ignore (let d = HxArray.get args (HxInt.add (!i) 1) in (
      ignore (if HxString.equals d name then raise (HxRuntime.Hx_return (Obj.repr "1")) else ());
      ignore (if StringTools.startsWith d (HxString.toStdString name ^ "=") then raise (HxRuntime.Hx_return (Obj.repr (HxString.substr d (HxString.length (HxString.toStdString name ^ "=")) (-1)))) else ());
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_11 = !i in let __new_12 = HxInt.add __old_11 1 in (
      ignore (i := __new_12);
      __old_11
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  Obj.magic (HxRuntime.hx_null)
) with
  | HxRuntime.Hx_return __ret_13 -> Obj.obj __ret_13

let argscan_hasDefine = fun args name -> argscan_getDefineValue args name != Obj.magic (HxRuntime.hx_null)

let argscan_addDefineIfMissing = fun args define -> try let eq = HxString.indexOf define "=" 0 in let tempString = ref "" in (
  ignore (if eq = -1 then let __assign_8 = define in (
    tempString := __assign_8;
    __assign_8
  ) else let __assign_9 = HxString.substr define 0 eq in (
    tempString := __assign_9;
    __assign_9
  ));
  ignore (if argscan_hasDefine args (!tempString) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "-D");
  HxArray.push args define
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10

let argscan_addCpIfExists = fun args path -> try (
  ignore (if not (HxFileSystem.exists path) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxArray.indexOf args path 0 <> -1 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxArray.push args "-cp");
  HxArray.push args path
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.TargetPresets *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.TargetPresets" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.TargetPresets" } : t)

let listTargets = fun () -> let __arr_1 = HxArray.create () in (
  ignore (HxArray.push __arr_1 "ocaml");
  __arr_1
)

let findBundledLibRoot = fun () -> try try let exe = HxSys.programPath () in (
  ignore (if exe == Obj.magic (HxRuntime.hx_null) || HxString.length exe = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let abs = HxFileSystem.fullPath exe in let root = Haxe_io_Path.directory (Haxe_io_Path.directory abs) in let libRoot = Haxe_io_Path.join (let __arr_7 = HxArray.create () in (
    ignore (HxArray.push __arr_7 root);
    ignore (HxArray.push __arr_7 "lib");
    __arr_7
  )) in (
    ignore (if not (HxFileSystem.exists (Haxe_io_Path.join (let __arr_8 = HxArray.create () in (
      ignore (HxArray.push __arr_8 libRoot);
      ignore (HxArray.push __arr_8 "reflaxe");
      ignore (HxArray.push __arr_8 "src");
      __arr_8
    )))) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if not (HxFileSystem.exists (Haxe_io_Path.join (let __arr_9 = HxArray.create () in (
      ignore (HxArray.push __arr_9 libRoot);
      ignore (HxArray.push __arr_9 "reflaxe.ocaml");
      ignore (HxArray.push __arr_9 "src");
      __arr_9
    )))) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    raise (HxRuntime.Hx_return (Obj.repr libRoot))
  )
) with
  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
  | HxRuntime.Hx_return __ret_10 -> raise (HxRuntime.Hx_return __ret_10)
  | HxRuntime.Hx_exception (__exn_v_11, __exn_tags_12) -> if true then let _hx = (__exn_v_11 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else HxRuntime.hx_throw_typed __exn_v_11 __exn_tags_12
  | __exn_13 -> if true then let _hx = (Obj.repr __exn_13 : Obj.t) in (
    ignore _hx;
    raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))
  ) else raise (__exn_13) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

let applyOcaml = fun forwarded -> let out = HxArray.copy forwarded in let reflaxeTarget = argscan_getDefineValue out "reflaxe-target" in (
  ignore (if reflaxeTarget != Obj.magic (HxRuntime.hx_null) && not (HxString.equals reflaxeTarget "ocaml") then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("Contradiction: --target ocaml but -D reflaxe-target=" ^ HxString.toStdString reflaxeTarget)) ["Dynamic"; "String"]) else ());
  let hasLib = argscan_hasLib out "reflaxe.ocaml" in let hasInitMacro = argscan_hasMacro out "reflaxe.ocaml.CompilerInit.Start()" in (
    ignore (if not (hasLib) && not (hasInitMacro) then ignore (let bundled = findBundledLibRoot () in if bundled != Obj.magic (HxRuntime.hx_null) then ignore (let reflaxeRoot = Haxe_io_Path.join (let __arr_3 = HxArray.create () in (
      ignore (HxArray.push __arr_3 bundled);
      ignore (HxArray.push __arr_3 "reflaxe");
      __arr_3
    )) in let ocamlRoot = Haxe_io_Path.join (let __arr_4 = HxArray.create () in (
      ignore (HxArray.push __arr_4 bundled);
      ignore (HxArray.push __arr_4 "reflaxe.ocaml");
      __arr_4
    )) in (
      ignore (argscan_addCpIfExists out (Haxe_io_Path.join (let __arr_5 = HxArray.create () in (
        ignore (HxArray.push __arr_5 reflaxeRoot);
        ignore (HxArray.push __arr_5 "src");
        __arr_5
      ))));
      ignore (argscan_addCpIfExists out (Haxe_io_Path.join (let __arr_6 = HxArray.create () in (
        ignore (HxArray.push __arr_6 ocamlRoot);
        ignore (HxArray.push __arr_6 "src");
        __arr_6
      ))));
      ignore (argscan_addMacroIfMissing out "nullSafety(\"reflaxe\")");
      ignore (argscan_addMacroIfMissing out "reflaxe.ReflectCompiler.Start()");
      argscan_addMacroIfMissing out "reflaxe.ocaml.CompilerInit.Start()"
    )) else ignore ((
      ignore (HxArray.unshift out "reflaxe.ocaml");
      HxArray.unshift out "-lib"
    ))) else ());
    ignore (if not (argscan_hasDefine out "ocaml_output") then ignore ((
      ignore (HxArray.push out "-D");
      HxArray.push out "ocaml_output=out"
    )) else ());
    ignore (argscan_addDefineIfMissing out "reflaxe-target=ocaml");
    ignore (argscan_addDefineIfMissing out "reflaxe-target-code-injection=ocaml");
    ignore (argscan_addDefineIfMissing out "retain-untyped-meta");
    out
  )
)

let apply = fun targetId forwarded -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxString.equals targetId "ocaml" then let __assign_2 = applyOcaml forwarded in (
    tempResult := __assign_2;
    __assign_2
  ) else HxType.hx_throw_typed_rtti (Obj.repr ("Unknown target: " ^ HxString.toStdString targetId)) ["Dynamic"; "String"]);
  !tempResult
)
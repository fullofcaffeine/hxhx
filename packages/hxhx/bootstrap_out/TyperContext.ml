# 1 "TyperContext.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: TyperContext *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable index : TyperIndex.t; mutable loader : LazyTypeLoader.t; mutable filePath : string; mutable modulePath : string; mutable packagePath : string; mutable imports : string HxArray.t; mutable classFullName : string }

let create = fun index2 filePath2 modulePath2 packagePath2 imports2 classFullName2 loader2 -> let self = ({ __hx_type = HxType.class_ "TyperContext"; index = Obj.magic (); loader = Obj.magic (); filePath = ""; modulePath = ""; packagePath = ""; imports = Obj.magic (); classFullName = "" } : t) in (
  ignore ((
    ignore (let __assign_1 = index2 in (
      self.index <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = loader2 in (
      self.loader <- __assign_2;
      __assign_2
    ));
    let tempRight = ref "" in (
      ignore (if filePath2 == Obj.magic (HxRuntime.hx_null) || HxString.length filePath2 = 0 then let __assign_3 = "<unknown>" in (
        tempRight := __assign_3;
        __assign_3
      ) else let __assign_4 = filePath2 in (
        tempRight := __assign_4;
        __assign_4
      ));
      ignore (let __assign_5 = !tempRight in (
        self.filePath <- __assign_5;
        __assign_5
      ));
      let tempRight1 = ref "" in (
        ignore (if modulePath2 == Obj.magic (HxRuntime.hx_null) then let __assign_6 = "" in (
          tempRight1 := __assign_6;
          __assign_6
        ) else let __assign_7 = modulePath2 in (
          tempRight1 := __assign_7;
          __assign_7
        ));
        ignore (let __assign_8 = !tempRight1 in (
          self.modulePath <- __assign_8;
          __assign_8
        ));
        let tempRight2 = ref "" in (
          ignore (if packagePath2 == Obj.magic (HxRuntime.hx_null) then let __assign_9 = "" in (
            tempRight2 := __assign_9;
            __assign_9
          ) else let __assign_10 = packagePath2 in (
            tempRight2 := __assign_10;
            __assign_10
          ));
          ignore (let __assign_11 = !tempRight2 in (
            self.packagePath <- __assign_11;
            __assign_11
          ));
          let tempRight3 = ref (Obj.magic ()) in (
            ignore (if imports2 == Obj.magic (HxRuntime.hx_null) then let __assign_12 = let __arr_13 = HxArray.create () in __arr_13 in (
              tempRight3 := __assign_12;
              __assign_12
            ) else let __assign_14 = imports2 in (
              tempRight3 := __assign_14;
              __assign_14
            ));
            ignore (let __assign_15 = !tempRight3 in (
              self.imports <- __assign_15;
              __assign_15
            ));
            let tempRight4 = ref "" in (
              ignore (if classFullName2 == Obj.magic (HxRuntime.hx_null) then let __assign_16 = "" in (
                tempRight4 := __assign_16;
                __assign_16
              ) else let __assign_17 = classFullName2 in (
                tempRight4 := __assign_17;
                __assign_17
              ));
              let __assign_18 = !tempRight4 in (
                self.classFullName <- __assign_18;
                __assign_18
              )
            )
          )
        )
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "TyperContext"; index = Obj.magic (); loader = Obj.magic (); filePath = ""; modulePath = ""; packagePath = ""; imports = Obj.magic (); classFullName = "" } : t)

let getIndex = fun self () -> self.index

let getFilePath = fun self () -> self.filePath

let getModulePath = fun self () -> self.modulePath

let getPackagePath = fun self () -> self.packagePath

let getImports = fun self () -> self.imports

let getClassFullName = fun self () -> self.classFullName

let resolveType = fun self (typePath : string) -> try (
  ignore (if self.index == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let hit = TyperIndex.resolveTypePath (self.index) typePath (self.packagePath) (self.imports) in (
    ignore (if hit != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit)) else ());
    let tempResult = ref (Obj.magic ()) in (
      ignore (if self.loader == Obj.magic (HxRuntime.hx_null) then let __assign_19 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_19;
        __assign_19
      ) else let __assign_20 = let __obj_21 = self.loader in __obj_21.ensureTypeAvailable (Obj.magic __obj_21) typePath (self.packagePath) (self.imports) in (
        tempResult := __assign_20;
        __assign_20
      ));
      !tempResult
    )
  )
) with
  | HxRuntime.Hx_return __ret_22 -> Obj.obj __ret_22

let currentClass = fun self () -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxString.length (self.classFullName) = 0 then let __assign_23 = Obj.magic (HxRuntime.hx_null) in (
    tempResult := __assign_23;
    __assign_23
  ) else let __assign_24 = resolveType self (self.classFullName) in (
    tempResult := __assign_24;
    __assign_24
  ));
  !tempResult
)
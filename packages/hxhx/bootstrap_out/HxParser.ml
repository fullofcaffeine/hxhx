# 1 "HxParser.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: HxParser *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable lex : HxLexer.t; mutable cur : HxToken.t; mutable peeked : HxToken.t; mutable capturedReturnStringLiteral : string }

let create = fun source -> let self = ({ __hx_type = HxType.class_ "HxParser"; lex = Obj.magic (); cur = Obj.magic (); peeked = Obj.magic (HxRuntime.hx_null); capturedReturnStringLiteral = "" } : t) in (
  ignore ((
    ignore (let __assign_1 = "" in (
      self.capturedReturnStringLiteral <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = Obj.magic (HxRuntime.hx_null) in (
      self.peeked <- __assign_2;
      __assign_2
    ));
    ignore (let __assign_3 = HxLexer.create source in (
      self.lex <- __assign_3;
      __assign_3
    ));
    let __assign_4 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_4;
      __assign_4
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "HxParser"; lex = Obj.magic (); cur = Obj.magic (); peeked = Obj.magic (HxRuntime.hx_null); capturedReturnStringLiteral = "" } : t)

let bump = fun self () -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
  ignore (let __assign_5 = self.peeked in (
    self.cur <- __assign_5;
    __assign_5
  ));
  let __assign_6 = Obj.magic (HxRuntime.hx_null) in (
    self.peeked <- __assign_6;
    __assign_6
  )
)) else ignore (let __assign_7 = HxLexer.next (self.lex) () in (
  self.cur <- __assign_7;
  __assign_7
)))

let peek = fun self () -> (
  ignore (if self.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_8 = HxLexer.next (self.lex) () in (
    self.peeked <- __assign_8;
    __assign_8
  )) else ());
  self.peeked
)

let peekKind = fun self () -> (
  ignore (if self.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_9 = HxLexer.next (self.lex) () in (
    self.peeked <- __assign_9;
    __assign_9
  )) else ());
  let tempMaybeHxToken = self.peeked in tempMaybeHxToken.kind
)

let fail = fun self (message : string) -> HxType.hx_throw_typed_rtti (Obj.repr (HxParseError.create message (self.cur.pos))) ["Dynamic"; "HxParseError"]

let expect = fun self (kind : HxTokenKind.hxtokenkind) (label : string) -> ignore (let tempBool = ref false in (
  ignore (let _g = self.cur.kind in match _g with
    | HxTokenKind.TEof -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 0 then let __assign_11 = true in (
      tempBool := __assign_11;
      __assign_11
    ) else let __assign_12 = false in (
      tempBool := __assign_12;
      __assign_12
    )
    | HxTokenKind.TKeyword _p0 -> let _g2 = _p0 in if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 5 then let _g1 = _p0 in let b = _g1 in let a = _g2 in let __assign_13 = a = b in (
      tempBool := __assign_13;
      __assign_13
    ) else let __assign_14 = false in (
      tempBool := __assign_14;
      __assign_14
    )
    | HxTokenKind.TLBrace -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 6 then let __assign_15 = true in (
      tempBool := __assign_15;
      __assign_15
    ) else let __assign_16 = false in (
      tempBool := __assign_16;
      __assign_16
    )
    | HxTokenKind.TRBrace -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 7 then let __assign_17 = true in (
      tempBool := __assign_17;
      __assign_17
    ) else let __assign_18 = false in (
      tempBool := __assign_18;
      __assign_18
    )
    | HxTokenKind.TLParen -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 8 then let __assign_19 = true in (
      tempBool := __assign_19;
      __assign_19
    ) else let __assign_20 = false in (
      tempBool := __assign_20;
      __assign_20
    )
    | HxTokenKind.TRParen -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 9 then let __assign_21 = true in (
      tempBool := __assign_21;
      __assign_21
    ) else let __assign_22 = false in (
      tempBool := __assign_22;
      __assign_22
    )
    | HxTokenKind.TSemicolon -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 10 then let __assign_23 = true in (
      tempBool := __assign_23;
      __assign_23
    ) else let __assign_24 = false in (
      tempBool := __assign_24;
      __assign_24
    )
    | HxTokenKind.TColon -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 11 then let __assign_25 = true in (
      tempBool := __assign_25;
      __assign_25
    ) else let __assign_26 = false in (
      tempBool := __assign_26;
      __assign_26
    )
    | HxTokenKind.TDot -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 12 then let __assign_27 = true in (
      tempBool := __assign_27;
      __assign_27
    ) else let __assign_28 = false in (
      tempBool := __assign_28;
      __assign_28
    )
    | HxTokenKind.TComma -> if (match kind with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 13 then let __assign_29 = true in (
      tempBool := __assign_29;
      __assign_29
    ) else let __assign_30 = false in (
      tempBool := __assign_30;
      __assign_30
    )
    | _ -> let __assign_10 = false in (
      tempBool := __assign_10;
      __assign_10
    ));
  let ok = !tempBool in (
    ignore (if not (ok) then ignore (fail self ("Expected " ^ HxString.toStdString label)) else ());
    if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_31 = self.peeked in (
        self.cur <- __assign_31;
        __assign_31
      ));
      let __assign_32 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_32;
        __assign_32
      )
    )) else ignore (let __assign_33 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_33;
      __assign_33
    ))
  )
))

let acceptKeyword = fun self (k : HxKeyword.hxkeyword) -> let tempResult = ref false in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 5 then let _g2 = match _g with
    | HxTokenKind.TKeyword __enum_param_34 -> __enum_param_34
    | _ -> failwith "Unexpected enum parameter" in let kk = _g2 in if kk = k then (
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_35 = self.peeked in (
        self.cur <- __assign_35;
        __assign_35
      ));
      let __assign_36 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_36;
        __assign_36
      )
    )) else ignore (let __assign_37 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_37;
      __assign_37
    )));
    let __assign_38 = true in (
      tempResult := __assign_38;
      __assign_38
    )
  ) else let __assign_39 = false in (
    tempResult := __assign_39;
    __assign_39
  ) else let __assign_40 = false in (
    tempResult := __assign_40;
    __assign_40
  ));
  !tempResult
)

let acceptOtherChar = fun self (ch : string) -> let code = HxString.charCodeAt ch 0 in let tempResult = ref false in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 14 then let _g2 = match _g with
    | HxTokenKind.TOther __enum_param_41 -> __enum_param_41
    | _ -> failwith "Unexpected enum parameter" in let c = _g2 in if let __nullable_42 = code in if __nullable_42 == HxRuntime.hx_null then false else Obj.obj __nullable_42 = c then (
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_43 = self.peeked in (
        self.cur <- __assign_43;
        __assign_43
      ));
      let __assign_44 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_44;
        __assign_44
      )
    )) else ignore (let __assign_45 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_45;
      __assign_45
    )));
    let __assign_46 = true in (
      tempResult := __assign_46;
      __assign_46
    )
  ) else let __assign_47 = false in (
    tempResult := __assign_47;
    __assign_47
  ) else let __assign_48 = false in (
    tempResult := __assign_48;
    __assign_48
  ));
  !tempResult
)

let isOtherChar = fun self (ch : string) -> let code = HxString.charCodeAt ch 0 in let tempResult = ref false in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 14 then let _g2 = match _g with
    | HxTokenKind.TOther __enum_param_49 -> __enum_param_49
    | _ -> failwith "Unexpected enum parameter" in let c = _g2 in if let __nullable_50 = code in if __nullable_50 == HxRuntime.hx_null then false else Obj.obj __nullable_50 = c then let __assign_51 = true in (
    tempResult := __assign_51;
    __assign_51
  ) else let __assign_52 = false in (
    tempResult := __assign_52;
    __assign_52
  ) else let __assign_53 = false in (
    tempResult := __assign_53;
    __assign_53
  ));
  !tempResult
)

let readIdent = fun self (label : string) -> let tempResult = ref "" in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 1 then let _g2 = match _g with
    | HxTokenKind.TIdent __enum_param_54 -> __enum_param_54
    | _ -> failwith "Unexpected enum parameter" in let name = _g2 in (
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_55 = self.peeked in (
        self.cur <- __assign_55;
        __assign_55
      ));
      let __assign_56 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_56;
        __assign_56
      )
    )) else ignore (let __assign_57 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_57;
      __assign_57
    )));
    let __assign_58 = name in (
      tempResult := __assign_58;
      __assign_58
    )
  ) else let __assign_59 = fail self ("Expected " ^ HxString.toStdString label) in (
    tempResult := __assign_59;
    __assign_59
  ));
  !tempResult
)

let readDottedPath = fun self () -> let parts = HxArray.create () in (
  ignore (HxArray.push parts (readIdent self "identifier"));
  ignore (try while true do try ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 12 then ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_60 = self.peeked in (
        self.cur <- __assign_60;
        __assign_60
      ));
      let __assign_61 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_61;
        __assign_61
      )
    )) else ignore (let __assign_62 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_62;
      __assign_62
    )));
    HxArray.push parts (readIdent self "identifier")
  )) else raise (HxRuntime.Hx_break)) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  HxArray.join parts "." (fun x -> x)
)

let readImportPath = fun self () -> let parts = HxArray.create () in (
  ignore (HxArray.push parts (readIdent self "identifier"));
  ignore (try while true do try ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 12 then ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_63 = self.peeked in (
        self.cur <- __assign_63;
        __assign_63
      ));
      let __assign_64 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_64;
        __assign_64
      )
    )) else ignore (let __assign_65 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_65;
      __assign_65
    )));
    ignore (if acceptOtherChar self "*" then ignore ((
      ignore (HxArray.push parts "*");
      raise (HxRuntime.Hx_break)
    )) else ());
    HxArray.push parts (readIdent self "identifier")
  )) else raise (HxRuntime.Hx_break)) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  HxArray.join parts "." (fun x -> x)
)

let skipBalancedParens = fun self () -> ignore (let depth = ref 1 in while !depth > 0 do ignore (let _g = self.cur.kind in match _g with
  | HxTokenKind.TEof -> ignore (fail self "Unterminated parenthesis group")
  | HxTokenKind.TLParen -> ignore ((
    ignore (let __old_69 = !depth in let __new_70 = HxInt.add __old_69 1 in (
      ignore (depth := __new_70);
      __old_69
    ));
    if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_71 = self.peeked in (
        self.cur <- __assign_71;
        __assign_71
      ));
      let __assign_72 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_72;
        __assign_72
      )
    )) else ignore (let __assign_73 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_73;
      __assign_73
    ))
  ))
  | HxTokenKind.TRParen -> ignore ((
    ignore (let __old_74 = !depth in let __new_75 = HxInt.add __old_74 (-1) in (
      ignore (depth := __new_75);
      __old_74
    ));
    if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_76 = self.peeked in (
        self.cur <- __assign_76;
        __assign_76
      ));
      let __assign_77 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_77;
        __assign_77
      )
    )) else ignore (let __assign_78 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_78;
      __assign_78
    ))
  ))
  | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
    ignore (let __assign_66 = self.peeked in (
      self.cur <- __assign_66;
      __assign_66
    ));
    let __assign_67 = Obj.magic (HxRuntime.hx_null) in (
      self.peeked <- __assign_67;
      __assign_67
    )
  )) else ignore (let __assign_68 = HxLexer.next (self.lex) () in (
    self.cur <- __assign_68;
    __assign_68
  )))) done)

let skipBalancedBraces = fun self () -> ignore (let depth = ref 1 in while !depth > 0 do ignore (let _g = self.cur.kind in match _g with
  | HxTokenKind.TEof -> ignore (fail self "Unterminated brace block")
  | HxTokenKind.TLBrace -> ignore ((
    ignore (let __old_82 = !depth in let __new_83 = HxInt.add __old_82 1 in (
      ignore (depth := __new_83);
      __old_82
    ));
    if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_84 = self.peeked in (
        self.cur <- __assign_84;
        __assign_84
      ));
      let __assign_85 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_85;
        __assign_85
      )
    )) else ignore (let __assign_86 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_86;
      __assign_86
    ))
  ))
  | HxTokenKind.TRBrace -> ignore ((
    ignore (let __old_87 = !depth in let __new_88 = HxInt.add __old_87 (-1) in (
      ignore (depth := __new_88);
      __old_87
    ));
    if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_89 = self.peeked in (
        self.cur <- __assign_89;
        __assign_89
      ));
      let __assign_90 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_90;
        __assign_90
      )
    )) else ignore (let __assign_91 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_91;
      __assign_91
    ))
  ))
  | HxTokenKind.TLParen -> ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_92 = self.peeked in (
        self.cur <- __assign_92;
        __assign_92
      ));
      let __assign_93 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_93;
        __assign_93
      )
    )) else ignore (let __assign_94 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_94;
      __assign_94
    )));
    skipBalancedParens self ()
  ))
  | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
    ignore (let __assign_79 = self.peeked in (
      self.cur <- __assign_79;
      __assign_79
    ));
    let __assign_80 = Obj.magic (HxRuntime.hx_null) in (
      self.peeked <- __assign_80;
      __assign_80
    )
  )) else ignore (let __assign_81 = HxLexer.next (self.lex) () in (
    self.cur <- __assign_81;
    __assign_81
  )))) done)

let readTypeHintText = fun self (stop : unit -> bool) -> let parts = HxArray.create () in (
  ignore (try while not (stop ()) do try ignore (let _g = self.cur.kind in match _g with
    | HxTokenKind.TEof -> raise (HxRuntime.Hx_break)
    | HxTokenKind.TIdent _p0 -> ignore (let _g2 = _p0 in let name = _g2 in (
      ignore (HxArray.push parts name);
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_95 = self.peeked in (
          self.cur <- __assign_95;
          __assign_95
        ));
        let __assign_96 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_96;
          __assign_96
        )
      )) else ignore (let __assign_97 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_97;
        __assign_97
      ))
    ))
    | HxTokenKind.TString _p0 -> ignore (let _g2 = _p0 in let s = _g2 in (
      ignore (HxArray.push parts (("\"" ^ HxString.toStdString s) ^ "\""));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_98 = self.peeked in (
          self.cur <- __assign_98;
          __assign_98
        ));
        let __assign_99 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_99;
          __assign_99
        )
      )) else ignore (let __assign_100 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_100;
        __assign_100
      ))
    ))
    | HxTokenKind.TInt _p0 -> ignore (let _g2 = _p0 in let v = _g2 in (
      ignore (HxArray.push parts (string_of_int v));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_101 = self.peeked in (
          self.cur <- __assign_101;
          __assign_101
        ));
        let __assign_102 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_102;
          __assign_102
        )
      )) else ignore (let __assign_103 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_103;
        __assign_103
      ))
    ))
    | HxTokenKind.TFloat _p0 -> ignore (let _g2 = _p0 in let v = _g2 in (
      ignore (HxArray.push parts (string_of_float v));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_104 = self.peeked in (
          self.cur <- __assign_104;
          __assign_104
        ));
        let __assign_105 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_105;
          __assign_105
        )
      )) else ignore (let __assign_106 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_106;
        __assign_106
      ))
    ))
    | HxTokenKind.TKeyword _p0 -> ignore (let _g2 = _p0 in let k = _g2 in (
      ignore (HxArray.push parts (HxRuntime.dynamic_toStdString (Obj.repr k)));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_107 = self.peeked in (
          self.cur <- __assign_107;
          __assign_107
        ));
        let __assign_108 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_108;
          __assign_108
        )
      )) else ignore (let __assign_109 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_109;
        __assign_109
      ))
    ))
    | HxTokenKind.TLBrace -> ignore ((
      ignore (HxArray.push parts "{");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_110 = self.peeked in (
          self.cur <- __assign_110;
          __assign_110
        ));
        let __assign_111 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_111;
          __assign_111
        )
      )) else ignore (let __assign_112 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_112;
        __assign_112
      ))
    ))
    | HxTokenKind.TRBrace -> ignore ((
      ignore (HxArray.push parts "}");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_113 = self.peeked in (
          self.cur <- __assign_113;
          __assign_113
        ));
        let __assign_114 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_114;
          __assign_114
        )
      )) else ignore (let __assign_115 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_115;
        __assign_115
      ))
    ))
    | HxTokenKind.TLParen -> ignore ((
      ignore (HxArray.push parts "(");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_116 = self.peeked in (
          self.cur <- __assign_116;
          __assign_116
        ));
        let __assign_117 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_117;
          __assign_117
        )
      )) else ignore (let __assign_118 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_118;
        __assign_118
      ))
    ))
    | HxTokenKind.TRParen -> ignore ((
      ignore (HxArray.push parts ")");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_119 = self.peeked in (
          self.cur <- __assign_119;
          __assign_119
        ));
        let __assign_120 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_120;
          __assign_120
        )
      )) else ignore (let __assign_121 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_121;
        __assign_121
      ))
    ))
    | HxTokenKind.TSemicolon -> ignore ((
      ignore (HxArray.push parts ";");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_122 = self.peeked in (
          self.cur <- __assign_122;
          __assign_122
        ));
        let __assign_123 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_123;
          __assign_123
        )
      )) else ignore (let __assign_124 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_124;
        __assign_124
      ))
    ))
    | HxTokenKind.TColon -> ignore ((
      ignore (HxArray.push parts ":");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_125 = self.peeked in (
          self.cur <- __assign_125;
          __assign_125
        ));
        let __assign_126 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_126;
          __assign_126
        )
      )) else ignore (let __assign_127 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_127;
        __assign_127
      ))
    ))
    | HxTokenKind.TDot -> ignore ((
      ignore (HxArray.push parts ".");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_128 = self.peeked in (
          self.cur <- __assign_128;
          __assign_128
        ));
        let __assign_129 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_129;
          __assign_129
        )
      )) else ignore (let __assign_130 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_130;
        __assign_130
      ))
    ))
    | HxTokenKind.TComma -> ignore ((
      ignore (HxArray.push parts ",");
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_131 = self.peeked in (
          self.cur <- __assign_131;
          __assign_131
        ));
        let __assign_132 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_132;
          __assign_132
        )
      )) else ignore (let __assign_133 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_133;
        __assign_133
      ))
    ))
    | HxTokenKind.TOther _p0 -> ignore (let _g2 = _p0 in let c = _g2 in (
      ignore (HxArray.push parts (HxString.fromCharCode c));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_134 = self.peeked in (
          self.cur <- __assign_134;
          __assign_134
        ));
        let __assign_135 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_135;
          __assign_135
        )
      )) else ignore (let __assign_136 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_136;
        __assign_136
      ))
    ))) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  HxArray.join parts "" (fun x -> x)
)

let peekBinop = fun self (stop : unit -> bool) -> try let _gthis = self in (
  ignore (if stop () then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 14 then let _g2 = match _g with
      | HxTokenKind.TOther __enum_param_249 -> __enum_param_249
      | _ -> failwith "Unexpected enum parameter" in let c = _g2 in match c with
      | 33 -> let tempBool = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_251 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_251;
            __assign_251
          )) else ());
          let tempMaybeHxToken = _gthis.peeked in let _g3 = tempMaybeHxToken.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_252 -> __enum_param_252
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 61 then let __assign_253 = true in (
            tempBool := __assign_253;
            __assign_253
          ) else let __assign_254 = false in (
            tempBool := __assign_254;
            __assign_254
          ) else let __assign_255 = false in (
            tempBool := __assign_255;
            __assign_255
          )
        ));
        if !tempBool then let __assign_256 = let __anon_257 = HxAnon.create () in (
          ignore (HxAnon.set __anon_257 "op" (Obj.repr "!="));
          ignore (HxAnon.set __anon_257 "len" (Obj.repr 2));
          __anon_257
        ) in (
          tempResult := __assign_256;
          __assign_256
        ) else let __assign_258 = HxRuntime.hx_null in (
          tempResult := __assign_258;
          __assign_258
        )
      )
      | 37 -> let __assign_259 = let __anon_260 = HxAnon.create () in (
        ignore (HxAnon.set __anon_260 "op" (Obj.repr "%"));
        ignore (HxAnon.set __anon_260 "len" (Obj.repr 1));
        __anon_260
      ) in (
        tempResult := __assign_259;
        __assign_259
      )
      | 38 -> let tempBool1 = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_261 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_261;
            __assign_261
          )) else ());
          let tempMaybeHxToken1 = _gthis.peeked in let _g3 = tempMaybeHxToken1.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_262 -> __enum_param_262
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 38 then let __assign_263 = true in (
            tempBool1 := __assign_263;
            __assign_263
          ) else let __assign_264 = false in (
            tempBool1 := __assign_264;
            __assign_264
          ) else let __assign_265 = false in (
            tempBool1 := __assign_265;
            __assign_265
          )
        ));
        if !tempBool1 then let __assign_266 = let __anon_267 = HxAnon.create () in (
          ignore (HxAnon.set __anon_267 "op" (Obj.repr "&&"));
          ignore (HxAnon.set __anon_267 "len" (Obj.repr 2));
          __anon_267
        ) in (
          tempResult := __assign_266;
          __assign_266
        ) else let __assign_268 = let __anon_269 = HxAnon.create () in (
          ignore (HxAnon.set __anon_269 "op" (Obj.repr "&"));
          ignore (HxAnon.set __anon_269 "len" (Obj.repr 1));
          __anon_269
        ) in (
          tempResult := __assign_268;
          __assign_268
        )
      )
      | 42 -> let __assign_270 = let __anon_271 = HxAnon.create () in (
        ignore (HxAnon.set __anon_271 "op" (Obj.repr "*"));
        ignore (HxAnon.set __anon_271 "len" (Obj.repr 1));
        __anon_271
      ) in (
        tempResult := __assign_270;
        __assign_270
      )
      | 43 -> let __assign_272 = let __anon_273 = HxAnon.create () in (
        ignore (HxAnon.set __anon_273 "op" (Obj.repr "+"));
        ignore (HxAnon.set __anon_273 "len" (Obj.repr 1));
        __anon_273
      ) in (
        tempResult := __assign_272;
        __assign_272
      )
      | 45 -> let __assign_274 = let __anon_275 = HxAnon.create () in (
        ignore (HxAnon.set __anon_275 "op" (Obj.repr "-"));
        ignore (HxAnon.set __anon_275 "len" (Obj.repr 1));
        __anon_275
      ) in (
        tempResult := __assign_274;
        __assign_274
      )
      | 47 -> let __assign_276 = let __anon_277 = HxAnon.create () in (
        ignore (HxAnon.set __anon_277 "op" (Obj.repr "/"));
        ignore (HxAnon.set __anon_277 "len" (Obj.repr 1));
        __anon_277
      ) in (
        tempResult := __assign_276;
        __assign_276
      )
      | 60 -> let tempBool2 = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_278 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_278;
            __assign_278
          )) else ());
          let tempMaybeHxToken2 = _gthis.peeked in let _g3 = tempMaybeHxToken2.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_279 -> __enum_param_279
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 61 then let __assign_280 = true in (
            tempBool2 := __assign_280;
            __assign_280
          ) else let __assign_281 = false in (
            tempBool2 := __assign_281;
            __assign_281
          ) else let __assign_282 = false in (
            tempBool2 := __assign_282;
            __assign_282
          )
        ));
        if !tempBool2 then let __assign_283 = let __anon_284 = HxAnon.create () in (
          ignore (HxAnon.set __anon_284 "op" (Obj.repr "<="));
          ignore (HxAnon.set __anon_284 "len" (Obj.repr 2));
          __anon_284
        ) in (
          tempResult := __assign_283;
          __assign_283
        ) else let __assign_285 = let __anon_286 = HxAnon.create () in (
          ignore (HxAnon.set __anon_286 "op" (Obj.repr "<"));
          ignore (HxAnon.set __anon_286 "len" (Obj.repr 1));
          __anon_286
        ) in (
          tempResult := __assign_285;
          __assign_285
        )
      )
      | 61 -> let tempBool3 = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_287 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_287;
            __assign_287
          )) else ());
          let tempMaybeHxToken3 = _gthis.peeked in let _g3 = tempMaybeHxToken3.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_288 -> __enum_param_288
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 61 then let __assign_289 = true in (
            tempBool3 := __assign_289;
            __assign_289
          ) else let __assign_290 = false in (
            tempBool3 := __assign_290;
            __assign_290
          ) else let __assign_291 = false in (
            tempBool3 := __assign_291;
            __assign_291
          )
        ));
        if !tempBool3 then let __assign_292 = let __anon_293 = HxAnon.create () in (
          ignore (HxAnon.set __anon_293 "op" (Obj.repr "=="));
          ignore (HxAnon.set __anon_293 "len" (Obj.repr 2));
          __anon_293
        ) in (
          tempResult := __assign_292;
          __assign_292
        ) else let __assign_294 = let __anon_295 = HxAnon.create () in (
          ignore (HxAnon.set __anon_295 "op" (Obj.repr "="));
          ignore (HxAnon.set __anon_295 "len" (Obj.repr 1));
          __anon_295
        ) in (
          tempResult := __assign_294;
          __assign_294
        )
      )
      | 62 -> let tempBool4 = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_296 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_296;
            __assign_296
          )) else ());
          let tempMaybeHxToken4 = _gthis.peeked in let _g3 = tempMaybeHxToken4.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_297 -> __enum_param_297
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 61 then let __assign_298 = true in (
            tempBool4 := __assign_298;
            __assign_298
          ) else let __assign_299 = false in (
            tempBool4 := __assign_299;
            __assign_299
          ) else let __assign_300 = false in (
            tempBool4 := __assign_300;
            __assign_300
          )
        ));
        if !tempBool4 then let __assign_301 = let __anon_302 = HxAnon.create () in (
          ignore (HxAnon.set __anon_302 "op" (Obj.repr ">="));
          ignore (HxAnon.set __anon_302 "len" (Obj.repr 2));
          __anon_302
        ) in (
          tempResult := __assign_301;
          __assign_301
        ) else let __assign_303 = let __anon_304 = HxAnon.create () in (
          ignore (HxAnon.set __anon_304 "op" (Obj.repr ">"));
          ignore (HxAnon.set __anon_304 "len" (Obj.repr 1));
          __anon_304
        ) in (
          tempResult := __assign_303;
          __assign_303
        )
      )
      | 124 -> let tempBool5 = ref false in (
        ignore ((
          ignore (if _gthis.peeked == Obj.magic (HxRuntime.hx_null) then ignore (let __assign_305 = HxLexer.next (_gthis.lex) () in (
            _gthis.peeked <- __assign_305;
            __assign_305
          )) else ());
          let tempMaybeHxToken5 = _gthis.peeked in let _g3 = tempMaybeHxToken5.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 14 then let _g4 = match _g3 with
            | HxTokenKind.TOther __enum_param_306 -> __enum_param_306
            | _ -> failwith "Unexpected enum parameter" in let c2 = _g4 in if c2 = 124 then let __assign_307 = true in (
            tempBool5 := __assign_307;
            __assign_307
          ) else let __assign_308 = false in (
            tempBool5 := __assign_308;
            __assign_308
          ) else let __assign_309 = false in (
            tempBool5 := __assign_309;
            __assign_309
          )
        ));
        if !tempBool5 then let __assign_310 = let __anon_311 = HxAnon.create () in (
          ignore (HxAnon.set __anon_311 "op" (Obj.repr "||"));
          ignore (HxAnon.set __anon_311 "len" (Obj.repr 2));
          __anon_311
        ) in (
          tempResult := __assign_310;
          __assign_310
        ) else let __assign_312 = let __anon_313 = HxAnon.create () in (
          ignore (HxAnon.set __anon_313 "op" (Obj.repr "|"));
          ignore (HxAnon.set __anon_313 "len" (Obj.repr 1));
          __anon_313
        ) in (
          tempResult := __assign_312;
          __assign_312
        )
      )
      | _ -> let __assign_250 = HxRuntime.hx_null in (
        tempResult := __assign_250;
        __assign_250
      ) else let __assign_314 = HxRuntime.hx_null in (
      tempResult := __assign_314;
      __assign_314
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_315 -> Obj.obj __ret_315

let consumeBinop = fun self (len : int) -> ignore (let _g = ref 0 in let _g1 = len in while !_g < _g1 do ignore ((
  ignore (let __old_316 = !_g in let __new_317 = HxInt.add __old_316 1 in (
    ignore (_g := __new_317);
    __old_316
  ));
  if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
    ignore (let __assign_318 = self.peeked in (
      self.cur <- __assign_318;
      __assign_318
    ));
    let __assign_319 = Obj.magic (HxRuntime.hx_null) in (
      self.peeked <- __assign_319;
      __assign_319
    )
  )) else ignore (let __assign_320 = HxLexer.next (self.lex) () in (
    self.cur <- __assign_320;
    __assign_320
  ))
)) done)

let syncToStmtEnd = fun self () -> ignore (try (
  ignore (try while true do try ignore (let tempBool = ref false in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 10 then let __assign_340 = true in (
      tempBool := __assign_340;
      __assign_340
    ) else let __assign_341 = false in (
      tempBool := __assign_341;
      __assign_341
    ));
    let tempBool1 = ref false in (
      ignore (let _g = self.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 7 then let __assign_342 = true in (
        tempBool1 := __assign_342;
        __assign_342
      ) else let __assign_343 = false in (
        tempBool1 := __assign_343;
        __assign_343
      ));
      let tempBool2 = ref false in (
        ignore (let _g = self.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 0 then let __assign_344 = true in (
          tempBool2 := __assign_344;
          __assign_344
        ) else let __assign_345 = false in (
          tempBool2 := __assign_345;
          __assign_345
        ));
        ignore (if not (not (!tempBool) && not (!tempBool1) && not (!tempBool2)) then raise (HxRuntime.Hx_break) else ());
        let _g = self.cur.kind in match _g with
          | HxTokenKind.TLBrace -> raise (HxRuntime.Hx_return (Obj.repr ()))
          | HxTokenKind.TLParen -> ignore ((
            ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
              ignore (let __assign_349 = self.peeked in (
                self.cur <- __assign_349;
                __assign_349
              ));
              let __assign_350 = Obj.magic (HxRuntime.hx_null) in (
                self.peeked <- __assign_350;
                __assign_350
              )
            )) else ignore (let __assign_351 = HxLexer.next (self.lex) () in (
              self.cur <- __assign_351;
              __assign_351
            )));
            skipBalancedParens self ()
          ))
          | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_346 = self.peeked in (
              self.cur <- __assign_346;
              __assign_346
            ));
            let __assign_347 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_347;
              __assign_347
            )
          )) else ignore (let __assign_348 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_348;
            __assign_348
          )))
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let tempBool3 = ref false in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 10 then let __assign_352 = true in (
      tempBool3 := __assign_352;
      __assign_352
    ) else let __assign_353 = false in (
      tempBool3 := __assign_353;
      __assign_353
    ));
    if !tempBool3 then ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_354 = self.peeked in (
        self.cur <- __assign_354;
        __assign_354
      ));
      let __assign_355 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_355;
        __assign_355
      )
    )) else ignore (let __assign_356 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_356;
      __assign_356
    ))) else ()
  )
) with
  | HxRuntime.Hx_return __ret_357 -> Obj.obj __ret_357)

let binopPrec = fun op -> let tempResult = ref 0 in (
  ignore (match op with
    | "!=" | "==" -> let __assign_580 = 4 in (
      tempResult := __assign_580;
      __assign_580
    )
    | "%" | "*" | "/" -> let __assign_581 = 7 in (
      tempResult := __assign_581;
      __assign_581
    )
    | "&" -> let __assign_582 = 3 in (
      tempResult := __assign_582;
      __assign_582
    )
    | "&&" -> let __assign_583 = 3 in (
      tempResult := __assign_583;
      __assign_583
    )
    | "+" | "-" -> let __assign_584 = 6 in (
      tempResult := __assign_584;
      __assign_584
    )
    | "=" -> let __assign_585 = 1 in (
      tempResult := __assign_585;
      __assign_585
    )
    | "<" | "<=" | ">" | ">=" -> let __assign_586 = 5 in (
      tempResult := __assign_586;
      __assign_586
    )
    | "|" -> let __assign_587 = 2 in (
      tempResult := __assign_587;
      __assign_587
    )
    | "||" -> let __assign_588 = 2 in (
      tempResult := __assign_588;
      __assign_588
    )
    | _ -> let __assign_579 = 0 in (
      tempResult := __assign_579;
      __assign_579
    ));
  !tempResult
)

let isRightAssoc = fun op -> HxString.equals op "="

let rec parsePrimaryExpr = fun self () -> let _gthis = self in let tempResult = ref (Obj.magic ()) in (
  ignore (let _g = self.cur.kind in match _g with
    | HxTokenKind.TIdent _p0 -> let _g2 = _p0 in let name = _g2 in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_141 = self.peeked in (
          self.cur <- __assign_141;
          __assign_141
        ));
        let __assign_142 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_142;
          __assign_142
        )
      )) else ignore (let __assign_143 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_143;
        __assign_143
      )));
      let __assign_144 = HxExpr.EIdent name in (
        tempResult := __assign_144;
        __assign_144
      )
    )
    | HxTokenKind.TString _p0 -> let _g2 = _p0 in let s = _g2 in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_145 = self.peeked in (
          self.cur <- __assign_145;
          __assign_145
        ));
        let __assign_146 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_146;
          __assign_146
        )
      )) else ignore (let __assign_147 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_147;
        __assign_147
      )));
      let __assign_148 = HxExpr.EString s in (
        tempResult := __assign_148;
        __assign_148
      )
    )
    | HxTokenKind.TInt _p0 -> let _g2 = _p0 in let v = _g2 in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_149 = self.peeked in (
          self.cur <- __assign_149;
          __assign_149
        ));
        let __assign_150 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_150;
          __assign_150
        )
      )) else ignore (let __assign_151 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_151;
        __assign_151
      )));
      let __assign_152 = HxExpr.EInt v in (
        tempResult := __assign_152;
        __assign_152
      )
    )
    | HxTokenKind.TFloat _p0 -> let _g2 = _p0 in let v = _g2 in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_153 = self.peeked in (
          self.cur <- __assign_153;
          __assign_153
        ));
        let __assign_154 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_154;
          __assign_154
        )
      )) else ignore (let __assign_155 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_155;
        __assign_155
      )));
      let __assign_156 = HxExpr.EFloat v in (
        tempResult := __assign_156;
        __assign_156
      )
    )
    | HxTokenKind.TKeyword _p0 -> let _g2 = _p0 in let k = _g2 in if k = HxKeyword.KNull then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_157 = self.peeked in (
          self.cur <- __assign_157;
          __assign_157
        ));
        let __assign_158 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_158;
          __assign_158
        )
      )) else ignore (let __assign_159 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_159;
        __assign_159
      )));
      let __assign_160 = HxExpr.ENull in (
        tempResult := __assign_160;
        __assign_160
      )
    ) else if k = HxKeyword.KTrue then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_161 = self.peeked in (
          self.cur <- __assign_161;
          __assign_161
        ));
        let __assign_162 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_162;
          __assign_162
        )
      )) else ignore (let __assign_163 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_163;
        __assign_163
      )));
      let __assign_164 = HxExpr.EBool true in (
        tempResult := __assign_164;
        __assign_164
      )
    ) else if k = HxKeyword.KFalse then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_165 = self.peeked in (
          self.cur <- __assign_165;
          __assign_165
        ));
        let __assign_166 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_166;
          __assign_166
        )
      )) else ignore (let __assign_167 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_167;
        __assign_167
      )));
      let __assign_168 = HxExpr.EBool false in (
        tempResult := __assign_168;
        __assign_168
      )
    ) else if k = HxKeyword.KThis then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_169 = self.peeked in (
          self.cur <- __assign_169;
          __assign_169
        ));
        let __assign_170 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_170;
          __assign_170
        )
      )) else ignore (let __assign_171 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_171;
        __assign_171
      )));
      let __assign_172 = HxExpr.EThis in (
        tempResult := __assign_172;
        __assign_172
      )
    ) else if k = HxKeyword.KSuper then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_173 = self.peeked in (
          self.cur <- __assign_173;
          __assign_173
        ));
        let __assign_174 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_174;
          __assign_174
        )
      )) else ignore (let __assign_175 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_175;
        __assign_175
      )));
      let __assign_176 = HxExpr.ESuper in (
        tempResult := __assign_176;
        __assign_176
      )
    ) else if k = HxKeyword.KNew then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_177 = self.peeked in (
          self.cur <- __assign_177;
          __assign_177
        ));
        let __assign_178 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_178;
          __assign_178
        )
      )) else ignore (let __assign_179 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_179;
        __assign_179
      )));
      let typePath = readDottedPath self () in let tempBool = ref false in (
        ignore (let _g3 = self.cur.kind in if (match _g3 with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 8 then let __assign_180 = true in (
          tempBool := __assign_180;
          __assign_180
        ) else let __assign_181 = false in (
          tempBool := __assign_181;
          __assign_181
        ));
        if not (!tempBool) then let __assign_182 = HxExpr.ENew (typePath, (let __arr_183 = HxArray.create () in __arr_183)) in (
          tempResult := __assign_182;
          __assign_182
        ) else (
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_184 = self.peeked in (
              self.cur <- __assign_184;
              __assign_184
            ));
            let __assign_185 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_185;
              __assign_185
            )
          )) else ignore (let __assign_186 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_186;
            __assign_186
          )));
          let args = HxArray.create () in let tempBool1 = ref false in (
            ignore (let _g3 = self.cur.kind in if (match _g3 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 9 then let __assign_187 = true in (
              tempBool1 := __assign_187;
              __assign_187
            ) else let __assign_188 = false in (
              tempBool1 := __assign_188;
              __assign_188
            ));
            if !tempBool1 then (
              ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
                ignore (let __assign_189 = self.peeked in (
                  self.cur <- __assign_189;
                  __assign_189
                ));
                let __assign_190 = Obj.magic (HxRuntime.hx_null) in (
                  self.peeked <- __assign_190;
                  __assign_190
                )
              )) else ignore (let __assign_191 = HxLexer.next (self.lex) () in (
                self.cur <- __assign_191;
                __assign_191
              )));
              let __assign_192 = HxExpr.ENew (typePath, args) in (
                tempResult := __assign_192;
                __assign_192
              )
            ) else (
              ignore (try while true do try ignore (let arg = parseExpr self (fun () -> let tempLeft = ref false in (
                ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
                  | HxTokenKind.TEof -> 0
                  | HxTokenKind.TIdent _ -> 1
                  | HxTokenKind.TString _ -> 2
                  | HxTokenKind.TInt _ -> 3
                  | HxTokenKind.TFloat _ -> 4
                  | HxTokenKind.TKeyword _ -> 5
                  | HxTokenKind.TLBrace -> 6
                  | HxTokenKind.TRBrace -> 7
                  | HxTokenKind.TLParen -> 8
                  | HxTokenKind.TRParen -> 9
                  | HxTokenKind.TSemicolon -> 10
                  | HxTokenKind.TColon -> 11
                  | HxTokenKind.TDot -> 12
                  | HxTokenKind.TComma -> 13
                  | HxTokenKind.TOther _ -> 14) = 13 then let __assign_193 = true in (
                  tempLeft := __assign_193;
                  __assign_193
                ) else let __assign_194 = false in (
                  tempLeft := __assign_194;
                  __assign_194
                ));
                let tempRight = ref false in (
                  ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
                    | HxTokenKind.TEof -> 0
                    | HxTokenKind.TIdent _ -> 1
                    | HxTokenKind.TString _ -> 2
                    | HxTokenKind.TInt _ -> 3
                    | HxTokenKind.TFloat _ -> 4
                    | HxTokenKind.TKeyword _ -> 5
                    | HxTokenKind.TLBrace -> 6
                    | HxTokenKind.TRBrace -> 7
                    | HxTokenKind.TLParen -> 8
                    | HxTokenKind.TRParen -> 9
                    | HxTokenKind.TSemicolon -> 10
                    | HxTokenKind.TColon -> 11
                    | HxTokenKind.TDot -> 12
                    | HxTokenKind.TComma -> 13
                    | HxTokenKind.TOther _ -> 14) = 9 then let __assign_195 = true in (
                    tempRight := __assign_195;
                    __assign_195
                  ) else let __assign_196 = false in (
                    tempRight := __assign_196;
                    __assign_196
                  ));
                  let tempRight1 = ref false in (
                    ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
                      | HxTokenKind.TEof -> 0
                      | HxTokenKind.TIdent _ -> 1
                      | HxTokenKind.TString _ -> 2
                      | HxTokenKind.TInt _ -> 3
                      | HxTokenKind.TFloat _ -> 4
                      | HxTokenKind.TKeyword _ -> 5
                      | HxTokenKind.TLBrace -> 6
                      | HxTokenKind.TRBrace -> 7
                      | HxTokenKind.TLParen -> 8
                      | HxTokenKind.TRParen -> 9
                      | HxTokenKind.TSemicolon -> 10
                      | HxTokenKind.TColon -> 11
                      | HxTokenKind.TDot -> 12
                      | HxTokenKind.TComma -> 13
                      | HxTokenKind.TOther _ -> 14) = 0 then let __assign_197 = true in (
                      tempRight1 := __assign_197;
                      __assign_197
                    ) else let __assign_198 = false in (
                      tempRight1 := __assign_198;
                      __assign_198
                    ));
                    !tempLeft || !tempRight || !tempRight1
                  )
                )
              )) in (
                ignore (HxArray.push args arg);
                let tempBool2 = ref false in (
                  ignore (let _g3 = self.cur.kind in if (match _g3 with
                    | HxTokenKind.TEof -> 0
                    | HxTokenKind.TIdent _ -> 1
                    | HxTokenKind.TString _ -> 2
                    | HxTokenKind.TInt _ -> 3
                    | HxTokenKind.TFloat _ -> 4
                    | HxTokenKind.TKeyword _ -> 5
                    | HxTokenKind.TLBrace -> 6
                    | HxTokenKind.TRBrace -> 7
                    | HxTokenKind.TLParen -> 8
                    | HxTokenKind.TRParen -> 9
                    | HxTokenKind.TSemicolon -> 10
                    | HxTokenKind.TColon -> 11
                    | HxTokenKind.TDot -> 12
                    | HxTokenKind.TComma -> 13
                    | HxTokenKind.TOther _ -> 14) = 13 then let __assign_199 = true in (
                    tempBool2 := __assign_199;
                    __assign_199
                  ) else let __assign_200 = false in (
                    tempBool2 := __assign_200;
                    __assign_200
                  ));
                  ignore (if !tempBool2 then ignore ((
                    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
                      ignore (let __assign_201 = self.peeked in (
                        self.cur <- __assign_201;
                        __assign_201
                      ));
                      let __assign_202 = Obj.magic (HxRuntime.hx_null) in (
                        self.peeked <- __assign_202;
                        __assign_202
                      )
                    )) else ignore (let __assign_203 = HxLexer.next (self.lex) () in (
                      self.cur <- __assign_203;
                      __assign_203
                    )));
                    raise (HxRuntime.Hx_continue)
                  )) else ());
                  ignore (expect self (HxTokenKind.TRParen) "')'");
                  raise (HxRuntime.Hx_break)
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              let __assign_204 = HxExpr.ENew (typePath, args) in (
                tempResult := __assign_204;
                __assign_204
              )
            )
          )
        )
      )
    ) else if k = HxKeyword.KCast || k = HxKeyword.KUntyped then let raw = HxRuntime.dynamic_toStdString (Obj.repr k) in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_205 = self.peeked in (
          self.cur <- __assign_205;
          __assign_205
        ));
        let __assign_206 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_206;
          __assign_206
        )
      )) else ignore (let __assign_207 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_207;
        __assign_207
      )));
      let __assign_208 = HxExpr.EUnsupported raw in (
        tempResult := __assign_208;
        __assign_208
      )
    ) else let raw = HxRuntime.dynamic_toStdString (Obj.repr k) in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_209 = self.peeked in (
          self.cur <- __assign_209;
          __assign_209
        ));
        let __assign_210 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_210;
          __assign_210
        )
      )) else ignore (let __assign_211 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_211;
        __assign_211
      )));
      let __assign_212 = HxExpr.EUnsupported raw in (
        tempResult := __assign_212;
        __assign_212
      )
    )
    | HxTokenKind.TOther _p0 -> let _g2 = _p0 in let c = _g2 in let raw = HxString.fromCharCode c in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_213 = self.peeked in (
          self.cur <- __assign_213;
          __assign_213
        ));
        let __assign_214 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_214;
          __assign_214
        )
      )) else ignore (let __assign_215 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_215;
        __assign_215
      )));
      let __assign_216 = HxExpr.EUnsupported raw in (
        tempResult := __assign_216;
        __assign_216
      )
    )
    | _ -> let raw = HxRuntime.dynamic_toStdString (Obj.repr (self.cur.kind)) in (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_137 = self.peeked in (
          self.cur <- __assign_137;
          __assign_137
        ));
        let __assign_138 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_138;
          __assign_138
        )
      )) else ignore (let __assign_139 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_139;
        __assign_139
      )));
      let __assign_140 = HxExpr.EUnsupported raw in (
        tempResult := __assign_140;
        __assign_140
      )
    ));
  !tempResult
)
and parsePostfixExpr = fun self (stop : unit -> bool) -> let _gthis = self in let e = ref (parsePrimaryExpr self ()) in (
  ignore (try while not (stop ()) do try ignore (let _g = self.cur.kind in match _g with
    | HxTokenKind.TLParen -> ignore ((
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_217 = self.peeked in (
          self.cur <- __assign_217;
          __assign_217
        ));
        let __assign_218 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_218;
          __assign_218
        )
      )) else ignore (let __assign_219 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_219;
        __assign_219
      )));
      let args = HxArray.create () in let tempBool = ref false in (
        ignore (let _g2 = self.cur.kind in if (match _g2 with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 9 then let __assign_220 = true in (
          tempBool := __assign_220;
          __assign_220
        ) else let __assign_221 = false in (
          tempBool := __assign_221;
          __assign_221
        ));
        ignore (if !tempBool then ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_222 = self.peeked in (
              self.cur <- __assign_222;
              __assign_222
            ));
            let __assign_223 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_223;
              __assign_223
            )
          )) else ignore (let __assign_224 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_224;
            __assign_224
          )));
          ignore (let __assign_225 = HxExpr.ECall (!e, args) in (
            e := __assign_225;
            __assign_225
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (try while true do try ignore (let arg = parseExpr self (fun () -> let tempLeft = ref false in (
          ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 13 then let __assign_226 = true in (
            tempLeft := __assign_226;
            __assign_226
          ) else let __assign_227 = false in (
            tempLeft := __assign_227;
            __assign_227
          ));
          let tempRight = ref false in (
            ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 9 then let __assign_228 = true in (
              tempRight := __assign_228;
              __assign_228
            ) else let __assign_229 = false in (
              tempRight := __assign_229;
              __assign_229
            ));
            let tempRight1 = ref false in (
              ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_230 = true in (
                tempRight1 := __assign_230;
                __assign_230
              ) else let __assign_231 = false in (
                tempRight1 := __assign_231;
                __assign_231
              ));
              !tempLeft || !tempRight || !tempRight1
            )
          )
        )) in (
          ignore (HxArray.push args arg);
          let tempBool1 = ref false in (
            ignore (let _g2 = self.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 13 then let __assign_232 = true in (
              tempBool1 := __assign_232;
              __assign_232
            ) else let __assign_233 = false in (
              tempBool1 := __assign_233;
              __assign_233
            ));
            ignore (if !tempBool1 then ignore ((
              ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
                ignore (let __assign_234 = self.peeked in (
                  self.cur <- __assign_234;
                  __assign_234
                ));
                let __assign_235 = Obj.magic (HxRuntime.hx_null) in (
                  self.peeked <- __assign_235;
                  __assign_235
                )
              )) else ignore (let __assign_236 = HxLexer.next (self.lex) () in (
                self.cur <- __assign_236;
                __assign_236
              )));
              raise (HxRuntime.Hx_continue)
            )) else ());
            ignore (expect self (HxTokenKind.TRParen) "')'");
            raise (HxRuntime.Hx_break)
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        let __assign_237 = HxExpr.ECall (!e, args) in (
          e := __assign_237;
          __assign_237
        )
      )
    ))
    | HxTokenKind.TDot -> ignore ((
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_238 = self.peeked in (
          self.cur <- __assign_238;
          __assign_238
        ));
        let __assign_239 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_239;
          __assign_239
        )
      )) else ignore (let __assign_240 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_240;
        __assign_240
      )));
      let field = readIdent self "field name" in let __assign_241 = HxExpr.EField (!e, field) in (
        e := __assign_241;
        __assign_241
      )
    ))
    | _ -> raise (HxRuntime.Hx_break)) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  !e
)
and parseUnaryExpr = fun self (stop : unit -> bool) -> let tempResult = ref (Obj.magic ()) in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 14 then let _g2 = match _g with
    | HxTokenKind.TOther __enum_param_242 -> __enum_param_242
    | _ -> failwith "Unexpected enum parameter" in let c = _g2 in if c = 33 || c = 45 || c = 43 then let op = HxString.fromCharCode c in (
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_243 = self.peeked in (
        self.cur <- __assign_243;
        __assign_243
      ));
      let __assign_244 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_244;
        __assign_244
      )
    )) else ignore (let __assign_245 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_245;
      __assign_245
    )));
    let __assign_246 = HxExpr.EUnop (op, parseUnaryExpr self stop) in (
      tempResult := __assign_246;
      __assign_246
    )
  ) else let __assign_247 = parsePostfixExpr self stop in (
    tempResult := __assign_247;
    __assign_247
  ) else let __assign_248 = parsePostfixExpr self stop in (
    tempResult := __assign_248;
    __assign_248
  ));
  !tempResult
)
and parseBinaryExpr = fun self (minPrec : int) (stop : unit -> bool) -> let left = ref (parseUnaryExpr self stop) in (
  ignore (try while true do try ignore ((
    ignore (if stop () then raise (HxRuntime.Hx_break) else ());
    let peekedOp = peekBinop self stop in (
      ignore (if peekedOp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_break) else ());
      let op = Obj.obj (HxAnon.get peekedOp "op") in let prec = binopPrec op in (
        ignore (if prec < minPrec || prec = 0 then raise (HxRuntime.Hx_break) else ());
        ignore (consumeBinop self (Obj.obj (HxAnon.get peekedOp "len")));
        let tempNumber = ref 0 in (
          ignore (if isRightAssoc op then let __assign_321 = prec in (
            tempNumber := __assign_321;
            __assign_321
          ) else let __assign_322 = HxInt.add prec 1 in (
            tempNumber := __assign_322;
            __assign_322
          ));
          let nextMin = !tempNumber in let right = parseBinaryExpr self nextMin stop in let __assign_323 = HxExpr.EBinop (op, !left, right) in (
            left := __assign_323;
            __assign_323
          )
        )
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  !left
)
and parseExpr = fun self (stop : unit -> bool) -> parseBinaryExpr self 1 stop

let parseReturnStmt = fun self (pos : HxPos.t) -> try let _gthis = self in let tempBool = ref false in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 10 then let __assign_324 = true in (
    tempBool := __assign_324;
    __assign_324
  ) else let __assign_325 = false in (
    tempBool := __assign_325;
    __assign_325
  ));
  ignore (if !tempBool then ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_326 = self.peeked in (
        self.cur <- __assign_326;
        __assign_326
      ));
      let __assign_327 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_327;
        __assign_327
      )
    )) else ignore (let __assign_328 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_328;
      __assign_328
    )));
    raise (HxRuntime.Hx_return (Obj.repr (HxStmt.SReturnVoid pos)))
  )) else ());
  let tempBool1 = ref false in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 7 then let __assign_329 = true in (
      tempBool1 := __assign_329;
      __assign_329
    ) else let __assign_330 = false in (
      tempBool1 := __assign_330;
      __assign_330
    ));
    ignore (if !tempBool1 then raise (HxRuntime.Hx_return (Obj.repr (HxStmt.SReturnVoid pos))) else ());
    ignore (if HxString.length (self.capturedReturnStringLiteral) = 0 then ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 2 then ignore (let _g2 = match _g with
      | HxTokenKind.TString __enum_param_331 -> __enum_param_331
      | _ -> failwith "Unexpected enum parameter" in let s = _g2 in let __assign_332 = s in (
      self.capturedReturnStringLiteral <- __assign_332;
      __assign_332
    )) else ignore ()) else ());
    let expr = parseExpr self (fun () -> let tempLeft = ref false in (
      ignore (let _g = _gthis.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 10 then let __assign_333 = true in (
        tempLeft := __assign_333;
        __assign_333
      ) else let __assign_334 = false in (
        tempLeft := __assign_334;
        __assign_334
      ));
      let tempRight = ref false in (
        ignore (let _g = _gthis.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 7 then let __assign_335 = true in (
          tempRight := __assign_335;
          __assign_335
        ) else let __assign_336 = false in (
          tempRight := __assign_336;
          __assign_336
        ));
        let tempRight1 = ref false in (
          ignore (let _g = _gthis.cur.kind in if (match _g with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 0 then let __assign_337 = true in (
            tempRight1 := __assign_337;
            __assign_337
          ) else let __assign_338 = false in (
            tempRight1 := __assign_338;
            __assign_338
          ));
          !tempLeft || !tempRight || !tempRight1
        )
      )
    )) in (
      ignore (syncToStmtEnd self ());
      HxStmt.SReturn (expr, pos)
    )
  )
) with
  | HxRuntime.Hx_return __ret_339 -> Obj.obj __ret_339

let parseVarStmt = fun self (pos : HxPos.t) -> let _gthis = self in let name = readIdent self "variable name" in let typeHint = ref "" in let tempBool = ref false in (
  ignore (let _g = self.cur.kind in if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 11 then let __assign_358 = true in (
    tempBool := __assign_358;
    __assign_358
  ) else let __assign_359 = false in (
    tempBool := __assign_359;
    __assign_359
  ));
  ignore (if !tempBool then ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_360 = self.peeked in (
        self.cur <- __assign_360;
        __assign_360
      ));
      let __assign_361 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_361;
        __assign_361
      )
    )) else ignore (let __assign_362 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_362;
      __assign_362
    )));
    let __assign_363 = readTypeHintText self (fun () -> let tempLeft = ref false in (
      ignore (let _g = _gthis.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 10 then let __assign_364 = true in (
        tempLeft := __assign_364;
        __assign_364
      ) else let __assign_365 = false in (
        tempLeft := __assign_365;
        __assign_365
      ));
      let tempRight = ref false in (
        ignore (let _g = _gthis.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 0 then let __assign_366 = true in (
          tempRight := __assign_366;
          __assign_366
        ) else let __assign_367 = false in (
          tempRight := __assign_367;
          __assign_367
        ));
        !tempLeft || !tempRight || isOtherChar _gthis "="
      )
    )) in (
      typeHint := __assign_363;
      __assign_363
    )
  )) else ());
  let init = ref (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null)))) in (
    ignore (if acceptOtherChar self "=" then ignore (let __assign_368 = HxEnum.box_if_needed "HxExpr" (Obj.repr (parseExpr self (fun () -> let tempLeft1 = ref false in (
      ignore (let _g = _gthis.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 10 then let __assign_369 = true in (
        tempLeft1 := __assign_369;
        __assign_369
      ) else let __assign_370 = false in (
        tempLeft1 := __assign_370;
        __assign_370
      ));
      let tempRight1 = ref false in (
        ignore (let _g = _gthis.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 0 then let __assign_371 = true in (
          tempRight1 := __assign_371;
          __assign_371
        ) else let __assign_372 = false in (
          tempRight1 := __assign_372;
          __assign_372
        ));
        let tempRight2 = ref false in (
          ignore (let _g = _gthis.cur.kind in if (match _g with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 7 then let __assign_373 = true in (
            tempRight2 := __assign_373;
            __assign_373
          ) else let __assign_374 = false in (
            tempRight2 := __assign_374;
            __assign_374
          ));
          !tempLeft1 || !tempRight1 || !tempRight2
        )
      )
    )))) in (
      init := __assign_368;
      __assign_368
    )) else ());
    ignore (syncToStmtEnd self ());
    HxStmt.SVar (name, !typeHint, !init, pos)
  )
)

let rec parseStmt = fun self (stop : unit -> bool) -> try let _gthis = self in (
  ignore (if stop () then raise (HxRuntime.Hx_return (Obj.repr (HxStmt.SExpr (HxExpr.EUnsupported "<eof-stmt>", HxPos.unknown ())))) else ());
  let pos = self.cur.pos in let tempResult = ref (Obj.magic ()) in (
    ignore (let _g = self.cur.kind in match _g with
      | HxTokenKind.TKeyword _p0 -> (let _g2 = _p0 in match _g2 with
        | HxKeyword.KReturn -> (
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_389 = self.peeked in (
              self.cur <- __assign_389;
              __assign_389
            ));
            let __assign_390 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_390;
              __assign_390
            )
          )) else ignore (let __assign_391 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_391;
            __assign_391
          )));
          let __assign_392 = parseReturnStmt self pos in (
            tempResult := __assign_392;
            __assign_392
          )
        )
        | HxKeyword.KIf -> (
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_393 = self.peeked in (
              self.cur <- __assign_393;
              __assign_393
            ));
            let __assign_394 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_394;
              __assign_394
            )
          )) else ignore (let __assign_395 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_395;
            __assign_395
          )));
          ignore (expect self (HxTokenKind.TLParen) "'('");
          let cond = parseExpr self (fun () -> let tempLeft = ref false in (
            ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 9 then let __assign_396 = true in (
              tempLeft := __assign_396;
              __assign_396
            ) else let __assign_397 = false in (
              tempLeft := __assign_397;
              __assign_397
            ));
            let tempRight = ref false in (
              ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_398 = true in (
                tempRight := __assign_398;
                __assign_398
              ) else let __assign_399 = false in (
                tempRight := __assign_399;
                __assign_399
              ));
              !tempLeft || !tempRight
            )
          )) in (
            ignore (expect self (HxTokenKind.TRParen) "')'");
            let thenBranch = parseStmt self stop in let tempMaybeHxStmt = ref (Obj.magic ()) in (
              ignore (if acceptKeyword self (HxKeyword.KElse) then let __assign_400 = HxEnum.box_if_needed "HxStmt" (Obj.repr (parseStmt self stop)) in (
                tempMaybeHxStmt := __assign_400;
                __assign_400
              ) else let __assign_401 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" (Obj.magic (HxRuntime.hx_null))) in (
                tempMaybeHxStmt := __assign_401;
                __assign_401
              ));
              let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" (!tempMaybeHxStmt)) in let __assign_402 = HxStmt.SIf (cond, thenBranch, elseBranch, pos) in (
                tempResult := __assign_402;
                __assign_402
              )
            )
          )
        )
        | HxKeyword.KVar -> (
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_403 = self.peeked in (
              self.cur <- __assign_403;
              __assign_403
            ));
            let __assign_404 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_404;
              __assign_404
            )
          )) else ignore (let __assign_405 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_405;
            __assign_405
          )));
          let __assign_406 = parseVarStmt self pos in (
            tempResult := __assign_406;
            __assign_406
          )
        )
        | _ -> let expr = parseExpr self (fun () -> let tempLeft1 = ref false in (
          ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 10 then let __assign_382 = true in (
            tempLeft1 := __assign_382;
            __assign_382
          ) else let __assign_383 = false in (
            tempLeft1 := __assign_383;
            __assign_383
          ));
          let tempRight1 = ref false in (
            ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 7 then let __assign_384 = true in (
              tempRight1 := __assign_384;
              __assign_384
            ) else let __assign_385 = false in (
              tempRight1 := __assign_385;
              __assign_385
            ));
            let tempRight2 = ref false in (
              ignore (let _g3 = _gthis.cur.kind in if (match _g3 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_386 = true in (
                tempRight2 := __assign_386;
                __assign_386
              ) else let __assign_387 = false in (
                tempRight2 := __assign_387;
                __assign_387
              ));
              !tempLeft1 || !tempRight1 || !tempRight2
            )
          )
        )) in (
          ignore (syncToStmtEnd self ());
          let __assign_388 = HxStmt.SExpr (expr, pos) in (
            tempResult := __assign_388;
            __assign_388
          )
        ))
      | HxTokenKind.TLBrace -> (
        ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (let __assign_407 = self.peeked in (
            self.cur <- __assign_407;
            __assign_407
          ));
          let __assign_408 = Obj.magic (HxRuntime.hx_null) in (
            self.peeked <- __assign_408;
            __assign_408
          )
        )) else ignore (let __assign_409 = HxLexer.next (self.lex) () in (
          self.cur <- __assign_409;
          __assign_409
        )));
        let ss = HxArray.create () in (
          ignore (try while true do try ignore (let tempBool = ref false in (
            ignore (let _g2 = self.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 7 then let __assign_410 = true in (
              tempBool := __assign_410;
              __assign_410
            ) else let __assign_411 = false in (
              tempBool := __assign_411;
              __assign_411
            ));
            let tempBool1 = ref false in (
              ignore (let _g2 = self.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_412 = true in (
                tempBool1 := __assign_412;
                __assign_412
              ) else let __assign_413 = false in (
                tempBool1 := __assign_413;
                __assign_413
              ));
              ignore (if not (not (!tempBool) && not (!tempBool1)) then raise (HxRuntime.Hx_break) else ());
              HxArray.push ss (parseStmt self (fun () -> let tempLeft2 = ref false in (
                ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                  | HxTokenKind.TEof -> 0
                  | HxTokenKind.TIdent _ -> 1
                  | HxTokenKind.TString _ -> 2
                  | HxTokenKind.TInt _ -> 3
                  | HxTokenKind.TFloat _ -> 4
                  | HxTokenKind.TKeyword _ -> 5
                  | HxTokenKind.TLBrace -> 6
                  | HxTokenKind.TRBrace -> 7
                  | HxTokenKind.TLParen -> 8
                  | HxTokenKind.TRParen -> 9
                  | HxTokenKind.TSemicolon -> 10
                  | HxTokenKind.TColon -> 11
                  | HxTokenKind.TDot -> 12
                  | HxTokenKind.TComma -> 13
                  | HxTokenKind.TOther _ -> 14) = 7 then let __assign_414 = true in (
                  tempLeft2 := __assign_414;
                  __assign_414
                ) else let __assign_415 = false in (
                  tempLeft2 := __assign_415;
                  __assign_415
                ));
                let tempRight3 = ref false in (
                  ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                    | HxTokenKind.TEof -> 0
                    | HxTokenKind.TIdent _ -> 1
                    | HxTokenKind.TString _ -> 2
                    | HxTokenKind.TInt _ -> 3
                    | HxTokenKind.TFloat _ -> 4
                    | HxTokenKind.TKeyword _ -> 5
                    | HxTokenKind.TLBrace -> 6
                    | HxTokenKind.TRBrace -> 7
                    | HxTokenKind.TLParen -> 8
                    | HxTokenKind.TRParen -> 9
                    | HxTokenKind.TSemicolon -> 10
                    | HxTokenKind.TColon -> 11
                    | HxTokenKind.TDot -> 12
                    | HxTokenKind.TComma -> 13
                    | HxTokenKind.TOther _ -> 14) = 0 then let __assign_416 = true in (
                    tempRight3 := __assign_416;
                    __assign_416
                  ) else let __assign_417 = false in (
                    tempRight3 := __assign_417;
                    __assign_417
                  ));
                  !tempLeft2 || !tempRight3
                )
              )))
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ignore (expect self (HxTokenKind.TRBrace) "'}'");
          let __assign_418 = HxStmt.SBlock (ss, pos) in (
            tempResult := __assign_418;
            __assign_418
          )
        )
      )
      | _ -> let expr = parseExpr self (fun () -> let tempLeft3 = ref false in (
        ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 10 then let __assign_375 = true in (
          tempLeft3 := __assign_375;
          __assign_375
        ) else let __assign_376 = false in (
          tempLeft3 := __assign_376;
          __assign_376
        ));
        let tempRight4 = ref false in (
          ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 7 then let __assign_377 = true in (
            tempRight4 := __assign_377;
            __assign_377
          ) else let __assign_378 = false in (
            tempRight4 := __assign_378;
            __assign_378
          ));
          let tempRight5 = ref false in (
            ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 0 then let __assign_379 = true in (
              tempRight5 := __assign_379;
              __assign_379
            ) else let __assign_380 = false in (
              tempRight5 := __assign_380;
              __assign_380
            ));
            !tempLeft3 || !tempRight4 || !tempRight5
          )
        )
      )) in (
        ignore (syncToStmtEnd self ());
        let __assign_381 = HxStmt.SExpr (expr, pos) in (
          tempResult := __assign_381;
          __assign_381
        )
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_419 -> Obj.obj __ret_419

let parseFunctionBodyStatements = fun self () -> try let _gthis = self in let out = HxArray.create () in while true do ignore (let _g = self.cur.kind in match _g with
  | HxTokenKind.TEof -> ignore (fail self "Unterminated function body")
  | HxTokenKind.TRBrace -> ignore ((
    ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_424 = self.peeked in (
        self.cur <- __assign_424;
        __assign_424
      ));
      let __assign_425 = Obj.magic (HxRuntime.hx_null) in (
        self.peeked <- __assign_425;
        __assign_425
      )
    )) else ignore (let __assign_426 = HxLexer.next (self.lex) () in (
      self.cur <- __assign_426;
      __assign_426
    )));
    raise (HxRuntime.Hx_return (Obj.repr out))
  ))
  | _ -> ignore (HxArray.push out (parseStmt self (fun () -> let tempLeft = ref false in (
    ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 7 then let __assign_420 = true in (
      tempLeft := __assign_420;
      __assign_420
    ) else let __assign_421 = false in (
      tempLeft := __assign_421;
      __assign_421
    ));
    let tempRight = ref false in (
      ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 0 then let __assign_422 = true in (
        tempRight := __assign_422;
        __assign_422
      ) else let __assign_423 = false in (
        tempRight := __assign_423;
        __assign_423
      ));
      !tempLeft || !tempRight
    )
  ))))) done with
  | HxRuntime.Hx_return __ret_427 -> Obj.obj __ret_427

let parseFunctionDecl = fun self (visibility : HxVisibility.hxvisibility) (isStatic : bool) -> let _gthis = self in (
  ignore (let __assign_428 = "" in (
    self.capturedReturnStringLiteral <- __assign_428;
    __assign_428
  ));
  let tempString = ref "" in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 5 then let _g2 = match _g with
      | HxTokenKind.TKeyword __enum_param_429 -> __enum_param_429
      | _ -> failwith "Unexpected enum parameter" in if (match _g2 with
      | HxKeyword.KPackage -> 0
      | HxKeyword.KImport -> 1
      | HxKeyword.KUsing -> 2
      | HxKeyword.KAs -> 3
      | HxKeyword.KClass -> 4
      | HxKeyword.KPublic -> 5
      | HxKeyword.KPrivate -> 6
      | HxKeyword.KStatic -> 7
      | HxKeyword.KFunction -> 8
      | HxKeyword.KReturn -> 9
      | HxKeyword.KIf -> 10
      | HxKeyword.KElse -> 11
      | HxKeyword.KSwitch -> 12
      | HxKeyword.KCase -> 13
      | HxKeyword.KDefault -> 14
      | HxKeyword.KTry -> 15
      | HxKeyword.KCatch -> 16
      | HxKeyword.KThrow -> 17
      | HxKeyword.KWhile -> 18
      | HxKeyword.KDo -> 19
      | HxKeyword.KFor -> 20
      | HxKeyword.KBreak -> 21
      | HxKeyword.KContinue -> 22
      | HxKeyword.KUntyped -> 23
      | HxKeyword.KCast -> 24
      | HxKeyword.KVar -> 25
      | HxKeyword.KFinal -> 26
      | HxKeyword.KNew -> 27
      | HxKeyword.KThis -> 28
      | HxKeyword.KSuper -> 29
      | HxKeyword.KTrue -> 30
      | HxKeyword.KFalse -> 31
      | HxKeyword.KNull -> 32) = 27 then (
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_430 = self.peeked in (
          self.cur <- __assign_430;
          __assign_430
        ));
        let __assign_431 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_431;
          __assign_431
        )
      )) else ignore (let __assign_432 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_432;
        __assign_432
      )));
      let __assign_433 = "new" in (
        tempString := __assign_433;
        __assign_433
      )
    ) else let __assign_434 = readIdent self "function name" in (
      tempString := __assign_434;
      __assign_434
    ) else let __assign_435 = readIdent self "function name" in (
      tempString := __assign_435;
      __assign_435
    ));
    ignore (expect self (HxTokenKind.TLParen) "'('");
    let args = HxArray.create () in let tempBool = ref false in (
      ignore (let _g = self.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 9 then let __assign_436 = true in (
        tempBool := __assign_436;
        __assign_436
      ) else let __assign_437 = false in (
        tempBool := __assign_437;
        __assign_437
      ));
      ignore (if not (!tempBool) then ignore (try while true do try ignore (let argName = readIdent self "argument name" in let argType = ref "" in let defaultValue = ref (HxDefaultValue.NoDefault) in let tempBool1 = ref false in (
        ignore (let _g = self.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 11 then let __assign_438 = true in (
          tempBool1 := __assign_438;
          __assign_438
        ) else let __assign_439 = false in (
          tempBool1 := __assign_439;
          __assign_439
        ));
        ignore (if !tempBool1 then ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_440 = self.peeked in (
              self.cur <- __assign_440;
              __assign_440
            ));
            let __assign_441 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_441;
              __assign_441
            )
          )) else ignore (let __assign_442 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_442;
            __assign_442
          )));
          let __assign_443 = readTypeHintText self (fun () -> let tempLeft = ref false in (
            ignore (let _g = _gthis.cur.kind in if (match _g with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 13 then let __assign_444 = true in (
              tempLeft := __assign_444;
              __assign_444
            ) else let __assign_445 = false in (
              tempLeft := __assign_445;
              __assign_445
            ));
            let tempRight = ref false in (
              ignore (let _g = _gthis.cur.kind in if (match _g with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 9 then let __assign_446 = true in (
                tempRight := __assign_446;
                __assign_446
              ) else let __assign_447 = false in (
                tempRight := __assign_447;
                __assign_447
              ));
              let tempRight1 = ref false in (
                ignore (let _g = _gthis.cur.kind in if (match _g with
                  | HxTokenKind.TEof -> 0
                  | HxTokenKind.TIdent _ -> 1
                  | HxTokenKind.TString _ -> 2
                  | HxTokenKind.TInt _ -> 3
                  | HxTokenKind.TFloat _ -> 4
                  | HxTokenKind.TKeyword _ -> 5
                  | HxTokenKind.TLBrace -> 6
                  | HxTokenKind.TRBrace -> 7
                  | HxTokenKind.TLParen -> 8
                  | HxTokenKind.TRParen -> 9
                  | HxTokenKind.TSemicolon -> 10
                  | HxTokenKind.TColon -> 11
                  | HxTokenKind.TDot -> 12
                  | HxTokenKind.TComma -> 13
                  | HxTokenKind.TOther _ -> 14) = 0 then let __assign_448 = true in (
                  tempRight1 := __assign_448;
                  __assign_448
                ) else let __assign_449 = false in (
                  tempRight1 := __assign_449;
                  __assign_449
                ));
                !tempLeft || !tempRight || !tempRight1 || isOtherChar _gthis "="
              )
            )
          )) in (
            argType := __assign_443;
            __assign_443
          )
        )) else ());
        ignore (if acceptOtherChar self "=" then ignore (let __assign_450 = HxDefaultValue.Default (parseExpr self (fun () -> let tempLeft1 = ref false in (
          ignore (let _g = _gthis.cur.kind in if (match _g with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 13 then let __assign_451 = true in (
            tempLeft1 := __assign_451;
            __assign_451
          ) else let __assign_452 = false in (
            tempLeft1 := __assign_452;
            __assign_452
          ));
          let tempRight2 = ref false in (
            ignore (let _g = _gthis.cur.kind in if (match _g with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 9 then let __assign_453 = true in (
              tempRight2 := __assign_453;
              __assign_453
            ) else let __assign_454 = false in (
              tempRight2 := __assign_454;
              __assign_454
            ));
            let tempRight3 = ref false in (
              ignore (let _g = _gthis.cur.kind in if (match _g with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_455 = true in (
                tempRight3 := __assign_455;
                __assign_455
              ) else let __assign_456 = false in (
                tempRight3 := __assign_456;
                __assign_456
              ));
              !tempLeft1 || !tempRight2 || !tempRight3
            )
          )
        ))) in (
          defaultValue := __assign_450;
          __assign_450
        )) else ());
        ignore (HxArray.push args (HxFunctionArg.create argName (!argType) (!defaultValue)));
        let tempBool2 = ref false in (
          ignore (let _g = self.cur.kind in if (match _g with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 13 then let __assign_457 = true in (
            tempBool2 := __assign_457;
            __assign_457
          ) else let __assign_458 = false in (
            tempBool2 := __assign_458;
            __assign_458
          ));
          ignore (if !tempBool2 then ignore ((
            ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
              ignore (let __assign_459 = self.peeked in (
                self.cur <- __assign_459;
                __assign_459
              ));
              let __assign_460 = Obj.magic (HxRuntime.hx_null) in (
                self.peeked <- __assign_460;
                __assign_460
              )
            )) else ignore (let __assign_461 = HxLexer.next (self.lex) () in (
              self.cur <- __assign_461;
              __assign_461
            )));
            raise (HxRuntime.Hx_continue)
          )) else ());
          raise (HxRuntime.Hx_break)
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      ignore (expect self (HxTokenKind.TRParen) "')'");
      let returnType = ref "" in let tempBool3 = ref false in (
        ignore (let _g = self.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 11 then let __assign_462 = true in (
          tempBool3 := __assign_462;
          __assign_462
        ) else let __assign_463 = false in (
          tempBool3 := __assign_463;
          __assign_463
        ));
        ignore (if !tempBool3 then ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_464 = self.peeked in (
              self.cur <- __assign_464;
              __assign_464
            ));
            let __assign_465 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_465;
              __assign_465
            )
          )) else ignore (let __assign_466 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_466;
            __assign_466
          )));
          let __assign_467 = readTypeHintText self (fun () -> let tempLeft2 = ref false in (
            ignore (let _g = _gthis.cur.kind in if (match _g with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 6 then let __assign_468 = true in (
              tempLeft2 := __assign_468;
              __assign_468
            ) else let __assign_469 = false in (
              tempLeft2 := __assign_469;
              __assign_469
            ));
            let tempRight4 = ref false in (
              ignore (let _g = _gthis.cur.kind in if (match _g with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 10 then let __assign_470 = true in (
                tempRight4 := __assign_470;
                __assign_470
              ) else let __assign_471 = false in (
                tempRight4 := __assign_471;
                __assign_471
              ));
              let tempRight5 = ref false in (
                ignore (let _g = _gthis.cur.kind in if (match _g with
                  | HxTokenKind.TEof -> 0
                  | HxTokenKind.TIdent _ -> 1
                  | HxTokenKind.TString _ -> 2
                  | HxTokenKind.TInt _ -> 3
                  | HxTokenKind.TFloat _ -> 4
                  | HxTokenKind.TKeyword _ -> 5
                  | HxTokenKind.TLBrace -> 6
                  | HxTokenKind.TRBrace -> 7
                  | HxTokenKind.TLParen -> 8
                  | HxTokenKind.TRParen -> 9
                  | HxTokenKind.TSemicolon -> 10
                  | HxTokenKind.TColon -> 11
                  | HxTokenKind.TDot -> 12
                  | HxTokenKind.TComma -> 13
                  | HxTokenKind.TOther _ -> 14) = 0 then let __assign_472 = true in (
                  tempRight5 := __assign_472;
                  __assign_472
                ) else let __assign_473 = false in (
                  tempRight5 := __assign_473;
                  __assign_473
                ));
                let tempRight6 = ref false in (
                  ignore (let _g = _gthis.cur.kind in if (match _g with
                    | HxTokenKind.TEof -> 0
                    | HxTokenKind.TIdent _ -> 1
                    | HxTokenKind.TString _ -> 2
                    | HxTokenKind.TInt _ -> 3
                    | HxTokenKind.TFloat _ -> 4
                    | HxTokenKind.TKeyword _ -> 5
                    | HxTokenKind.TLBrace -> 6
                    | HxTokenKind.TRBrace -> 7
                    | HxTokenKind.TLParen -> 8
                    | HxTokenKind.TRParen -> 9
                    | HxTokenKind.TSemicolon -> 10
                    | HxTokenKind.TColon -> 11
                    | HxTokenKind.TDot -> 12
                    | HxTokenKind.TComma -> 13
                    | HxTokenKind.TOther _ -> 14) = 5 then let _g2 = match _g with
                    | HxTokenKind.TKeyword __enum_param_474 -> __enum_param_474
                    | _ -> failwith "Unexpected enum parameter" in if (match _g2 with
                    | HxKeyword.KPackage -> 0
                    | HxKeyword.KImport -> 1
                    | HxKeyword.KUsing -> 2
                    | HxKeyword.KAs -> 3
                    | HxKeyword.KClass -> 4
                    | HxKeyword.KPublic -> 5
                    | HxKeyword.KPrivate -> 6
                    | HxKeyword.KStatic -> 7
                    | HxKeyword.KFunction -> 8
                    | HxKeyword.KReturn -> 9
                    | HxKeyword.KIf -> 10
                    | HxKeyword.KElse -> 11
                    | HxKeyword.KSwitch -> 12
                    | HxKeyword.KCase -> 13
                    | HxKeyword.KDefault -> 14
                    | HxKeyword.KTry -> 15
                    | HxKeyword.KCatch -> 16
                    | HxKeyword.KThrow -> 17
                    | HxKeyword.KWhile -> 18
                    | HxKeyword.KDo -> 19
                    | HxKeyword.KFor -> 20
                    | HxKeyword.KBreak -> 21
                    | HxKeyword.KContinue -> 22
                    | HxKeyword.KUntyped -> 23
                    | HxKeyword.KCast -> 24
                    | HxKeyword.KVar -> 25
                    | HxKeyword.KFinal -> 26
                    | HxKeyword.KNew -> 27
                    | HxKeyword.KThis -> 28
                    | HxKeyword.KSuper -> 29
                    | HxKeyword.KTrue -> 30
                    | HxKeyword.KFalse -> 31
                    | HxKeyword.KNull -> 32) = 9 then let __assign_475 = true in (
                    tempRight6 := __assign_475;
                    __assign_475
                  ) else let __assign_476 = false in (
                    tempRight6 := __assign_476;
                    __assign_476
                  ) else let __assign_477 = false in (
                    tempRight6 := __assign_477;
                    __assign_477
                  ));
                  !tempLeft2 || !tempRight4 || !tempRight5 || !tempRight6
                )
              )
            )
          )) in (
            returnType := __assign_467;
            __assign_467
          )
        )) else ());
        let body = HxArray.create () in (
          ignore (let _g = self.cur.kind in match _g with
            | HxTokenKind.TLBrace -> ignore ((
              ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
                ignore (let __assign_487 = self.peeked in (
                  self.cur <- __assign_487;
                  __assign_487
                ));
                let __assign_488 = Obj.magic (HxRuntime.hx_null) in (
                  self.peeked <- __assign_488;
                  __assign_488
                )
              )) else ignore (let __assign_489 = HxLexer.next (self.lex) () in (
                self.cur <- __assign_489;
                __assign_489
              )));
              let _g2 = ref 0 in let _g1 = parseFunctionBodyStatements self () in while !_g2 < HxArray.length _g1 do ignore (let s = HxArray.get _g1 (!_g2) in (
                ignore (let __old_490 = !_g2 in let __new_491 = HxInt.add __old_490 1 in (
                  ignore (_g2 := __new_491);
                  __new_491
                ));
                HxArray.push body s
              )) done
            ))
            | HxTokenKind.TSemicolon -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
              ignore (let __assign_492 = self.peeked in (
                self.cur <- __assign_492;
                __assign_492
              ));
              let __assign_493 = Obj.magic (HxRuntime.hx_null) in (
                self.peeked <- __assign_493;
                __assign_493
              )
            )) else ignore (let __assign_494 = HxLexer.next (self.lex) () in (
              self.cur <- __assign_494;
              __assign_494
            )))
            | _ -> ignore (if acceptKeyword self (HxKeyword.KReturn) then ignore (HxArray.push body (parseReturnStmt self (HxPos.unknown ()))) else ignore (let expr = parseExpr self (fun () -> let tempLeft3 = ref false in (
              ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 10 then let __assign_478 = true in (
                tempLeft3 := __assign_478;
                __assign_478
              ) else let __assign_479 = false in (
                tempLeft3 := __assign_479;
                __assign_479
              ));
              let tempRight7 = ref false in (
                ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                  | HxTokenKind.TEof -> 0
                  | HxTokenKind.TIdent _ -> 1
                  | HxTokenKind.TString _ -> 2
                  | HxTokenKind.TInt _ -> 3
                  | HxTokenKind.TFloat _ -> 4
                  | HxTokenKind.TKeyword _ -> 5
                  | HxTokenKind.TLBrace -> 6
                  | HxTokenKind.TRBrace -> 7
                  | HxTokenKind.TLParen -> 8
                  | HxTokenKind.TRParen -> 9
                  | HxTokenKind.TSemicolon -> 10
                  | HxTokenKind.TColon -> 11
                  | HxTokenKind.TDot -> 12
                  | HxTokenKind.TComma -> 13
                  | HxTokenKind.TOther _ -> 14) = 0 then let __assign_480 = true in (
                  tempRight7 := __assign_480;
                  __assign_480
                ) else let __assign_481 = false in (
                  tempRight7 := __assign_481;
                  __assign_481
                ));
                !tempLeft3 || !tempRight7
              )
            )) in let tempBool4 = ref false in (
              ignore (let _g2 = self.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 10 then let __assign_482 = true in (
                tempBool4 := __assign_482;
                __assign_482
              ) else let __assign_483 = false in (
                tempBool4 := __assign_483;
                __assign_483
              ));
              ignore (if !tempBool4 then ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
                ignore (let __assign_484 = self.peeked in (
                  self.cur <- __assign_484;
                  __assign_484
                ));
                let __assign_485 = Obj.magic (HxRuntime.hx_null) in (
                  self.peeked <- __assign_485;
                  __assign_485
                )
              )) else ignore (let __assign_486 = HxLexer.next (self.lex) () in (
                self.cur <- __assign_486;
                __assign_486
              ))) else ());
              HxArray.push body (HxStmt.SExpr (expr, HxPos.unknown ()))
            ))));
          HxFunctionDecl.create (!tempString) visibility isStatic args (!returnType) body (self.capturedReturnStringLiteral)
        )
      )
    )
  )
)

let parseClassMembers = fun self () -> let _gthis = self in let funcs = HxArray.create () in let fields = HxArray.create () in (
  ignore (try while true do try ignore (let _g = self.cur.kind in match _g with
    | HxTokenKind.TEof -> ignore (fail self "Unexpected end of input in class body")
    | HxTokenKind.TRBrace -> ignore ((
      ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_528 = self.peeked in (
          self.cur <- __assign_528;
          __assign_528
        ));
        let __assign_529 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_529;
          __assign_529
        )
      )) else ignore (let __assign_530 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_530;
        __assign_530
      )));
      raise (HxRuntime.Hx_break)
    ))
    | _ -> ignore (let visibility = ref (HxVisibility.Public) in let isStatic = ref false in let keep = ref true in (
      ignore (while !keep do ignore ((
        ignore (let __assign_495 = false in (
          keep := __assign_495;
          __assign_495
        ));
        if acceptKeyword self (HxKeyword.KPublic) then ignore ((
          ignore (let __assign_496 = HxVisibility.Public in (
            visibility := __assign_496;
            __assign_496
          ));
          let __assign_497 = true in (
            keep := __assign_497;
            __assign_497
          )
        )) else ignore (if acceptKeyword self (HxKeyword.KPrivate) then ignore ((
          ignore (let __assign_498 = HxVisibility.Private in (
            visibility := __assign_498;
            __assign_498
          ));
          let __assign_499 = true in (
            keep := __assign_499;
            __assign_499
          )
        )) else ignore (if acceptKeyword self (HxKeyword.KStatic) then ignore ((
          ignore (let __assign_500 = true in (
            isStatic := __assign_500;
            __assign_500
          ));
          let __assign_501 = true in (
            keep := __assign_501;
            __assign_501
          )
        )) else ()))
      )) done);
      ignore (if acceptKeyword self (HxKeyword.KFunction) then ignore ((
        ignore (HxArray.push funcs (parseFunctionDecl self (!visibility) (!isStatic)));
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if acceptKeyword self (HxKeyword.KVar) then ignore (let name = readIdent self "field name" in let typeHint = ref "" in let init = ref (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null)))) in let tempBool = ref false in (
        ignore (let _g2 = self.cur.kind in if (match _g2 with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 11 then let __assign_502 = true in (
          tempBool := __assign_502;
          __assign_502
        ) else let __assign_503 = false in (
          tempBool := __assign_503;
          __assign_503
        ));
        ignore (if !tempBool then ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_504 = self.peeked in (
              self.cur <- __assign_504;
              __assign_504
            ));
            let __assign_505 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_505;
              __assign_505
            )
          )) else ignore (let __assign_506 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_506;
            __assign_506
          )));
          let __assign_507 = readTypeHintText self (fun () -> let tempLeft = ref false in (
            ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 10 then let __assign_508 = true in (
              tempLeft := __assign_508;
              __assign_508
            ) else let __assign_509 = false in (
              tempLeft := __assign_509;
              __assign_509
            ));
            let tempRight = ref false in (
              ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 0 then let __assign_510 = true in (
                tempRight := __assign_510;
                __assign_510
              ) else let __assign_511 = false in (
                tempRight := __assign_511;
                __assign_511
              ));
              !tempLeft || !tempRight || isOtherChar _gthis "="
            )
          )) in (
            typeHint := __assign_507;
            __assign_507
          )
        )) else ());
        ignore (if acceptOtherChar self "=" then ignore (let __assign_512 = HxEnum.box_if_needed "HxExpr" (Obj.repr (parseExpr self (fun () -> let tempLeft1 = ref false in (
          ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 10 then let __assign_513 = true in (
            tempLeft1 := __assign_513;
            __assign_513
          ) else let __assign_514 = false in (
            tempLeft1 := __assign_514;
            __assign_514
          ));
          let tempRight1 = ref false in (
            ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 0 then let __assign_515 = true in (
              tempRight1 := __assign_515;
              __assign_515
            ) else let __assign_516 = false in (
              tempRight1 := __assign_516;
              __assign_516
            ));
            let tempRight2 = ref false in (
              ignore (let _g2 = _gthis.cur.kind in if (match _g2 with
                | HxTokenKind.TEof -> 0
                | HxTokenKind.TIdent _ -> 1
                | HxTokenKind.TString _ -> 2
                | HxTokenKind.TInt _ -> 3
                | HxTokenKind.TFloat _ -> 4
                | HxTokenKind.TKeyword _ -> 5
                | HxTokenKind.TLBrace -> 6
                | HxTokenKind.TRBrace -> 7
                | HxTokenKind.TLParen -> 8
                | HxTokenKind.TRParen -> 9
                | HxTokenKind.TSemicolon -> 10
                | HxTokenKind.TColon -> 11
                | HxTokenKind.TDot -> 12
                | HxTokenKind.TComma -> 13
                | HxTokenKind.TOther _ -> 14) = 7 then let __assign_517 = true in (
                tempRight2 := __assign_517;
                __assign_517
              ) else let __assign_518 = false in (
                tempRight2 := __assign_518;
                __assign_518
              ));
              !tempLeft1 || !tempRight1 || !tempRight2
            )
          )
        )))) in (
          init := __assign_512;
          __assign_512
        )) else ());
        ignore (expect self (HxTokenKind.TSemicolon) "';'");
        ignore (HxArray.push fields (HxFieldDecl.create name (!visibility) (!isStatic) (!typeHint) (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (!init)))));
        raise (HxRuntime.Hx_continue)
      )) else ());
      let _g2 = self.cur.kind in match _g2 with
        | HxTokenKind.TLBrace -> ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_522 = self.peeked in (
              self.cur <- __assign_522;
              __assign_522
            ));
            let __assign_523 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_523;
              __assign_523
            )
          )) else ignore (let __assign_524 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_524;
            __assign_524
          )));
          skipBalancedBraces self ()
        ))
        | HxTokenKind.TLParen -> ignore ((
          ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_525 = self.peeked in (
              self.cur <- __assign_525;
              __assign_525
            ));
            let __assign_526 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_526;
              __assign_526
            )
          )) else ignore (let __assign_527 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_527;
            __assign_527
          )));
          skipBalancedParens self ()
        ))
        | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (let __assign_519 = self.peeked in (
            self.cur <- __assign_519;
            __assign_519
          ));
          let __assign_520 = Obj.magic (HxRuntime.hx_null) in (
            self.peeked <- __assign_520;
            __assign_520
          )
        )) else ignore (let __assign_521 = HxLexer.next (self.lex) () in (
          self.cur <- __assign_521;
          __assign_521
        )))
    ))) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  let __anon_531 = HxAnon.create () in (
    ignore (HxAnon.set __anon_531 "functions" (Obj.repr funcs));
    ignore (HxAnon.set __anon_531 "fields" (Obj.repr fields));
    __anon_531
  )
)

let parseModule = fun self () -> let packagePath = ref "" in let imports = HxArray.create () in let hasToplevelMain = ref false in (
  ignore (if acceptKeyword self (HxKeyword.KPackage) then ignore (let tempBool = ref false in (
    ignore (let _g = self.cur.kind in if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 10 then let __assign_532 = true in (
      tempBool := __assign_532;
      __assign_532
    ) else let __assign_533 = false in (
      tempBool := __assign_533;
      __assign_533
    ));
    if !tempBool then ignore ((
      ignore (let __assign_534 = "" in (
        packagePath := __assign_534;
        __assign_534
      ));
      if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_535 = self.peeked in (
          self.cur <- __assign_535;
          __assign_535
        ));
        let __assign_536 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_536;
          __assign_536
        )
      )) else ignore (let __assign_537 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_537;
        __assign_537
      ))
    )) else ignore ((
      ignore (let __assign_538 = readDottedPath self () in (
        packagePath := __assign_538;
        __assign_538
      ));
      expect self (HxTokenKind.TSemicolon) "';'"
    ))
  )) else ());
  ignore (while acceptKeyword self (HxKeyword.KImport) || acceptKeyword self (HxKeyword.KUsing) do ignore (let path = readImportPath self () in (
    ignore (if acceptKeyword self (HxKeyword.KAs) then ignore (readIdent self "import alias") else ());
    ignore (HxArray.push imports path);
    expect self (HxTokenKind.TSemicolon) "';'"
  )) done);
  let sawClass = ref false in (
    ignore (try while true do try ignore ((
      ignore (let _g = self.cur.kind in match _g with
        | HxTokenKind.TEof -> raise (HxRuntime.Hx_break)
        | HxTokenKind.TKeyword _p0 -> ignore (let _g2 = _p0 in match _g2 with
          | HxKeyword.KClass -> ignore ((
            ignore (let __assign_545 = true in (
              sawClass := __assign_545;
              __assign_545
            ));
            raise (HxRuntime.Hx_break)
          ))
          | HxKeyword.KFunction -> ignore ((
            ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
              ignore (let __assign_546 = self.peeked in (
                self.cur <- __assign_546;
                __assign_546
              ));
              let __assign_547 = Obj.magic (HxRuntime.hx_null) in (
                self.peeked <- __assign_547;
                __assign_547
              )
            )) else ignore (let __assign_548 = HxLexer.next (self.lex) () in (
              self.cur <- __assign_548;
              __assign_548
            )));
            let _g3 = self.cur.kind in if (match _g3 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 1 then ignore (let _g4 = match _g3 with
              | HxTokenKind.TIdent __enum_param_549 -> __enum_param_549
              | _ -> failwith "Unexpected enum parameter" in if HxString.equals _g4 "main" then ignore (let __assign_550 = true in (
              hasToplevelMain := __assign_550;
              __assign_550
            )) else ignore ()) else ignore ()
          ))
          | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_542 = self.peeked in (
              self.cur <- __assign_542;
              __assign_542
            ));
            let __assign_543 = Obj.magic (HxRuntime.hx_null) in (
              self.peeked <- __assign_543;
              __assign_543
            )
          )) else ignore (let __assign_544 = HxLexer.next (self.lex) () in (
            self.cur <- __assign_544;
            __assign_544
          ))))
        | _ -> ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (let __assign_539 = self.peeked in (
            self.cur <- __assign_539;
            __assign_539
          ));
          let __assign_540 = Obj.magic (HxRuntime.hx_null) in (
            self.peeked <- __assign_540;
            __assign_540
          )
        )) else ignore (let __assign_541 = HxLexer.next (self.lex) () in (
          self.cur <- __assign_541;
          __assign_541
        ))));
      let tempLeft = ref false in (
        ignore (let _g = self.cur.kind in if (match _g with
          | HxTokenKind.TEof -> 0
          | HxTokenKind.TIdent _ -> 1
          | HxTokenKind.TString _ -> 2
          | HxTokenKind.TInt _ -> 3
          | HxTokenKind.TFloat _ -> 4
          | HxTokenKind.TKeyword _ -> 5
          | HxTokenKind.TLBrace -> 6
          | HxTokenKind.TRBrace -> 7
          | HxTokenKind.TLParen -> 8
          | HxTokenKind.TRParen -> 9
          | HxTokenKind.TSemicolon -> 10
          | HxTokenKind.TColon -> 11
          | HxTokenKind.TDot -> 12
          | HxTokenKind.TComma -> 13
          | HxTokenKind.TOther _ -> 14) = 0 then let __assign_551 = true in (
          tempLeft := __assign_551;
          __assign_551
        ) else let __assign_552 = false in (
          tempLeft := __assign_552;
          __assign_552
        ));
        let tempRight = ref false in (
          ignore (let _g = self.cur.kind in if (match _g with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 5 then let _g2 = match _g with
            | HxTokenKind.TKeyword __enum_param_553 -> __enum_param_553
            | _ -> failwith "Unexpected enum parameter" in if (match _g2 with
            | HxKeyword.KPackage -> 0
            | HxKeyword.KImport -> 1
            | HxKeyword.KUsing -> 2
            | HxKeyword.KAs -> 3
            | HxKeyword.KClass -> 4
            | HxKeyword.KPublic -> 5
            | HxKeyword.KPrivate -> 6
            | HxKeyword.KStatic -> 7
            | HxKeyword.KFunction -> 8
            | HxKeyword.KReturn -> 9
            | HxKeyword.KIf -> 10
            | HxKeyword.KElse -> 11
            | HxKeyword.KSwitch -> 12
            | HxKeyword.KCase -> 13
            | HxKeyword.KDefault -> 14
            | HxKeyword.KTry -> 15
            | HxKeyword.KCatch -> 16
            | HxKeyword.KThrow -> 17
            | HxKeyword.KWhile -> 18
            | HxKeyword.KDo -> 19
            | HxKeyword.KFor -> 20
            | HxKeyword.KBreak -> 21
            | HxKeyword.KContinue -> 22
            | HxKeyword.KUntyped -> 23
            | HxKeyword.KCast -> 24
            | HxKeyword.KVar -> 25
            | HxKeyword.KFinal -> 26
            | HxKeyword.KNew -> 27
            | HxKeyword.KThis -> 28
            | HxKeyword.KSuper -> 29
            | HxKeyword.KTrue -> 30
            | HxKeyword.KFalse -> 31
            | HxKeyword.KNull -> 32) = 4 then let __assign_554 = true in (
            tempRight := __assign_554;
            __assign_554
          ) else let __assign_555 = false in (
            tempRight := __assign_555;
            __assign_555
          ) else let __assign_556 = false in (
            tempRight := __assign_556;
            __assign_556
          ));
          if !tempLeft || !tempRight then raise (HxRuntime.Hx_break) else ()
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    let className = ref "Unknown" in let functions = HxArray.create () in let fields = HxArray.create () in let hasStaticMain = ref false in (
      ignore (if !sawClass then ignore ((
        ignore (expect self (HxTokenKind.TKeyword (HxKeyword.KClass)) "'class'");
        ignore (let __assign_557 = readIdent self "class name" in (
          className := __assign_557;
          __assign_557
        ));
        ignore (expect self (HxTokenKind.TLBrace) "'{'");
        let members = parseClassMembers self () in (
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get members "functions") in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
            ignore (let __old_558 = !_g in let __new_559 = HxInt.add __old_558 1 in (
              ignore (_g := __new_559);
              __new_559
            ));
            HxArray.push functions fn
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get members "fields") in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
            ignore (let __old_560 = !_g in let __new_561 = HxInt.add __old_560 1 in (
              ignore (_g := __new_561);
              __new_561
            ));
            HxArray.push fields f
          )) done);
          let _g = ref 0 in try while !_g < HxArray.length functions do try ignore (let fn = HxArray.get functions (!_g) in (
            ignore (let __old_562 = !_g in let __new_563 = HxInt.add __old_562 1 in (
              ignore (_g := __new_563);
              __new_563
            ));
            if HxFunctionDecl.getIsStatic fn && HxString.equals (HxFunctionDecl.getName fn) "main" then ignore ((
              ignore (let __assign_564 = true in (
                hasStaticMain := __assign_564;
                __assign_564
              ));
              raise (HxRuntime.Hx_break)
            )) else ()
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ()
        )
      )) else ());
      ignore (try while true do try ignore (let _g = self.cur.kind in if (match _g with
        | HxTokenKind.TEof -> 0
        | HxTokenKind.TIdent _ -> 1
        | HxTokenKind.TString _ -> 2
        | HxTokenKind.TInt _ -> 3
        | HxTokenKind.TFloat _ -> 4
        | HxTokenKind.TKeyword _ -> 5
        | HxTokenKind.TLBrace -> 6
        | HxTokenKind.TRBrace -> 7
        | HxTokenKind.TLParen -> 8
        | HxTokenKind.TRParen -> 9
        | HxTokenKind.TSemicolon -> 10
        | HxTokenKind.TColon -> 11
        | HxTokenKind.TDot -> 12
        | HxTokenKind.TComma -> 13
        | HxTokenKind.TOther _ -> 14) = 0 then raise (HxRuntime.Hx_break) else ignore (if self.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (let __assign_565 = self.peeked in (
          self.cur <- __assign_565;
          __assign_565
        ));
        let __assign_566 = Obj.magic (HxRuntime.hx_null) in (
          self.peeked <- __assign_566;
          __assign_566
        )
      )) else ignore (let __assign_567 = HxLexer.next (self.lex) () in (
        self.cur <- __assign_567;
        __assign_567
      )))) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (expect self (HxTokenKind.TEof) "end of input");
      HxModuleDecl.create (!packagePath) imports (HxClassDecl.create (!className) (!hasStaticMain) functions fields) false (!hasToplevelMain)
    )
  )
)

let parseExprText = fun source -> let p = create source in let e = parseExpr p (fun () -> let tempResult = ref false in let _g = p.cur.kind in (
  ignore (if (match _g with
    | HxTokenKind.TEof -> 0
    | HxTokenKind.TIdent _ -> 1
    | HxTokenKind.TString _ -> 2
    | HxTokenKind.TInt _ -> 3
    | HxTokenKind.TFloat _ -> 4
    | HxTokenKind.TKeyword _ -> 5
    | HxTokenKind.TLBrace -> 6
    | HxTokenKind.TRBrace -> 7
    | HxTokenKind.TLParen -> 8
    | HxTokenKind.TRParen -> 9
    | HxTokenKind.TSemicolon -> 10
    | HxTokenKind.TColon -> 11
    | HxTokenKind.TDot -> 12
    | HxTokenKind.TComma -> 13
    | HxTokenKind.TOther _ -> 14) = 0 then let __assign_568 = true in (
    tempResult := __assign_568;
    __assign_568
  ) else let __assign_569 = false in (
    tempResult := __assign_569;
    __assign_569
  ));
  !tempResult
)) in e

let parseFunctionBodyText = fun bodySource -> try let tempString = ref "" in (
  ignore (if bodySource == Obj.magic (HxRuntime.hx_null) then let __assign_570 = "" in (
    tempString := __assign_570;
    __assign_570
  ) else let __assign_571 = bodySource in (
    tempString := __assign_571;
    __assign_571
  ));
  let src = ("{\n" ^ HxString.toStdString (!tempString)) ^ "\n}" in let p = create src in let tempBool = ref false in let _g = p.cur.kind in (
    ignore (if (match _g with
      | HxTokenKind.TEof -> 0
      | HxTokenKind.TIdent _ -> 1
      | HxTokenKind.TString _ -> 2
      | HxTokenKind.TInt _ -> 3
      | HxTokenKind.TFloat _ -> 4
      | HxTokenKind.TKeyword _ -> 5
      | HxTokenKind.TLBrace -> 6
      | HxTokenKind.TRBrace -> 7
      | HxTokenKind.TLParen -> 8
      | HxTokenKind.TRParen -> 9
      | HxTokenKind.TSemicolon -> 10
      | HxTokenKind.TColon -> 11
      | HxTokenKind.TDot -> 12
      | HxTokenKind.TComma -> 13
      | HxTokenKind.TOther _ -> 14) = 6 then let __assign_572 = true in (
      tempBool := __assign_572;
      __assign_572
    ) else let __assign_573 = false in (
      tempBool := __assign_573;
      __assign_573
    ));
    ignore (if not (!tempBool) then raise (HxRuntime.Hx_return (Obj.repr (let __arr_574 = HxArray.create () in __arr_574))) else ());
    ignore (if p.peeked != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_575 = p.peeked in (
        p.cur <- __assign_575;
        __assign_575
      ));
      let __assign_576 = Obj.magic (HxRuntime.hx_null) in (
        p.peeked <- __assign_576;
        __assign_576
      )
    )) else ignore (let __assign_577 = HxLexer.next (p.lex) () in (
      p.cur <- __assign_577;
      __assign_577
    )));
    parseFunctionBodyStatements p ()
  )
) with
  | HxRuntime.Hx_return __ret_578 -> Obj.obj __ret_578
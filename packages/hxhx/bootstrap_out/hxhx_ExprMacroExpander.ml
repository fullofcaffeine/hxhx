# 1 "hxhx_ExprMacroExpander.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.ExprMacroExpander *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.ExprMacroExpander" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.ExprMacroExpander" } : t)

let isTrueEnv = fun name -> let v = HxSys.getEnv name in let tempString = ref "" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) then let __assign_28 = "" in (
    tempString := __assign_28;
    __assign_28
  ) else let __assign_29 = StringTools.trim v in (
    tempString := __assign_29;
    __assign_29
  ));
  HxString.equals (!tempString) "1" || HxString.equals (!tempString) "true" || HxString.equals (!tempString) "yes"
)

let exprKind = fun e -> let tempResult = ref "" in (
  ignore (match e with
    | HxExpr.ENull -> let __assign_93 = "Null" in (
      tempResult := __assign_93;
      __assign_93
    )
    | HxExpr.EBool _p0 -> (
      ignore _p0;
      let __assign_94 = "Bool" in (
        tempResult := __assign_94;
        __assign_94
      )
    )
    | HxExpr.EString _p0 -> (
      ignore _p0;
      let __assign_95 = "String" in (
        tempResult := __assign_95;
        __assign_95
      )
    )
    | HxExpr.EInt _p0 -> (
      ignore _p0;
      let __assign_96 = "Int" in (
        tempResult := __assign_96;
        __assign_96
      )
    )
    | HxExpr.EFloat _p0 -> (
      ignore _p0;
      let __assign_97 = "Float" in (
        tempResult := __assign_97;
        __assign_97
      )
    )
    | HxExpr.EThis -> let __assign_98 = "This" in (
      tempResult := __assign_98;
      __assign_98
    )
    | HxExpr.ESuper -> let __assign_99 = "Super" in (
      tempResult := __assign_99;
      __assign_99
    )
    | HxExpr.EIdent _p0 -> (
      ignore _p0;
      let __assign_100 = "Ident" in (
        tempResult := __assign_100;
        __assign_100
      )
    )
    | HxExpr.EField (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_101 = "Field" in (
        tempResult := __assign_101;
        __assign_101
      )
    )
    | HxExpr.ECall (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_102 = "Call" in (
        tempResult := __assign_102;
        __assign_102
      )
    )
    | HxExpr.ELambda (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_103 = "Lambda" in (
        tempResult := __assign_103;
        __assign_103
      )
    )
    | HxExpr.ENew (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_104 = "New" in (
        tempResult := __assign_104;
        __assign_104
      )
    )
    | HxExpr.EUnop (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_105 = "Unop" in (
        tempResult := __assign_105;
        __assign_105
      )
    )
    | HxExpr.EBinop (_p0, _p1, _p2) -> (
      ignore _p0;
      ignore _p1;
      ignore _p2;
      let __assign_106 = "Binop" in (
        tempResult := __assign_106;
        __assign_106
      )
    )
    | HxExpr.ETernary (_p0, _p1, _p2) -> (
      ignore _p0;
      ignore _p1;
      ignore _p2;
      let __assign_107 = "Ternary" in (
        tempResult := __assign_107;
        __assign_107
      )
    )
    | HxExpr.EAnon (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_108 = "Anon" in (
        tempResult := __assign_108;
        __assign_108
      )
    )
    | HxExpr.EArrayDecl _p0 -> (
      ignore _p0;
      let __assign_109 = "ArrayDecl" in (
        tempResult := __assign_109;
        __assign_109
      )
    )
    | HxExpr.EArrayAccess (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_110 = "ArrayAccess" in (
        tempResult := __assign_110;
        __assign_110
      )
    )
    | HxExpr.ECast (_p0, _p1) -> (
      ignore _p0;
      ignore _p1;
      let __assign_111 = "Cast" in (
        tempResult := __assign_111;
        __assign_111
      )
    )
    | HxExpr.EUntyped _p0 -> (
      ignore _p0;
      let __assign_112 = "Untyped" in (
        tempResult := __assign_112;
        __assign_112
      )
    )
    | HxExpr.EUnsupported _p0 -> (
      ignore _p0;
      let __assign_113 = "Unsupported" in (
        tempResult := __assign_113;
        __assign_113
      )
    ));
  !tempResult
)

let buildImportMap = fun imports modulePkg -> try let map = HxMap.create_string () in (
  ignore (if imports == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr map)) else ());
  let _g = ref 0 in (
    ignore (try while !_g < HxArray.length imports do try ignore (let raw = HxArray.get imports (!_g) in (
      ignore (let __old_114 = !_g in let __new_115 = HxInt.add __old_114 1 in (
        ignore (_g := __new_115);
        __new_115
      ));
      ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
      let trimmed = StringTools.trim raw in (
        ignore (if HxString.length trimmed = 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if StringTools.endsWith trimmed ".*" then raise (HxRuntime.Hx_continue) else ());
        let tempString = ref "" in (
          ignore (if modulePkg != Obj.magic (HxRuntime.hx_null) && HxString.length modulePkg > 0 && HxString.indexOf trimmed "." 0 = -1 then let c0 = HxString.charCodeAt trimmed 0 in let isUpper = (let __nullable_116 = c0 in let __nullable_117 = 65 in if __nullable_116 == HxRuntime.hx_null then false else Obj.obj __nullable_116 >= __nullable_117) && (let __nullable_118 = c0 in let __nullable_119 = 90 in if __nullable_118 == HxRuntime.hx_null then false else Obj.obj __nullable_118 <= __nullable_119) in if isUpper then let __assign_120 = (HxString.toStdString modulePkg ^ ".") ^ HxString.toStdString trimmed in (
            tempString := __assign_120;
            __assign_120
          ) else let __assign_121 = trimmed in (
            tempString := __assign_121;
            __assign_121
          ) else let __assign_122 = trimmed in (
            tempString := __assign_122;
            __assign_122
          ));
          let full = !tempString in let dot = HxString.lastIndexOf full "." (HxString.length full) in let tempString1 = ref "" in (
            ignore (if dot = -1 then let __assign_123 = full in (
              tempString1 := __assign_123;
              __assign_123
            ) else let __assign_124 = HxString.substr full (HxInt.add dot 1) (-1) in (
              tempString1 := __assign_124;
              __assign_124
            ));
            let shortName = !tempString1 in (
              ignore (if HxString.length shortName = 0 then raise (HxRuntime.Hx_continue) else ());
              if not (HxMap.exists_string map shortName) then ignore (HxMap.set_string map shortName full) else ()
            )
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    map
  )
) with
  | HxRuntime.Hx_return __ret_125 -> Obj.obj __ret_125

let shortenCall = fun callText -> try (
  ignore (if callText == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let hx_open = HxString.indexOf callText "(" 0 in let tempString = ref "" in (
    ignore (if hx_open = -1 then let __assign_136 = callText in (
      tempString := __assign_136;
      __assign_136
    ) else let __assign_137 = HxString.substr callText 0 hx_open in (
      tempString := __assign_137;
      __assign_137
    ));
    let tempString1 = ref "" in (
      ignore (if hx_open = -1 then let __assign_138 = "" in (
        tempString1 := __assign_138;
        __assign_138
      ) else let __assign_139 = HxString.substr callText hx_open (-1) in (
        tempString1 := __assign_139;
        __assign_139
      ));
      let parts = HxString.split (!tempString) "." in (
        ignore (if HxArray.length parts <= 2 then raise (HxRuntime.Hx_return (Obj.repr callText)) else ());
        ((HxString.toStdString (HxArray.get parts (HxInt.sub (HxArray.length parts) 2)) ^ ".") ^ HxString.toStdString (HxArray.get parts (HxInt.sub (HxArray.length parts) 1))) ^ HxString.toStdString (!tempString1)
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_140 -> Obj.obj __ret_140

let matchAllowlistedCall = fun renderedCall allowed allowKeys importMap modulePkg -> try (
  ignore (if renderedCall == Obj.magic (HxRuntime.hx_null) || HxString.length renderedCall = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  ignore (if HxMap.exists_string allowed renderedCall then raise (HxRuntime.Hx_return (Obj.repr renderedCall)) else ());
  let firstDot = HxString.indexOf renderedCall "." 0 in (
    ignore (if firstDot <> -1 then ignore (let head = HxString.substr renderedCall 0 firstDot in let rest = HxString.substr renderedCall firstDot (-1) in if importMap != Obj.magic (HxRuntime.hx_null) && HxMap.exists_string importMap head then ignore (let fullHead = HxMap.get_string importMap head in if fullHead != Obj.magic (HxRuntime.hx_null) && HxString.length fullHead > 0 then ignore (let qualified = HxString.toStdString fullHead ^ HxString.toStdString rest in if HxMap.exists_string allowed qualified then raise (HxRuntime.Hx_return (Obj.repr qualified)) else ()) else ()) else ()) else ());
    ignore (if modulePkg != Obj.magic (HxRuntime.hx_null) && HxString.length modulePkg > 0 && not (StringTools.startsWith renderedCall (HxString.toStdString modulePkg ^ ".")) then ignore (let headDot = HxString.indexOf renderedCall "." 0 in let tempString = ref "" in (
      ignore (if headDot = -1 then let __assign_126 = renderedCall in (
        tempString := __assign_126;
        __assign_126
      ) else let __assign_127 = HxString.substr renderedCall 0 headDot in (
        tempString := __assign_127;
        __assign_127
      ));
      let head = !tempString in if HxString.length head > 0 then ignore (let c0 = HxString.charCodeAt head 0 in let isUpper = (let __nullable_128 = c0 in let __nullable_129 = 65 in if __nullable_128 == HxRuntime.hx_null then false else Obj.obj __nullable_128 >= __nullable_129) && (let __nullable_130 = c0 in let __nullable_131 = 90 in if __nullable_130 == HxRuntime.hx_null then false else Obj.obj __nullable_130 <= __nullable_131) in if isUpper then ignore (let qualified = (HxString.toStdString modulePkg ^ ".") ^ HxString.toStdString renderedCall in if HxMap.exists_string allowed qualified then raise (HxRuntime.Hx_return (Obj.repr qualified)) else ()) else ()) else ()
    )) else ());
    let renderedShort = shortenCall renderedCall in let found = ref (Obj.magic (HxRuntime.hx_null)) in let matches = ref 0 in let _g = ref 0 in (
      ignore (try while !_g < HxArray.length allowKeys do try ignore (let k = HxArray.get allowKeys (!_g) in (
        ignore (let __old_132 = !_g in let __new_133 = HxInt.add __old_132 1 in (
          ignore (_g := __new_133);
          __new_133
        ));
        ignore (if k == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
        if HxString.equals (shortenCall k) renderedShort then ignore ((
          ignore (let __assign_134 = k in (
            found := __assign_134;
            __assign_134
          ));
          ignore (matches := HxInt.add (!matches) 1);
          if !matches > 1 then raise (HxRuntime.Hx_break) else ()
        )) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if !matches = 1 then raise (HxRuntime.Hx_return (Obj.repr (!found))) else ());
      Obj.magic (HxRuntime.hx_null)
    )
  )
) with
  | HxRuntime.Hx_return __ret_135 -> Obj.obj __ret_135

let rec renderCalleePath = fun e -> let tempResult = ref (Obj.magic ()) in (
  ignore (match e with
    | HxExpr.EIdent _p0 -> let _g = _p0 in let name = _g in let __assign_142 = name in (
      tempResult := __assign_142;
      __assign_142
    )
    | HxExpr.EField (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let obj = _g in let field = _g1 in let base = renderCalleePath obj in if base == Obj.magic (HxRuntime.hx_null) then let __assign_143 = Obj.magic (HxRuntime.hx_null) in (
      tempResult := __assign_143;
      __assign_143
    ) else let __assign_144 = (HxString.toStdString base ^ ".") ^ HxString.toStdString field in (
      tempResult := __assign_144;
      __assign_144
    )
    | _ -> let __assign_141 = Obj.magic (HxRuntime.hx_null) in (
      tempResult := __assign_141;
      __assign_141
    ));
  !tempResult
)

let escapeStringLiteral = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace s "\\" "\\\\") "\"" "\\\"") "\n" "\\n") "\r" "\\r") "\t" "\\t"
) with
  | HxRuntime.Hx_return __ret_145 -> Obj.obj __ret_145

let renderSimpleCall = fun callee args -> try (
  ignore (if callee == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let path = renderCalleePath callee in (
    ignore (if path == Obj.magic (HxRuntime.hx_null) || HxString.length path = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if args == Obj.magic (HxRuntime.hx_null) || HxArray.length args = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxString.toStdString path ^ "()"))) else ());
    ignore (if HxArray.length args = 1 then ignore (let tempResult = ref (Obj.magic ()) in (
      ignore (let _g = HxArray.get args 0 in if (match _g with
        | HxExpr.ENull -> 0
        | HxExpr.EBool _ -> 1
        | HxExpr.EString _ -> 2
        | HxExpr.EInt _ -> 3
        | HxExpr.EFloat _ -> 4
        | HxExpr.EThis -> 5
        | HxExpr.ESuper -> 6
        | HxExpr.EIdent _ -> 7
        | HxExpr.EField (_, _) -> 8
        | HxExpr.ECall (_, _) -> 9
        | HxExpr.ELambda (_, _) -> 10
        | HxExpr.ENew (_, _) -> 11
        | HxExpr.EUnop (_, _) -> 12
        | HxExpr.EBinop (_, _, _) -> 13
        | HxExpr.ETernary (_, _, _) -> 14
        | HxExpr.EAnon (_, _) -> 15
        | HxExpr.EArrayDecl _ -> 16
        | HxExpr.EArrayAccess (_, _) -> 17
        | HxExpr.ECast (_, _) -> 18
        | HxExpr.EUntyped _ -> 19
        | HxExpr.EUnsupported _ -> 20) = 2 then let _g2 = match _g with
        | HxExpr.EString __enum_param_146 -> __enum_param_146
        | _ -> failwith "Unexpected enum parameter" in let s = _g2 in let __assign_147 = ((HxString.toStdString path ^ "(\"") ^ HxString.toStdString (escapeStringLiteral s)) ^ "\")" in (
        tempResult := __assign_147;
        __assign_147
      ) else let __assign_148 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_148;
        __assign_148
      ));
      raise (HxRuntime.Hx_return (Obj.repr (!tempResult)))
    )) else ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_149 -> Obj.obj __ret_149

let rec rewriteExpr = fun e session allowed allowKeys importMap modulePkg trace depth onExpand -> try (
  ignore (if depth > 4 then raise (HxRuntime.Hx_return (Obj.repr e)) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (match e with
      | HxExpr.EField (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let obj = _g in let field = _g1 in let ro = rewriteExpr obj session allowed allowKeys importMap modulePkg trace depth onExpand in if ro <> obj then let __assign_49 = HxExpr.EField (ro, field) in (
        tempResult := __assign_49;
        __assign_49
      ) else let __assign_50 = e in (
        tempResult := __assign_50;
        __assign_50
      )
      | HxExpr.ECall (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let callee = _g in let args = _g1 in let rc = rewriteExpr callee session allowed allowKeys importMap modulePkg trace depth onExpand in let rargs = HxArray.create () in let argsChanged = ref false in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
          ignore (let __old_51 = !_g2 in let __new_52 = HxInt.add __old_51 1 in (
            ignore (_g2 := __new_52);
            __new_52
          ));
          let ra = rewriteExpr a session allowed allowKeys importMap modulePkg trace depth onExpand in (
            ignore (if ra <> a then ignore (let __assign_53 = true in (
              argsChanged := __assign_53;
              __assign_53
            )) else ());
            HxArray.push rargs ra
          )
        )) done);
        ignore (if trace then ignore (let calleePath = renderCalleePath rc in let tempArray = ref (Obj.magic ()) in (
          ignore (let _g2 = let __arr_54 = HxArray.create () in __arr_54 in (
            ignore (let _g3 = ref 0 in let _g4 = rargs in while !_g3 < HxArray.length _g4 do ignore (let v = HxArray.get _g4 (!_g3) in (
              ignore (let __old_55 = !_g3 in let __new_56 = HxInt.add __old_55 1 in (
                ignore (_g3 := __new_56);
                __new_56
              ));
              HxArray.push _g2 (exprKind v)
            )) done);
            let __assign_57 = _g2 in (
              tempArray := __assign_57;
              __assign_57
            )
          ));
          let argKinds = HxArray.join (!tempArray) "," (fun x -> x) in let tempMaybeString = ref (Obj.magic ()) in (
            ignore (if calleePath == Obj.magic (HxRuntime.hx_null) then let __assign_58 = exprKind rc in (
              tempMaybeString := __assign_58;
              __assign_58
            ) else let __assign_59 = calleePath in (
              tempMaybeString := __assign_59;
              __assign_59
            ));
            print_endline (((("expr_macro_visit callee=" ^ HxString.toStdString (!tempMaybeString)) ^ " args=[") ^ HxString.toStdString argKinds) ^ "]")
          )
        )) else ());
        let candidate = renderSimpleCall rc rargs in (
          ignore (if trace && candidate != Obj.magic (HxRuntime.hx_null) then ignore (print_endline ("expr_macro_candidate raw=" ^ HxString.toStdString candidate)) else ());
          let tempMaybeString1 = ref (Obj.magic ()) in (
            ignore (if candidate == Obj.magic (HxRuntime.hx_null) then let __assign_60 = Obj.magic (HxRuntime.hx_null) in (
              tempMaybeString1 := __assign_60;
              __assign_60
            ) else let __assign_61 = matchAllowlistedCall candidate allowed allowKeys importMap modulePkg in (
              tempMaybeString1 := __assign_61;
              __assign_61
            ));
            let matched = !tempMaybeString1 in if matched != Obj.magic (HxRuntime.hx_null) then (
              ignore (if trace then ignore (print_endline ("expr_macro_expand call=" ^ HxString.toStdString matched)) else ());
              let expandedText = Hxhx_macro_MacroHostClient.macrohostsession_expandExpr session matched in let parsed = HxParser.parseExprText expandedText in (
                ignore (onExpand ());
                let nested = rewriteExpr parsed session allowed allowKeys importMap modulePkg trace (HxInt.add depth 1) onExpand in let __assign_62 = nested in (
                  tempResult := __assign_62;
                  __assign_62
                )
              )
            ) else if !argsChanged || rc <> callee then let __assign_63 = HxExpr.ECall (rc, rargs) in (
              tempResult := __assign_63;
              __assign_63
            ) else let __assign_64 = e in (
              tempResult := __assign_64;
              __assign_64
            )
          )
        )
      )
      | HxExpr.ENew (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let typePath = _g in let args = _g1 in let out = HxArray.create () in let changed = ref false in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
          ignore (let __old_65 = !_g2 in let __new_66 = HxInt.add __old_65 1 in (
            ignore (_g2 := __new_66);
            __new_66
          ));
          let ra = rewriteExpr a session allowed allowKeys importMap modulePkg trace depth onExpand in (
            ignore (if ra <> a then ignore (let __assign_67 = true in (
              changed := __assign_67;
              __assign_67
            )) else ());
            HxArray.push out ra
          )
        )) done);
        if !changed then let __assign_68 = HxExpr.ENew (typePath, out) in (
          tempResult := __assign_68;
          __assign_68
        ) else let __assign_69 = e in (
          tempResult := __assign_69;
          __assign_69
        )
      )
      | HxExpr.EUnop (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let op = _g in let expr = _g1 in let re = rewriteExpr expr session allowed allowKeys importMap modulePkg trace depth onExpand in if re <> expr then let __assign_70 = HxExpr.EUnop (op, re) in (
        tempResult := __assign_70;
        __assign_70
      ) else let __assign_71 = e in (
        tempResult := __assign_71;
        __assign_71
      )
      | HxExpr.EBinop (_p0, _p1, _p2) -> let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let op = _g in let left = _g1 in let right = _g2 in let rl = rewriteExpr left session allowed allowKeys importMap modulePkg trace depth onExpand in let rr = rewriteExpr right session allowed allowKeys importMap modulePkg trace depth onExpand in if rl <> left || rr <> right then let __assign_72 = HxExpr.EBinop (op, rl, rr) in (
        tempResult := __assign_72;
        __assign_72
      ) else let __assign_73 = e in (
        tempResult := __assign_73;
        __assign_73
      )
      | HxExpr.ETernary (_p0, _p1, _p2) -> let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let cond = _g in let thenExpr = _g1 in let elseExpr = _g2 in let rc = rewriteExpr cond session allowed allowKeys importMap modulePkg trace depth onExpand in let rt = rewriteExpr thenExpr session allowed allowKeys importMap modulePkg trace depth onExpand in let re = rewriteExpr elseExpr session allowed allowKeys importMap modulePkg trace depth onExpand in if rc <> cond || rt <> thenExpr || re <> elseExpr then let __assign_74 = HxExpr.ETernary (rc, rt, re) in (
        tempResult := __assign_74;
        __assign_74
      ) else let __assign_75 = e in (
        tempResult := __assign_75;
        __assign_75
      )
      | HxExpr.EAnon (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let fieldNames = _g in let fieldValues = _g1 in let changed = ref false in let outNames = HxArray.create () in let outValues = HxArray.create () in (
        ignore (let _g2 = ref 0 in let _g3 = HxArray.length fieldValues in while !_g2 < _g3 do ignore (let i = let __old_76 = !_g2 in let __new_77 = HxInt.add __old_76 1 in (
          ignore (_g2 := __new_77);
          __old_76
        ) in let v = HxArray.get fieldValues i in let rv = rewriteExpr v session allowed allowKeys importMap modulePkg trace depth onExpand in (
          ignore (if rv <> v then ignore (let __assign_78 = true in (
            changed := __assign_78;
            __assign_78
          )) else ());
          ignore (HxArray.push outNames (HxArray.get fieldNames i));
          HxArray.push outValues rv
        )) done);
        if !changed then let __assign_79 = HxExpr.EAnon (outNames, outValues) in (
          tempResult := __assign_79;
          __assign_79
        ) else let __assign_80 = e in (
          tempResult := __assign_80;
          __assign_80
        )
      )
      | HxExpr.EArrayDecl _p0 -> let _g = _p0 in let values = _g in let out = HxArray.create () in let changed = ref false in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
          ignore (let __old_81 = !_g2 in let __new_82 = HxInt.add __old_81 1 in (
            ignore (_g2 := __new_82);
            __new_82
          ));
          let rv = rewriteExpr v session allowed allowKeys importMap modulePkg trace depth onExpand in (
            ignore (if rv <> v then ignore (let __assign_83 = true in (
              changed := __assign_83;
              __assign_83
            )) else ());
            HxArray.push out rv
          )
        )) done);
        if !changed then let __assign_84 = HxExpr.EArrayDecl out in (
          tempResult := __assign_84;
          __assign_84
        ) else let __assign_85 = e in (
          tempResult := __assign_85;
          __assign_85
        )
      )
      | HxExpr.EArrayAccess (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let arr = _g in let idx = _g1 in let ra = rewriteExpr arr session allowed allowKeys importMap modulePkg trace depth onExpand in let ri = rewriteExpr idx session allowed allowKeys importMap modulePkg trace depth onExpand in if ra <> arr || ri <> idx then let __assign_86 = HxExpr.EArrayAccess (ra, ri) in (
        tempResult := __assign_86;
        __assign_86
      ) else let __assign_87 = e in (
        tempResult := __assign_87;
        __assign_87
      )
      | HxExpr.ECast (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in let hint = _g1 in let re = rewriteExpr expr session allowed allowKeys importMap modulePkg trace depth onExpand in if re <> expr then let __assign_88 = HxExpr.ECast (re, hint) in (
        tempResult := __assign_88;
        __assign_88
      ) else let __assign_89 = e in (
        tempResult := __assign_89;
        __assign_89
      )
      | HxExpr.EUntyped _p0 -> let _g = _p0 in let expr = _g in let re = rewriteExpr expr session allowed allowKeys importMap modulePkg trace depth onExpand in if re <> expr then let __assign_90 = HxExpr.EUntyped re in (
        tempResult := __assign_90;
        __assign_90
      ) else let __assign_91 = e in (
        tempResult := __assign_91;
        __assign_91
      )
      | _ -> let __assign_48 = e in (
        tempResult := __assign_48;
        __assign_48
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_92 -> Obj.obj __ret_92

let rewriteExprOrNull = fun e session allowed allowKeys importMap modulePkg trace depth onExpand -> let tempResult = ref (Obj.magic ()) in (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then let __assign_46 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (Obj.magic (HxRuntime.hx_null))) in (
    tempResult := __assign_46;
    __assign_46
  ) else let __assign_47 = HxEnum.box_if_needed "HxExpr" (Obj.repr (rewriteExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" e)) session allowed allowKeys importMap modulePkg trace depth onExpand)) in (
    tempResult := __assign_47;
    __assign_47
  ));
  !tempResult
)

let rec rewriteStmt = fun s session allowed allowKeys importMap modulePkg trace onExpand -> let tempResult = ref (Obj.magic ()) in (
  ignore (match s with
    | HxStmt.SBlock (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let stmts = _g in let pos = _g1 in let out = HxArray.create () in let changed = ref false in (
      ignore (let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let ss = HxArray.get stmts (!_g2) in (
        ignore (let __old_30 = !_g2 in let __new_31 = HxInt.add __old_30 1 in (
          ignore (_g2 := __new_31);
          __new_31
        ));
        let rs = rewriteStmt ss session allowed allowKeys importMap modulePkg trace onExpand in (
          ignore (if rs <> ss then ignore (let __assign_32 = true in (
            changed := __assign_32;
            __assign_32
          )) else ());
          HxArray.push out rs
        )
      )) done);
      if !changed then let __assign_33 = HxStmt.SBlock (out, pos) in (
        tempResult := __assign_33;
        __assign_33
      ) else let __assign_34 = s in (
        tempResult := __assign_34;
        __assign_34
      )
    )
    | HxStmt.SVar (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in let name = _g in let typeHint = _g1 in let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in let pos = _g3 in let rInit = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (rewriteExprOrNull (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) session allowed allowKeys importMap modulePkg trace 0 onExpand)) in if rInit <> init then let __assign_35 = HxStmt.SVar (name, typeHint, rInit, pos) in (
      tempResult := __assign_35;
      __assign_35
    ) else let __assign_36 = s in (
      tempResult := __assign_36;
      __assign_36
    )
    | HxStmt.SIf (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in let pos = _g3 in let rCond = rewriteExpr cond session allowed allowKeys importMap modulePkg trace 0 onExpand in let rThen = rewriteStmt thenBranch session allowed allowKeys importMap modulePkg trace onExpand in let tempMaybeHxStmt = ref (Obj.magic ()) in (
      ignore (if elseBranch == Obj.magic (HxRuntime.hx_null) then let __assign_37 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" (Obj.magic (HxRuntime.hx_null))) in (
        tempMaybeHxStmt := __assign_37;
        __assign_37
      ) else let __assign_38 = HxEnum.box_if_needed "HxStmt" (Obj.repr (rewriteStmt (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) session allowed allowKeys importMap modulePkg trace onExpand)) in (
        tempMaybeHxStmt := __assign_38;
        __assign_38
      ));
      let rElse = Obj.obj (HxEnum.unbox_or_obj "HxStmt" (!tempMaybeHxStmt)) in if rCond <> cond || rThen <> thenBranch || rElse <> elseBranch then let __assign_39 = HxStmt.SIf (rCond, rThen, rElse, pos) in (
        tempResult := __assign_39;
        __assign_39
      ) else let __assign_40 = s in (
        tempResult := __assign_40;
        __assign_40
      )
    )
    | HxStmt.SReturnVoid _p0 -> (
      ignore _p0;
      let __assign_41 = s in (
        tempResult := __assign_41;
        __assign_41
      )
    )
    | HxStmt.SReturn (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let e = _g in let pos = _g1 in let re = rewriteExpr e session allowed allowKeys importMap modulePkg trace 0 onExpand in if re <> e then let __assign_42 = HxStmt.SReturn (re, pos) in (
      tempResult := __assign_42;
      __assign_42
    ) else let __assign_43 = s in (
      tempResult := __assign_43;
      __assign_43
    )
    | HxStmt.SExpr (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let e = _g in let pos = _g1 in let re = rewriteExpr e session allowed allowKeys importMap modulePkg trace 0 onExpand in if re <> e then let __assign_44 = HxStmt.SExpr (re, pos) in (
      tempResult := __assign_44;
      __assign_44
    ) else let __assign_45 = s in (
      tempResult := __assign_45;
      __assign_45
    ));
  !tempResult
)

let expandResolvedModules = fun modules session allowlist -> try (
  ignore (if modules == Obj.magic (HxRuntime.hx_null) || HxArray.length modules = 0 then ignore (let tempArray = ref (Obj.magic ()) in (
    ignore (if modules == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
      tempArray := __assign_1;
      __assign_1
    ) else let __assign_3 = modules in (
      tempArray := __assign_3;
      __assign_3
    ));
    raise (HxRuntime.Hx_return (Obj.repr (let __anon_4 = HxAnon.create () in (
      ignore (HxAnon.set __anon_4 "modules" (Obj.repr (!tempArray)));
      ignore (HxAnon.set __anon_4 "expandedCount" (Obj.repr 0));
      __anon_4
    ))))
  )) else ());
  ignore (if session == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_5 = HxAnon.create () in (
    ignore (HxAnon.set __anon_5 "modules" (Obj.repr modules));
    ignore (HxAnon.set __anon_5 "expandedCount" (Obj.repr 0));
    __anon_5
  )))) else ());
  ignore (if allowlist == Obj.magic (HxRuntime.hx_null) || HxArray.length allowlist = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_6 = HxAnon.create () in (
    ignore (HxAnon.set __anon_6 "modules" (Obj.repr modules));
    ignore (HxAnon.set __anon_6 "expandedCount" (Obj.repr 0));
    __anon_6
  )))) else ());
  let allowed = HxMap.create_string () in let allowKeys = HxArray.create () in let anyAllowed = ref false in (
    ignore (let _g = ref 0 in try while !_g < HxArray.length allowlist do try ignore (let raw = HxArray.get allowlist (!_g) in (
      ignore (let __old_7 = !_g in let __new_8 = HxInt.add __old_7 1 in (
        ignore (_g := __new_8);
        __new_8
      ));
      ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
      let s = StringTools.trim raw in (
        ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (HxMap.set_string allowed s true);
        ignore (HxArray.push allowKeys s);
        let __assign_9 = true in (
          anyAllowed := __assign_9;
          __assign_9
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if not (!anyAllowed) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_10 = HxAnon.create () in (
      ignore (HxAnon.set __anon_10 "modules" (Obj.repr modules));
      ignore (HxAnon.set __anon_10 "expandedCount" (Obj.repr 0));
      __anon_10
    )))) else ());
    let expandedCount = ref 0 in let out = HxArray.create () in let trace = isTrueEnv "HXHX_TRACE_EXPR_MACROS" in (
      ignore (let _g = ref 0 in try while !_g < HxArray.length modules do try ignore (let m = HxArray.get modules (!_g) in (
        ignore (let __old_11 = !_g in let __new_12 = HxInt.add __old_11 1 in (
          ignore (_g := __new_12);
          __new_12
        ));
        let pm = ResolvedModule.getParsed m in let decl = ParsedModule.getDecl pm () in let modulePkg = HxModuleDecl.getPackagePath decl in let importMap = buildImportMap (HxModuleDecl.getImports decl) modulePkg in let cls = HxModuleDecl.getMainClass decl in let changed = ref false in let newFields = HxArray.create () in (
          ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
            ignore (let __old_13 = !_g2 in let __new_14 = HxInt.add __old_13 1 in (
              ignore (_g2 := __new_14);
              __new_14
            ));
            let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (HxFieldDecl.getInit f)) in let rewritten = Obj.obj (HxEnum.unbox_or_obj "HxExpr" (rewriteExprOrNull (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) session allowed allowKeys importMap modulePkg trace 0 (fun () -> let __old_15 = !expandedCount in let __new_16 = HxInt.add __old_15 1 in (
              ignore (expandedCount := __new_16);
              __old_15
            )))) in (
              ignore (if rewritten <> init then ignore (let __assign_17 = true in (
                changed := __assign_17;
                __assign_17
              )) else ());
              HxArray.push newFields (HxFieldDecl.create (HxFieldDecl.getName f) (HxFieldDecl.getVisibility f) (HxFieldDecl.getIsStatic f) (HxFieldDecl.getTypeHint f) (Obj.obj (HxEnum.unbox_or_obj "HxExpr" rewritten)))
            )
          )) done);
          let newFns = HxArray.create () in (
            ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
              ignore (let __old_18 = !_g2 in let __new_19 = HxInt.add __old_18 1 in (
                ignore (_g2 := __new_19);
                __new_19
              ));
              let body = HxFunctionDecl.getBody fn in let newBody = HxArray.create () in let bodyChanged = ref false in (
                ignore (let _g3 = ref 0 in while !_g3 < HxArray.length body do ignore (let s = HxArray.get body (!_g3) in (
                  ignore (let __old_20 = !_g3 in let __new_21 = HxInt.add __old_20 1 in (
                    ignore (_g3 := __new_21);
                    __new_21
                  ));
                  let rs = rewriteStmt s session allowed allowKeys importMap modulePkg trace (fun () -> let __old_22 = !expandedCount in let __new_23 = HxInt.add __old_22 1 in (
                    ignore (expandedCount := __new_23);
                    __old_22
                  )) in (
                    ignore (if rs <> s then ignore (let __assign_24 = true in (
                      bodyChanged := __assign_24;
                      __assign_24
                    )) else ());
                    HxArray.push newBody rs
                  )
                )) done);
                ignore (if !bodyChanged then ignore (let __assign_25 = true in (
                  changed := __assign_25;
                  __assign_25
                )) else ());
                HxArray.push newFns (HxFunctionDecl.create (HxFunctionDecl.getName fn) (HxFunctionDecl.getVisibility fn) (HxFunctionDecl.getIsStatic fn) (HxFunctionDecl.getArgs fn) (HxFunctionDecl.getReturnTypeHint fn) newBody (HxFunctionDecl.getReturnStringLiteral fn))
              )
            )) done);
            ignore (if not (!changed) then ignore ((
              ignore (HxArray.push out m);
              raise (HxRuntime.Hx_continue)
            )) else ());
            let newCls = HxClassDecl.create (HxClassDecl.getName cls) (HxClassDecl.getHasStaticMain cls) newFns newFields in let newDecl = HxModuleDecl.create (HxModuleDecl.getPackagePath decl) (HxModuleDecl.getImports decl) newCls (HxModuleDecl.getHeaderOnly decl) (HxModuleDecl.getHasToplevelMain decl) in let newParsed = ParsedModule.create (ParsedModule.getSource pm ()) newDecl (ParsedModule.getFilePath pm ()) in let updated = ResolvedModule.create (ResolvedModule.getModulePath m) (ResolvedModule.getFilePath m) newParsed in (
              ignore (HxArray.push out updated);
              if trace then ignore (print_endline ((("expr_macro_module=" ^ HxString.toStdString (ResolvedModule.getModulePath m)) ^ " file=") ^ HxString.toStdString (ResolvedModule.getFilePath m))) else ()
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      let __anon_26 = HxAnon.create () in (
        ignore (HxAnon.set __anon_26 "modules" (Obj.repr out));
        ignore (HxAnon.set __anon_26 "expandedCount" (Obj.repr (!expandedCount)));
        __anon_26
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_27 -> Obj.obj __ret_27
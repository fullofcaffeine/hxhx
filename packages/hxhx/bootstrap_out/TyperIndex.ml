# 1 "TyperIndex.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: TyperIndex *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable byFullName : TyClassInfo.t HxMap.string_map; mutable byShortName : TyClassInfo.t HxArray.t HxMap.string_map }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "TyperIndex"; byFullName = Obj.magic (); byShortName = Obj.magic () } : t) in (
  ignore ((
    ignore (let __assign_1 = HxMap.create_string () in (
      self.byFullName <- __assign_1;
      __assign_1
    ));
    let __assign_2 = HxMap.create_string () in (
      self.byShortName <- __assign_2;
      __assign_2
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "TyperIndex"; byFullName = Obj.magic (); byShortName = Obj.magic () } : t)

let getByFullName = fun self (fullName : string) -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxMap.exists_string (self.byFullName) fullName then let __assign_3 = HxMap.get_string (self.byFullName) fullName in (
    tempResult := __assign_3;
    __assign_3
  ) else let __assign_4 = Obj.magic (HxRuntime.hx_null) in (
    tempResult := __assign_4;
    __assign_4
  ));
  !tempResult
)

let getByShortName = fun self (shortName : string) -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxMap.exists_string (self.byShortName) shortName then let __assign_5 = HxMap.get_string (self.byShortName) shortName in (
    tempResult := __assign_5;
    __assign_5
  ) else let __assign_6 = let __arr_7 = HxArray.create () in __arr_7 in (
    tempResult := __assign_6;
    __assign_6
  ));
  !tempResult
)

let addClass = fun self (info : TyClassInfo.t) -> ignore (try (
  ignore (if info == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let fullName = TyClassInfo.getFullName info () in (
    ignore (HxMap.set_string (self.byFullName) fullName info);
    let shortName = TyClassInfo.getShortName info () in let tempMaybeArray = ref (Obj.magic ()) in (
      ignore (if HxMap.exists_string (self.byShortName) shortName then let __assign_8 = HxMap.get_string (self.byShortName) shortName in (
        tempMaybeArray := __assign_8;
        __assign_8
      ) else let __assign_9 = let __arr_10 = HxArray.create () in __arr_10 in (
        tempMaybeArray := __assign_9;
        __assign_9
      ));
      let arr = !tempMaybeArray in (
        ignore (HxArray.push arr info);
        HxMap.set_string (self.byShortName) shortName arr
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_11 -> Obj.obj __ret_11)

let resolveTypePath = fun self (typePath : string) (packagePath : string) (imports : string HxArray.t) -> try (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let raw = StringTools.trim typePath in (
    ignore (if HxString.length raw = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if HxString.indexOf raw "." 0 >= 0 then ignore (let direct = getByFullName self raw in if direct != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr direct)) else ()) else ());
    ignore (if imports != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in try while !_g < HxArray.length imports do try ignore (let imp = HxArray.get imports (!_g) in (
      ignore (let __old_12 = !_g in let __new_13 = HxInt.add __old_12 1 in (
        ignore (_g := __new_13);
        __new_13
      ));
      ignore (if imp == Obj.magic (HxRuntime.hx_null) || HxString.length imp = 0 then raise (HxRuntime.Hx_continue) else ());
      let parts = HxString.split imp "." in let tempString = ref "" in (
        ignore (if HxArray.length parts = 0 then let __assign_14 = "" in (
          tempString := __assign_14;
          __assign_14
        ) else let __assign_15 = HxArray.get parts (HxInt.sub (HxArray.length parts) 1) in (
          tempString := __assign_15;
          __assign_15
        ));
        let last = !tempString in if HxString.equals last raw then ignore (let hit = getByFullName self imp in if hit != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit)) else ()) else ()
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()) else ());
    let tempString1 = ref "" in (
      ignore (if packagePath == Obj.magic (HxRuntime.hx_null) then let __assign_16 = "" in (
        tempString1 := __assign_16;
        __assign_16
      ) else let __assign_17 = StringTools.trim packagePath in (
        tempString1 := __assign_17;
        __assign_17
      ));
      ignore (if HxString.length (!tempString1) > 0 then ignore (let cur = ref (!tempString1) in try while true do try ignore (let candidate = (HxString.toStdString (!cur) ^ ".") ^ HxString.toStdString raw in let hit = getByFullName self candidate in (
        ignore (if hit != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit)) else ());
        let lastDot = HxString.lastIndexOf (!cur) "." (HxString.length (!cur)) in (
          ignore (if lastDot < 0 then raise (HxRuntime.Hx_break) else ());
          let __assign_18 = HxString.substr (!cur) 0 lastDot in (
            cur := __assign_18;
            __assign_18
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ()) else ());
      let alts = getByShortName self raw in let tempResult = ref (Obj.magic ()) in (
        ignore (if HxArray.length alts = 1 then let __assign_19 = HxArray.get alts 0 in (
          tempResult := __assign_19;
          __assign_19
        ) else let __assign_20 = Obj.magic (HxRuntime.hx_null) in (
          tempResult := __assign_20;
          __assign_20
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_21 -> Obj.obj __ret_21

let classFullName = fun pkg cls -> let tempString = ref "" in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) then let __assign_22 = "" in (
    tempString := __assign_22;
    __assign_22
  ) else let __assign_23 = StringTools.trim pkg in (
    tempString := __assign_23;
    __assign_23
  ));
  let tempResult = ref "" in (
    ignore (if HxString.length (!tempString) = 0 then let __assign_24 = cls in (
      tempResult := __assign_24;
      __assign_24
    ) else let __assign_25 = (HxString.toStdString (!tempString) ^ ".") ^ HxString.toStdString cls in (
      tempResult := __assign_25;
      __assign_25
    ));
    !tempResult
  )
)

let build = fun resolved -> try let idx = create () in (
  ignore (if resolved == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr idx)) else ());
  let _g = ref 0 in (
    ignore (while !_g < HxArray.length resolved do ignore (let m = HxArray.get resolved (!_g) in (
      ignore (let __old_26 = !_g in let __new_27 = HxInt.add __old_26 1 in (
        ignore (_g := __new_27);
        __new_27
      ));
      let pm = ResolvedModule.getParsed m in let decl = ParsedModule.getDecl pm () in let pkg = HxModuleDecl.getPackagePath decl in let cls = HxModuleDecl.getMainClass decl in let clsName = HxClassDecl.getName cls in let full = classFullName pkg clsName in let fields = HxMap.create_string () in (
        ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
          ignore (let __old_28 = !_g2 in let __new_29 = HxInt.add __old_28 1 in (
            ignore (_g2 := __new_29);
            __new_29
          ));
          HxMap.set_string fields (HxFieldDecl.getName f) (TyType.fromHintText (HxFieldDecl.getTypeHint f))
        )) done);
        let statics = HxMap.create_string () in let instances = HxMap.create_string () in (
          ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
            ignore (let __old_30 = !_g2 in let __new_31 = HxInt.add __old_30 1 in (
              ignore (_g2 := __new_31);
              __new_31
            ));
            let fnName = HxFunctionDecl.getName fn in let isStatic = HxFunctionDecl.getIsStatic fn in let args = HxArray.create () in (
              ignore (let _g3 = ref 0 in let _g4 = HxFunctionDecl.getArgs fn in while !_g3 < HxArray.length _g4 do ignore (let a = HxArray.get _g4 (!_g3) in (
                ignore (let __old_32 = !_g3 in let __new_33 = HxInt.add __old_32 1 in (
                  ignore (_g3 := __new_33);
                  __new_33
                ));
                HxArray.push args (TyType.fromHintText (HxFunctionArg.getTypeHint a))
              )) done);
              let retHint = HxFunctionDecl.getReturnTypeHint fn in let tempTyType = ref (Obj.magic ()) in (
                ignore (if HxString.equals fnName "new" then let __assign_34 = TyType.fromHintText full in (
                  tempTyType := __assign_34;
                  __assign_34
                ) else let __assign_35 = TyType.fromHintText retHint in (
                  tempTyType := __assign_35;
                  __assign_35
                ));
                let ret = !tempTyType in let hx_sig = TyFunSig.create fnName isStatic args ret in if isStatic then ignore (HxMap.set_string statics fnName hx_sig) else ignore (HxMap.set_string instances fnName hx_sig)
              )
            )
          )) done);
          addClass idx (TyClassInfo.create full clsName (ResolvedModule.getModulePath m) fields statics instances)
        )
      )
    )) done);
    idx
  )
) with
  | HxRuntime.Hx_return __ret_36 -> Obj.obj __ret_36
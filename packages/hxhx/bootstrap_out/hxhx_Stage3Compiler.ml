# 1 "hxhx_Stage3Compiler.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Stage3Compiler *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Stage3Compiler" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Stage3Compiler" } : t)

let error = fun msg -> (
  ignore (print_endline ("hxhx(stage3): " ^ HxString.toStdString msg));
  2
)

let hasFlag = fun args flag -> try (
  ignore (if args == Obj.magic (HxRuntime.hx_null) || flag == Obj.magic (HxRuntime.hx_null) || HxString.length flag = 0 then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  let _g = ref 0 in (
    ignore (while !_g < HxArray.length args do ignore (let a = HxArray.get args (!_g) in (
      ignore (let __old_1 = !_g in let __new_2 = HxInt.add __old_1 1 in (
        ignore (_g := __new_2);
        __new_2
      ));
      if HxString.equals a flag then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
    )) done);
    false
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let parseGlobalStage3Flags = fun args -> let outDir = ref "" in let typeOnly = ref false in let emitFullBodies = ref false in let noEmit = ref false in let noRun = ref false in let rest = HxArray.create () in let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in match a with
    | "--hxhx-emit-full-bodies" -> ignore ((
      ignore (let __assign_4 = true in (
        emitFullBodies := __assign_4;
        __assign_4
      ));
      i := HxInt.add (!i) 1
    ))
    | "--hxhx-no-emit" -> ignore ((
      ignore (let __assign_5 = true in (
        noEmit := __assign_5;
        __assign_5
      ));
      i := HxInt.add (!i) 1
    ))
    | "--hxhx-no-run" -> ignore ((
      ignore (let __assign_6 = true in (
        noRun := __assign_6;
        __assign_6
      ));
      i := HxInt.add (!i) 1
    ))
    | "--hxhx-out" -> ignore ((
      ignore (if HxInt.add (!i) 1 >= HxArray.length args then ignore (HxType.hx_throw_typed_rtti (Obj.repr "missing value after --hxhx-out") ["Dynamic"; "String"]) else ());
      ignore (let __assign_7 = HxArray.get args (HxInt.add (!i) 1) in (
        outDir := __assign_7;
        __assign_7
      ));
      i := HxInt.add (!i) 2
    ))
    | "--hxhx-type-only" -> ignore ((
      ignore (let __assign_8 = true in (
        typeOnly := __assign_8;
        __assign_8
      ));
      i := HxInt.add (!i) 1
    ))
    | _ -> ignore ((
      ignore (HxArray.push rest a);
      i := HxInt.add (!i) 1
    ))) done);
  let __anon_9 = HxAnon.create () in (
    ignore (HxAnon.set __anon_9 "outDir" (Obj.repr (!outDir)));
    ignore (HxAnon.set __anon_9 "typeOnly" (Obj.repr (!typeOnly)));
    ignore (HxAnon.set __anon_9 "emitFullBodies" (Obj.repr (!emitFullBodies)));
    ignore (HxAnon.set __anon_9 "noEmit" (Obj.repr (!noEmit)));
    ignore (HxAnon.set __anon_9 "noRun" (Obj.repr (!noRun)));
    ignore (HxAnon.set __anon_9 "rest" (Obj.repr rest));
    __anon_9
  )
)

let escapeOneLine = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace s "\\" "\\\\") "\r" "\\r") "\n" "\\n") "\t" "\\t"
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10

let rec countUnsupportedExprsInExpr = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let tempResult = ref 0 in (
    ignore (if e == Obj.magic (HxRuntime.hx_null) then let __assign_11 = 0 in (
      tempResult := __assign_11;
      __assign_11
    ) else match let __enum_idx_94 = e in if __enum_idx_94 == HxRuntime.hx_null then -1 else match Obj.obj __enum_idx_94 with
      | HxExpr.ENull -> 0
      | HxExpr.EBool _ -> 1
      | HxExpr.EString _ -> 2
      | HxExpr.EInt _ -> 3
      | HxExpr.EFloat _ -> 4
      | HxExpr.EEnumValue _ -> 5
      | HxExpr.EThis -> 6
      | HxExpr.ESuper -> 7
      | HxExpr.EIdent _ -> 8
      | HxExpr.EField (_, _) -> 9
      | HxExpr.ECall (_, _) -> 10
      | HxExpr.ELambda (_, _) -> 11
      | HxExpr.ETryCatchRaw _ -> 12
      | HxExpr.ESwitchRaw _ -> 13
      | HxExpr.ESwitch (_, _) -> 14
      | HxExpr.ENew (_, _) -> 15
      | HxExpr.EUnop (_, _) -> 16
      | HxExpr.EBinop (_, _, _) -> 17
      | HxExpr.ETernary (_, _, _) -> 18
      | HxExpr.EAnon (_, _) -> 19
      | HxExpr.EArrayComprehension (_, _, _) -> 20
      | HxExpr.EArrayDecl _ -> 21
      | HxExpr.EArrayAccess (_, _) -> 22
      | HxExpr.ERange (_, _) -> 23
      | HxExpr.ECast (_, _) -> 24
      | HxExpr.EUntyped _ -> 25
      | HxExpr.EUnsupported _ -> 26 with
      | 9 -> let _g = let __enum_param_14 = e in if __enum_param_14 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_14 with
        | HxExpr.EField (__enum_param_13, _) -> __enum_param_13
        | _ -> failwith "Unexpected enum parameter" in (
        ignore (let __enum_param_16 = e in if __enum_param_16 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_16 with
          | HxExpr.EField (_, __enum_param_15) -> __enum_param_15
          | _ -> failwith "Unexpected enum parameter");
        let obj = _g in let __assign_17 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr obj)) in (
          tempResult := __assign_17;
          __assign_17
        )
      )
      | 10 -> let _g = let __enum_param_19 = e in if __enum_param_19 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_19 with
        | HxExpr.ECall (__enum_param_18, _) -> __enum_param_18
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_21 = e in if __enum_param_21 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_21 with
        | HxExpr.ECall (_, __enum_param_20) -> __enum_param_20
        | _ -> failwith "Unexpected enum parameter" in let callee = _g in let args = _g1 in let c = ref (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr callee))) in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
          ignore (let __old_22 = !_g2 in let __new_23 = HxInt.add __old_22 1 in (
            ignore (_g2 := __new_23);
            __new_23
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)))
        )) done);
        let __assign_24 = !c in (
          tempResult := __assign_24;
          __assign_24
        )
      )
      | 11 -> let _g = let __enum_param_26 = e in if __enum_param_26 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_26 with
        | HxExpr.ELambda (__enum_param_25, _) -> __enum_param_25
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_28 = e in if __enum_param_28 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_28 with
        | HxExpr.ELambda (_, __enum_param_27) -> __enum_param_27
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let body = _g1 in let __assign_29 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr body)) in (
          tempResult := __assign_29;
          __assign_29
        )
      )
      | 12 -> let _g = let __enum_param_31 = e in if __enum_param_31 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_31 with
        | HxExpr.ETryCatchRaw __enum_param_30 -> __enum_param_30
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let __assign_32 = 0 in (
          tempResult := __assign_32;
          __assign_32
        )
      )
      | 15 -> let _g = let __enum_param_34 = e in if __enum_param_34 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_34 with
        | HxExpr.ENew (__enum_param_33, _) -> __enum_param_33
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_36 = e in if __enum_param_36 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_36 with
        | HxExpr.ENew (_, __enum_param_35) -> __enum_param_35
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let args = _g1 in let c = ref 0 in (
          ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
            ignore (let __old_37 = !_g2 in let __new_38 = HxInt.add __old_37 1 in (
              ignore (_g2 := __new_38);
              __new_38
            ));
            c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)))
          )) done);
          let __assign_39 = !c in (
            tempResult := __assign_39;
            __assign_39
          )
        )
      )
      | 16 -> let _g = let __enum_param_41 = e in if __enum_param_41 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_41 with
        | HxExpr.EUnop (__enum_param_40, _) -> __enum_param_40
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_43 = e in if __enum_param_43 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_43 with
        | HxExpr.EUnop (_, __enum_param_42) -> __enum_param_42
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let expr = _g1 in let __assign_44 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
          tempResult := __assign_44;
          __assign_44
        )
      )
      | 17 -> let _g = let __enum_param_46 = e in if __enum_param_46 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_46 with
        | HxExpr.EBinop (__enum_param_45, _, _) -> __enum_param_45
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_48 = e in if __enum_param_48 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_48 with
        | HxExpr.EBinop (_, __enum_param_47, _) -> __enum_param_47
        | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_50 = e in if __enum_param_50 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_50 with
        | HxExpr.EBinop (_, _, __enum_param_49) -> __enum_param_49
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let left = _g1 in let right = _g2 in let __assign_51 = HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr left))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr right))) in (
          tempResult := __assign_51;
          __assign_51
        )
      )
      | 18 -> let _g = let __enum_param_53 = e in if __enum_param_53 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_53 with
        | HxExpr.ETernary (__enum_param_52, _, _) -> __enum_param_52
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_55 = e in if __enum_param_55 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_55 with
        | HxExpr.ETernary (_, __enum_param_54, _) -> __enum_param_54
        | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_57 = e in if __enum_param_57 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_57 with
        | HxExpr.ETernary (_, _, __enum_param_56) -> __enum_param_56
        | _ -> failwith "Unexpected enum parameter" in let cond = _g in let thenExpr = _g1 in let elseExpr = _g2 in let __assign_58 = HxInt.add (HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr thenExpr)))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr elseExpr))) in (
        tempResult := __assign_58;
        __assign_58
      )
      | 19 -> let _g = let __enum_param_60 = e in if __enum_param_60 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_60 with
        | HxExpr.EAnon (__enum_param_59, _) -> __enum_param_59
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_62 = e in if __enum_param_62 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_62 with
        | HxExpr.EAnon (_, __enum_param_61) -> __enum_param_61
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let values = _g1 in let c = ref 0 in (
          ignore (let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
            ignore (let __old_63 = !_g2 in let __new_64 = HxInt.add __old_63 1 in (
              ignore (_g2 := __new_64);
              __new_64
            ));
            c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr v)))
          )) done);
          let __assign_65 = !c in (
            tempResult := __assign_65;
            __assign_65
          )
        )
      )
      | 20 -> let _g = let __enum_param_67 = e in if __enum_param_67 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_67 with
        | HxExpr.EArrayComprehension (__enum_param_66, _, _) -> __enum_param_66
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_69 = e in if __enum_param_69 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_69 with
        | HxExpr.EArrayComprehension (_, __enum_param_68, _) -> __enum_param_68
        | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_71 = e in if __enum_param_71 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_71 with
        | HxExpr.EArrayComprehension (_, _, __enum_param_70) -> __enum_param_70
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let iterable = _g1 in let yieldExpr = _g2 in let __assign_72 = HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr iterable))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr yieldExpr))) in (
          tempResult := __assign_72;
          __assign_72
        )
      )
      | 21 -> let _g = let __enum_param_74 = e in if __enum_param_74 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_74 with
        | HxExpr.EArrayDecl __enum_param_73 -> __enum_param_73
        | _ -> failwith "Unexpected enum parameter" in let values = _g in let c = ref 0 in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
          ignore (let __old_75 = !_g2 in let __new_76 = HxInt.add __old_75 1 in (
            ignore (_g2 := __new_76);
            __new_76
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr v)))
        )) done);
        let __assign_77 = !c in (
          tempResult := __assign_77;
          __assign_77
        )
      )
      | 22 -> let _g = let __enum_param_79 = e in if __enum_param_79 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_79 with
        | HxExpr.EArrayAccess (__enum_param_78, _) -> __enum_param_78
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_81 = e in if __enum_param_81 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_81 with
        | HxExpr.EArrayAccess (_, __enum_param_80) -> __enum_param_80
        | _ -> failwith "Unexpected enum parameter" in let arr = _g in let idx = _g1 in let __assign_82 = HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr arr))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr idx))) in (
        tempResult := __assign_82;
        __assign_82
      )
      | 24 -> let _g = let __enum_param_84 = e in if __enum_param_84 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_84 with
        | HxExpr.ECast (__enum_param_83, _) -> __enum_param_83
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_86 = e in if __enum_param_86 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_86 with
        | HxExpr.ECast (_, __enum_param_85) -> __enum_param_85
        | _ -> failwith "Unexpected enum parameter" in let expr = _g in (
        ignore _g1;
        let __assign_87 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
          tempResult := __assign_87;
          __assign_87
        )
      )
      | 25 -> let _g = let __enum_param_89 = e in if __enum_param_89 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_89 with
        | HxExpr.EUntyped __enum_param_88 -> __enum_param_88
        | _ -> failwith "Unexpected enum parameter" in let expr = _g in let __assign_90 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
        tempResult := __assign_90;
        __assign_90
      )
      | 26 -> (
        ignore (let __enum_param_92 = e in if __enum_param_92 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_92 with
          | HxExpr.EUnsupported __enum_param_91 -> __enum_param_91
          | _ -> failwith "Unexpected enum parameter");
        let __assign_93 = 1 in (
          tempResult := __assign_93;
          __assign_93
        )
      )
      | _ -> let __assign_12 = 0 in (
        tempResult := __assign_12;
        __assign_12
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_95 -> Obj.obj __ret_95

let rec collectUnsupportedExprRawInExpr = fun e out max -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxArray.length out >= max then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  if e == Obj.magic (HxRuntime.hx_null) then ignore () else ignore (match let __enum_idx_162 = e in if __enum_idx_162 == HxRuntime.hx_null then -1 else match Obj.obj __enum_idx_162 with
    | HxExpr.ENull -> 0
    | HxExpr.EBool _ -> 1
    | HxExpr.EString _ -> 2
    | HxExpr.EInt _ -> 3
    | HxExpr.EFloat _ -> 4
    | HxExpr.EEnumValue _ -> 5
    | HxExpr.EThis -> 6
    | HxExpr.ESuper -> 7
    | HxExpr.EIdent _ -> 8
    | HxExpr.EField (_, _) -> 9
    | HxExpr.ECall (_, _) -> 10
    | HxExpr.ELambda (_, _) -> 11
    | HxExpr.ETryCatchRaw _ -> 12
    | HxExpr.ESwitchRaw _ -> 13
    | HxExpr.ESwitch (_, _) -> 14
    | HxExpr.ENew (_, _) -> 15
    | HxExpr.EUnop (_, _) -> 16
    | HxExpr.EBinop (_, _, _) -> 17
    | HxExpr.ETernary (_, _, _) -> 18
    | HxExpr.EAnon (_, _) -> 19
    | HxExpr.EArrayComprehension (_, _, _) -> 20
    | HxExpr.EArrayDecl _ -> 21
    | HxExpr.EArrayAccess (_, _) -> 22
    | HxExpr.ERange (_, _) -> 23
    | HxExpr.ECast (_, _) -> 24
    | HxExpr.EUntyped _ -> 25
    | HxExpr.EUnsupported _ -> 26 with
    | 9 -> ignore (let _g = let __enum_param_97 = e in if __enum_param_97 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_97 with
      | HxExpr.EField (__enum_param_96, _) -> __enum_param_96
      | _ -> failwith "Unexpected enum parameter" in (
      ignore (let __enum_param_99 = e in if __enum_param_99 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_99 with
        | HxExpr.EField (_, __enum_param_98) -> __enum_param_98
        | _ -> failwith "Unexpected enum parameter");
      let obj = _g in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr obj)) out max
    ))
    | 10 -> ignore (let _g = let __enum_param_101 = e in if __enum_param_101 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_101 with
      | HxExpr.ECall (__enum_param_100, _) -> __enum_param_100
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_103 = e in if __enum_param_103 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_103 with
      | HxExpr.ECall (_, __enum_param_102) -> __enum_param_102
      | _ -> failwith "Unexpected enum parameter" in let callee = _g in let args = _g1 in (
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr callee)) out max);
      let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
        ignore (let __old_104 = !_g2 in let __new_105 = HxInt.add __old_104 1 in (
          ignore (_g2 := __new_105);
          __new_105
        ));
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)) out max
      )) done
    ))
    | 11 -> ignore (let _g = let __enum_param_107 = e in if __enum_param_107 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_107 with
      | HxExpr.ELambda (__enum_param_106, _) -> __enum_param_106
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_109 = e in if __enum_param_109 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_109 with
      | HxExpr.ELambda (_, __enum_param_108) -> __enum_param_108
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let body = _g1 in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr body)) out max
    ))
    | 12 -> ignore (let _g = let __enum_param_111 = e in if __enum_param_111 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_111 with
      | HxExpr.ETryCatchRaw __enum_param_110 -> __enum_param_110
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      ()
    ))
    | 15 -> ignore (let _g = let __enum_param_113 = e in if __enum_param_113 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_113 with
      | HxExpr.ENew (__enum_param_112, _) -> __enum_param_112
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_115 = e in if __enum_param_115 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_115 with
      | HxExpr.ENew (_, __enum_param_114) -> __enum_param_114
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let args = _g1 in let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
        ignore (let __old_116 = !_g2 in let __new_117 = HxInt.add __old_116 1 in (
          ignore (_g2 := __new_117);
          __new_117
        ));
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)) out max
      )) done
    ))
    | 16 -> ignore (let _g = let __enum_param_119 = e in if __enum_param_119 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_119 with
      | HxExpr.EUnop (__enum_param_118, _) -> __enum_param_118
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_121 = e in if __enum_param_121 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_121 with
      | HxExpr.EUnop (_, __enum_param_120) -> __enum_param_120
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let expr = _g1 in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
    | 17 -> ignore (let _g = let __enum_param_123 = e in if __enum_param_123 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_123 with
      | HxExpr.EBinop (__enum_param_122, _, _) -> __enum_param_122
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_125 = e in if __enum_param_125 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_125 with
      | HxExpr.EBinop (_, __enum_param_124, _) -> __enum_param_124
      | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_127 = e in if __enum_param_127 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_127 with
      | HxExpr.EBinop (_, _, __enum_param_126) -> __enum_param_126
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let left = _g1 in let right = _g2 in (
        ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr left)) out max);
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr right)) out max
      )
    ))
    | 18 -> ignore (let _g = let __enum_param_129 = e in if __enum_param_129 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_129 with
      | HxExpr.ETernary (__enum_param_128, _, _) -> __enum_param_128
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_131 = e in if __enum_param_131 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_131 with
      | HxExpr.ETernary (_, __enum_param_130, _) -> __enum_param_130
      | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_133 = e in if __enum_param_133 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_133 with
      | HxExpr.ETernary (_, _, __enum_param_132) -> __enum_param_132
      | _ -> failwith "Unexpected enum parameter" in let cond = _g in let thenExpr = _g1 in let elseExpr = _g2 in (
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond)) out max);
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr thenExpr)) out max);
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr elseExpr)) out max
    ))
    | 19 -> ignore (let _g = let __enum_param_135 = e in if __enum_param_135 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_135 with
      | HxExpr.EAnon (__enum_param_134, _) -> __enum_param_134
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_137 = e in if __enum_param_137 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_137 with
      | HxExpr.EAnon (_, __enum_param_136) -> __enum_param_136
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let values = _g1 in let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
        ignore (let __old_138 = !_g2 in let __new_139 = HxInt.add __old_138 1 in (
          ignore (_g2 := __new_139);
          __new_139
        ));
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr v)) out max
      )) done
    ))
    | 20 -> ignore (let _g = let __enum_param_141 = e in if __enum_param_141 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_141 with
      | HxExpr.EArrayComprehension (__enum_param_140, _, _) -> __enum_param_140
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_143 = e in if __enum_param_143 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_143 with
      | HxExpr.EArrayComprehension (_, __enum_param_142, _) -> __enum_param_142
      | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_145 = e in if __enum_param_145 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_145 with
      | HxExpr.EArrayComprehension (_, _, __enum_param_144) -> __enum_param_144
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let iterable = _g1 in let yieldExpr = _g2 in (
        ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr iterable)) out max);
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr yieldExpr)) out max
      )
    ))
    | 21 -> ignore (let _g = let __enum_param_147 = e in if __enum_param_147 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_147 with
      | HxExpr.EArrayDecl __enum_param_146 -> __enum_param_146
      | _ -> failwith "Unexpected enum parameter" in let values = _g in let _g2 = ref 0 in while !_g2 < HxArray.length values do ignore (let v = HxArray.get values (!_g2) in (
      ignore (let __old_148 = !_g2 in let __new_149 = HxInt.add __old_148 1 in (
        ignore (_g2 := __new_149);
        __new_149
      ));
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr v)) out max
    )) done)
    | 22 -> ignore (let _g = let __enum_param_151 = e in if __enum_param_151 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_151 with
      | HxExpr.EArrayAccess (__enum_param_150, _) -> __enum_param_150
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_153 = e in if __enum_param_153 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_153 with
      | HxExpr.EArrayAccess (_, __enum_param_152) -> __enum_param_152
      | _ -> failwith "Unexpected enum parameter" in let arr = _g in let idx = _g1 in (
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr arr)) out max);
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr idx)) out max
    ))
    | 24 -> ignore (let _g = let __enum_param_155 = e in if __enum_param_155 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_155 with
      | HxExpr.ECast (__enum_param_154, _) -> __enum_param_154
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_157 = e in if __enum_param_157 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_157 with
      | HxExpr.ECast (_, __enum_param_156) -> __enum_param_156
      | _ -> failwith "Unexpected enum parameter" in let expr = _g in (
      ignore _g1;
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
    | 25 -> ignore (let _g = let __enum_param_159 = e in if __enum_param_159 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_159 with
      | HxExpr.EUntyped __enum_param_158 -> __enum_param_158
      | _ -> failwith "Unexpected enum parameter" in let expr = _g in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max)
    | 26 -> ignore (let _g = let __enum_param_161 = e in if __enum_param_161 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_161 with
      | HxExpr.EUnsupported __enum_param_160 -> __enum_param_160
      | _ -> failwith "Unexpected enum parameter" in let raw = _g in if HxArray.length out < max then ignore (HxArray.push out raw) else ())
    | _ -> ignore ())
) with
  | HxRuntime.Hx_return __ret_163 -> Obj.obj __ret_163

let rec collectUnsupportedExprRawInStmt = fun s out max -> try (
  ignore (if HxArray.length out >= max then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  match s with
    | HxStmt.SBlock (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let stmts = _g in (
      ignore _g1;
      let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let ss = HxArray.get stmts (!_g2) in (
        ignore (let __old_164 = !_g2 in let __new_165 = HxInt.add __old_164 1 in (
          ignore (_g2 := __new_165);
          __new_165
        ));
        collectUnsupportedExprRawInStmt ss out max
      )) done
    ))
    | HxStmt.SVar (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in (
      ignore _g;
      ignore _g1;
      let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in (
        ignore _g3;
        collectUnsupportedExprRawInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) out max
      )
    ))
    | HxStmt.SIf (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
      ignore _g3;
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond)) out max);
      ignore (collectUnsupportedExprRawInStmt thenBranch out max);
      if elseBranch != Obj.magic (HxRuntime.hx_null) then ignore (collectUnsupportedExprRawInStmt (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) out max) else ()
    ))
    | HxStmt.SForIn (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let _g3 = _p3 in (
      ignore _g;
      let iterable = _g1 in let body = _g2 in (
        ignore _g3;
        ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr iterable)) out max);
        collectUnsupportedExprRawInStmt body out max
      )
    ))
    | HxStmt.SSwitch (_p0, _p1, _p2) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let scrutinee = _g in let cases = _g1 in (
      ignore _g2;
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr scrutinee)) out max);
      let _g3 = ref 0 in while !_g3 < HxArray.length cases do ignore (let c = HxArray.get cases (!_g3) in (
        ignore (let __old_166 = !_g3 in let __new_167 = HxInt.add __old_166 1 in (
          ignore (_g3 := __new_167);
          __new_167
        ));
        collectUnsupportedExprRawInStmt (Obj.obj (HxAnon.get c "body")) out max
      )) done
    ))
    | HxStmt.SReturnVoid _p0 -> ignore (let _g = _p0 in (
      ignore _g;
      ()
    ))
    | HxStmt.SReturn (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
    | HxStmt.SExpr (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
) with
  | HxRuntime.Hx_return __ret_168 -> Obj.obj __ret_168

let collectUnsupportedExprRawInModule = fun pm max -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let out = HxArray.create () in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_169 = !_g in let __new_170 = HxInt.add __old_169 1 in (
      ignore (_g := __new_170);
      __new_170
    ));
    collectUnsupportedExprRawInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (HxFieldDecl.getInit f))) out max
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_171 = !_g in let __new_172 = HxInt.add __old_171 1 in (
      ignore (_g := __new_172);
      __new_172
    ));
    let _g2 = ref 0 in let _g3 = HxFunctionDecl.getBody fn in while !_g2 < HxArray.length _g3 do ignore (let s = HxArray.get _g3 (!_g2) in (
      ignore (let __old_173 = !_g2 in let __new_174 = HxInt.add __old_173 1 in (
        ignore (_g2 := __new_174);
        __new_174
      ));
      collectUnsupportedExprRawInStmt s out max
    )) done
  )) done);
  out
)

let rec countUnsupportedExprsInStmt = fun s -> let tempResult = ref 0 in (
  ignore (match s with
    | HxStmt.SBlock (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let stmts = _g in (
      ignore _g1;
      let c = ref 0 in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let ss = HxArray.get stmts (!_g2) in (
          ignore (let __old_175 = !_g2 in let __new_176 = HxInt.add __old_175 1 in (
            ignore (_g2 := __new_176);
            __new_176
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInStmt ss)
        )) done);
        let __assign_177 = !c in (
          tempResult := __assign_177;
          __assign_177
        )
      )
    )
    | HxStmt.SVar (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in (
      ignore _g;
      ignore _g1;
      let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in (
        ignore _g3;
        let __assign_178 = countUnsupportedExprsInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) in (
          tempResult := __assign_178;
          __assign_178
        )
      )
    )
    | HxStmt.SIf (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
      ignore _g3;
      let tempNumber = ref 0 in (
        ignore (if elseBranch == Obj.magic (HxRuntime.hx_null) then let __assign_179 = 0 in (
          tempNumber := __assign_179;
          __assign_179
        ) else let __assign_180 = countUnsupportedExprsInStmt (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) in (
          tempNumber := __assign_180;
          __assign_180
        ));
        let __assign_181 = HxInt.add (HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond))) (countUnsupportedExprsInStmt thenBranch)) (!tempNumber) in (
          tempResult := __assign_181;
          __assign_181
        )
      )
    )
    | HxStmt.SForIn (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let _g3 = _p3 in (
      ignore _g;
      let iterable = _g1 in let body = _g2 in (
        ignore _g3;
        let __assign_182 = HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr iterable))) (countUnsupportedExprsInStmt body) in (
          tempResult := __assign_182;
          __assign_182
        )
      )
    )
    | HxStmt.SSwitch (_p0, _p1, _p2) -> let _g = _p0 in let _g1 = _p1 in let _g2 = _p2 in let scrutinee = _g in let cases = _g1 in (
      ignore _g2;
      let c = ref (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr scrutinee))) in (
        ignore (let _g3 = ref 0 in while !_g3 < HxArray.length cases do ignore (let cc = HxArray.get cases (!_g3) in (
          ignore (let __old_183 = !_g3 in let __new_184 = HxInt.add __old_183 1 in (
            ignore (_g3 := __new_184);
            __new_184
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInStmt (Obj.obj (HxAnon.get cc "body")))
        )) done);
        let __assign_185 = !c in (
          tempResult := __assign_185;
          __assign_185
        )
      )
    )
    | HxStmt.SReturnVoid _p0 -> let _g = _p0 in (
      ignore _g;
      let __assign_186 = 0 in (
        tempResult := __assign_186;
        __assign_186
      )
    )
    | HxStmt.SReturn (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      let __assign_187 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
        tempResult := __assign_187;
        __assign_187
      )
    )
    | HxStmt.SExpr (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      let __assign_188 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
        tempResult := __assign_188;
        __assign_188
      )
    ));
  !tempResult
)

let countUnsupportedExprsInModule = fun pm -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let c = ref 0 in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_189 = !_g in let __new_190 = HxInt.add __old_189 1 in (
      ignore (_g := __new_190);
      __new_190
    ));
    c := HxInt.add (!c) (countUnsupportedExprsInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (HxFieldDecl.getInit f))))
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_191 = !_g in let __new_192 = HxInt.add __old_191 1 in (
      ignore (_g := __new_192);
      __new_192
    ));
    let _g2 = ref 0 in let _g3 = HxFunctionDecl.getBody fn in while !_g2 < HxArray.length _g3 do ignore (let s = HxArray.get _g3 (!_g2) in (
      ignore (let __old_193 = !_g2 in let __new_194 = HxInt.add __old_193 1 in (
        ignore (_g2 := __new_194);
        __new_194
      ));
      c := HxInt.add (!c) (countUnsupportedExprsInStmt s)
    )) done
  )) done);
  !c
)

let countUnsupportedExprsInFunction = fun fn -> let c = ref 0 in let _g = ref 0 in let _g1 = HxFunctionDecl.getBody fn in (
  ignore (while !_g < HxArray.length _g1 do ignore (let s = HxArray.get _g1 (!_g) in (
    ignore (let __old_195 = !_g in let __new_196 = HxInt.add __old_195 1 in (
      ignore (_g := __new_196);
      __new_196
    ));
    c := HxInt.add (!c) (countUnsupportedExprsInStmt s)
  )) done);
  !c
)

let bool01 = fun v -> let tempResult = ref "" in (
  ignore (if v then let __assign_197 = "1" in (
    tempResult := __assign_197;
    __assign_197
  ) else let __assign_198 = "0" in (
    tempResult := __assign_198;
    __assign_198
  ));
  !tempResult
)

let formatException = fun e -> try (
  ignore (if HxType.isOfType e (HxType.class_ "String") then raise (HxRuntime.Hx_return (Obj.repr (Obj.obj e))) else ());
  try (
    ignore (if HxType.isOfType e (HxType.class_ "TyperError") then ignore (let te = Obj.obj e in let p = TyperError.getPos te () in let tempNumber = ref 0 in (
      ignore (if p == Obj.magic (HxRuntime.hx_null) then let __assign_199 = 0 in (
        tempNumber := __assign_199;
        __assign_199
      ) else let __assign_200 = HxPos.getLine p () in (
        tempNumber := __assign_200;
        __assign_200
      ));
      let line = !tempNumber in let tempNumber1 = ref 0 in (
        ignore (if p == Obj.magic (HxRuntime.hx_null) then let __assign_201 = 0 in (
          tempNumber1 := __assign_201;
          __assign_201
        ) else let __assign_202 = HxPos.getColumn p () in (
          tempNumber1 := __assign_202;
          __assign_202
        ));
        let col = !tempNumber1 in raise (HxRuntime.Hx_return (Obj.repr ((((((HxString.toStdString (TyperError.getFilePath te ()) ^ ":") ^ string_of_int line) ^ ":") ^ string_of_int col) ^ ": ") ^ HxString.toStdString (TyperError.getMessage te ()))))
      )
    )) else ());
    let msg = HxRuntime.dynamic_toStdString e in let debug = HxSys.getEnv "HXHX_DEBUG_EXN" in (
      ignore (if HxString.equals debug "1" || HxString.equals debug "true" || HxString.equals debug "yes" then ignore (let details = ref ("typeof=" ^ HxString.toStdString (HxRuntime.dynamic_toStdString (Obj.repr (let __typeof_v_203 = e in if HxRuntime.is_null __typeof_v_203 then Type.TNull else if HxRuntime.is_boxed_bool __typeof_v_203 then Type.TBool else if Obj.is_int __typeof_v_203 then Type.TInt else if Obj.tag __typeof_v_203 = Obj.double_tag then Type.TFloat else if Obj.tag __typeof_v_203 = Obj.string_tag then Type.TClass (HxType.class_ "String") else if Obj.tag __typeof_v_203 = Obj.closure_tag then Type.TFunction else match HxEnum.name_opt __typeof_v_203 with
        | Some __enum_name_204 -> Type.TEnum (HxType.enum_ __enum_name_204)
        | _ -> let __cls_205 = HxType.getClass __typeof_v_203 in if HxRuntime.is_null __cls_205 then Type.TObject else Type.TClass __cls_205)))) in let cls = HxType.getClass e in (
        ignore (if cls != Obj.magic (HxRuntime.hx_null) then ignore (details := HxString.toStdString (!details) ^ ";class=" ^ HxString.toStdString (HxType.getClassName cls)) else ());
        let fields = HxAnon.fields e in (
          ignore (if fields != Obj.magic (HxRuntime.hx_null) && HxArray.length fields > 0 then ignore (details := HxString.toStdString (!details) ^ ";fields=" ^ HxString.toStdString (HxArray.join fields "," (fun x -> x))) else ());
          ignore (if HxAnon.has e "message" then ignore (details := HxString.toStdString (!details) ^ ";message=" ^ HxString.toStdString (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "message")))) else ());
          raise (HxRuntime.Hx_return (Obj.repr ((HxString.toStdString msg ^ " :: ") ^ HxString.toStdString (!details))))
        )
      )) else ());
      raise (HxRuntime.Hx_return (Obj.repr msg))
    )
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_206 -> raise (HxRuntime.Hx_return __ret_206)
    | HxRuntime.Hx_exception (__exn_v_207, __exn_tags_208) -> if true then let _hx = (__exn_v_207 : Obj.t) in (
      ignore _hx;
      raise (HxRuntime.Hx_return (Obj.repr (HxRuntime.dynamic_toStdString e)))
    ) else HxRuntime.hx_throw_typed __exn_v_207 __exn_tags_208
    | __exn_209 -> if true then let _hx = (Obj.repr __exn_209 : Obj.t) in (
      ignore _hx;
      raise (HxRuntime.Hx_return (Obj.repr (HxRuntime.dynamic_toStdString e)))
    ) else raise (__exn_209)
) with
  | HxRuntime.Hx_return __ret_210 -> Obj.obj __ret_210

let haxelibBin = fun () -> let v = HxSys.getEnv "HAXELIB_BIN" in let tempResult = ref "" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_211 = "haxelib" in (
    tempResult := __assign_211;
    __assign_211
  ) else let __assign_212 = v in (
    tempResult := __assign_212;
    __assign_212
  ));
  !tempResult
)

let resolveHaxelibSpecViaProcess = fun lib -> try let classPaths = HxArray.create () in let defines = HxArray.create () in let macros = HxArray.create () in let unknownArgs = HxArray.create () in let p = Sys_io_Process.create (haxelibBin ()) (let __arr_219 = HxArray.create () in (
  ignore (HxArray.push __arr_219 "path");
  ignore (HxArray.push __arr_219 lib);
  __arr_219
)) (HxRuntime.hx_null) in (
  ignore (try try while true do try ignore (let raw = let __obj_220 = p.stdout in __obj_220.readLine (Obj.magic __obj_220) () in let line = StringTools.trim raw in (
    ignore (if HxString.length line = 0 then raise (HxRuntime.Hx_continue) else ());
    ignore (if not (StringTools.startsWith line "-") then ignore ((
      ignore (HxArray.push classPaths line);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "-D " then ignore (let def = StringTools.trim (HxString.substr line 3 (-1)) in (
      ignore (if HxString.length def > 0 then ignore (HxArray.push defines def) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "--macro " then ignore (let expr = StringTools.trim (HxString.substr line 8 (-1)) in (
      ignore (if HxString.length expr > 0 then ignore (HxArray.push macros expr) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "-cp " then ignore (let cp = StringTools.trim (HxString.substr line 4 (-1)) in (
      ignore (if HxString.length cp > 0 then ignore (HxArray.push classPaths cp) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "--class-path " then ignore (let cp = StringTools.trim (HxString.substr line 13 (-1)) in (
      ignore (if HxString.length cp > 0 then ignore (HxArray.push classPaths cp) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    HxArray.push unknownArgs line
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> () with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_221 -> raise (HxRuntime.Hx_return __ret_221)
    | HxRuntime.Hx_exception (__exn_v_222, __exn_tags_223) -> if HxRuntime.tags_has __exn_tags_223 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_222 : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else HxRuntime.hx_throw_typed __exn_v_222 __exn_tags_223
    | __exn_224 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_224) : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else raise (__exn_224));
  let code = Sys_io_Process.exitCode p () in (
    ignore (if code <> 0 then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ((("haxelib path " ^ HxString.toStdString lib) ^ " failed with exit code ") ^ string_of_int code)) ["Dynamic"; "String"]))) else ());
    let __anon_225 = HxAnon.create () in (
      ignore (HxAnon.set __anon_225 "classPaths" (Obj.repr classPaths));
      ignore (HxAnon.set __anon_225 "defines" (Obj.repr defines));
      ignore (HxAnon.set __anon_225 "macros" (Obj.repr macros));
      ignore (HxAnon.set __anon_225 "unknownArgs" (Obj.repr unknownArgs));
      __anon_225
    )
  )
) with
  | HxRuntime.Hx_return __ret_226 -> Obj.obj __ret_226

let findHaxeLibrariesHxml = fun lib cwd -> try let tempString = ref "" in (
  ignore (if cwd == Obj.magic (HxRuntime.hx_null) || HxString.length cwd = 0 then let __assign_237 = "." in (
    tempString := __assign_237;
    __assign_237
  ) else let __assign_238 = cwd in (
    tempString := __assign_238;
    __assign_238
  ));
  let _g = ref 0 in (
    ignore (try while !_g < 10 do try ignore ((
      ignore (let __old_239 = !_g in let __new_240 = HxInt.add __old_239 1 in (
        ignore (_g := __new_240);
        __old_239
      ));
      let candidate = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_241 = HxArray.create () in (
        ignore (HxArray.push __arr_241 (!tempString));
        ignore (HxArray.push __arr_241 "haxe_libraries");
        ignore (HxArray.push __arr_241 (HxString.toStdString lib ^ ".hxml"));
        __arr_241
      ))) in (
        ignore (if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ());
        let parent = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_242 = HxArray.create () in (
          ignore (HxArray.push __arr_242 (!tempString));
          ignore (HxArray.push __arr_242 "..");
          __arr_242
        ))) in (
          ignore (if HxString.equals parent (!tempString) then raise (HxRuntime.Hx_break) else ());
          let __assign_243 = parent in (
            tempString := __assign_243;
            __assign_243
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ""
  )
) with
  | HxRuntime.Hx_return __ret_244 -> Obj.obj __ret_244

let rec resolveHaxelibSpec = fun lib cwd seen depth -> try (
  ignore (if depth > 25 then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ("haxelib resolution depth exceeded while resolving: " ^ HxString.toStdString lib)) ["Dynamic"; "String"]))) else ());
  ignore (if HxMap.exists_string seen lib then raise (HxRuntime.Hx_return (Obj.repr (let __anon_213 = HxAnon.create () in (
    ignore (HxAnon.set __anon_213 "classPaths" (Obj.repr (let __arr_214 = HxArray.create () in __arr_214)));
    ignore (HxAnon.set __anon_213 "defines" (Obj.repr (let __arr_215 = HxArray.create () in __arr_215)));
    ignore (HxAnon.set __anon_213 "macros" (Obj.repr (let __arr_216 = HxArray.create () in __arr_216)));
    ignore (HxAnon.set __anon_213 "unknownArgs" (Obj.repr (let __arr_217 = HxArray.create () in __arr_217)));
    __anon_213
  )))) else ());
  ignore (HxMap.set_string seen lib true);
  let hxmlPath = findHaxeLibrariesHxml lib cwd in (
    ignore (if HxString.length hxmlPath > 0 then raise (HxRuntime.Hx_return (Obj.repr (resolveHaxelibSpecFromHxml hxmlPath cwd seen depth))) else ());
    resolveHaxelibSpecViaProcess lib
  )
) with
  | HxRuntime.Hx_return __ret_218 -> Obj.obj __ret_218
and resolveHaxelibSpecFromHxml = fun hxmlPath cwd seen depth -> try let args = Hxhx_Hxml.parseFile hxmlPath in (
  ignore (if args == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ("failed to parse haxelib hxml: " ^ HxString.toStdString hxmlPath)) ["Dynamic"; "String"]))) else ());
  let classPaths = HxArray.create () in let defines = HxArray.create () in let macros = HxArray.create () in let unknownArgs = HxArray.create () in let i = ref 0 in (
    ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in match a with
      | "--class-path" | "-cp" | "-p" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf classPaths v 0 = -1 then ignore (HxArray.push classPaths v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | "--library" | "-lib" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length args then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ((("malformed haxelib hxml (missing value after " ^ HxString.toStdString a) ^ "): ") ^ HxString.toStdString hxmlPath)) ["Dynamic"; "String"]))) else ());
        let dep = HxArray.get args (HxInt.add (!i) 1) in let depSpec = resolveHaxelibSpec dep cwd seen (HxInt.add depth 1) in (
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "classPaths") in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
            ignore (let __old_227 = !_g in let __new_228 = HxInt.add __old_227 1 in (
              ignore (_g := __new_228);
              __new_228
            ));
            if cp == Obj.magic (HxRuntime.hx_null) || HxString.length cp = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf classPaths cp 0 = -1 then ignore (HxArray.push classPaths cp) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "defines") in while !_g < HxArray.length _g1 do ignore (let d = HxArray.get _g1 (!_g) in (
            ignore (let __old_229 = !_g in let __new_230 = HxInt.add __old_229 1 in (
              ignore (_g := __new_230);
              __new_230
            ));
            if d == Obj.magic (HxRuntime.hx_null) || HxString.length d = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf defines d 0 = -1 then ignore (HxArray.push defines d) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "macros") in while !_g < HxArray.length _g1 do ignore (let m = HxArray.get _g1 (!_g) in (
            ignore (let __old_231 = !_g in let __new_232 = HxInt.add __old_231 1 in (
              ignore (_g := __new_232);
              __new_232
            ));
            if m == Obj.magic (HxRuntime.hx_null) || HxString.length m = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf macros m 0 = -1 then ignore (HxArray.push macros m) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "unknownArgs") in while !_g < HxArray.length _g1 do ignore (let u = HxArray.get _g1 (!_g) in (
            ignore (let __old_233 = !_g in let __new_234 = HxInt.add __old_233 1 in (
              ignore (_g := __new_234);
              __new_234
            ));
            if u == Obj.magic (HxRuntime.hx_null) || HxString.length u = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf unknownArgs u 0 = -1 then ignore (HxArray.push unknownArgs u) else ())
          )) done);
          i := HxInt.add (!i) 2
        )
      ))
      | "--macro" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf macros v 0 = -1 then ignore (HxArray.push macros v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | "-D" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf defines v 0 = -1 then ignore (HxArray.push defines v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | _ -> ignore ((
        ignore (if a != Obj.magic (HxRuntime.hx_null) && HxString.length a > 0 && StringTools.startsWith a "-" then ignore (if a == Obj.magic (HxRuntime.hx_null) || HxString.length a = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf unknownArgs a 0 = -1 then ignore (HxArray.push unknownArgs a) else ())) else ());
        i := HxInt.add (!i) 1
      ))) done);
    let __anon_235 = HxAnon.create () in (
      ignore (HxAnon.set __anon_235 "classPaths" (Obj.repr classPaths));
      ignore (HxAnon.set __anon_235 "defines" (Obj.repr defines));
      ignore (HxAnon.set __anon_235 "macros" (Obj.repr macros));
      ignore (HxAnon.set __anon_235 "unknownArgs" (Obj.repr unknownArgs));
      __anon_235
    )
  )
) with
  | HxRuntime.Hx_return __ret_236 -> Obj.obj __ret_236

let absFromCwd = fun cwd path -> try (
  ignore (if path == Obj.magic (HxRuntime.hx_null) || HxString.length path = 0 then raise (HxRuntime.Hx_return (Obj.repr cwd)) else ());
  let tempResult = ref "" in (
    ignore (if Haxe_io_Path.isAbsolute path then let __assign_245 = Haxe_io_Path.normalize path in (
      tempResult := __assign_245;
      __assign_245
    ) else let __assign_246 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_247 = HxArray.create () in (
      ignore (HxArray.push __arr_247 cwd);
      ignore (HxArray.push __arr_247 path);
      __arr_247
    ))) in (
      tempResult := __assign_246;
      __assign_246
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_248 -> Obj.obj __ret_248

let inferRepoRootForScripts = fun () -> try let env = HxSys.getEnv "HXHX_REPO_ROOT" in (
  ignore (if env != Obj.magic (HxRuntime.hx_null) && HxString.length env > 0 && HxFileSystem.exists env && HxFileSystem.isDirectory env then raise (HxRuntime.Hx_return (Obj.repr env)) else ());
  let prog = HxSys.programPath () in (
    ignore (if prog == Obj.magic (HxRuntime.hx_null) || HxString.length prog = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let tempString = ref "" in (
      ignore (try let __assign_249 = HxFileSystem.fullPath prog in (
        tempString := __assign_249;
        __assign_249
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_250 -> raise (HxRuntime.Hx_return __ret_250)
        | HxRuntime.Hx_exception (__exn_v_251, __exn_tags_252) -> if true then let _hx = (__exn_v_251 : Obj.t) in (
          ignore _hx;
          let __assign_253 = prog in (
            tempString := __assign_253;
            __assign_253
          )
        ) else HxRuntime.hx_throw_typed __exn_v_251 __exn_tags_252
        | __exn_254 -> if true then let _hx = (Obj.repr __exn_254 : Obj.t) in (
          ignore _hx;
          let __assign_255 = prog in (
            tempString := __assign_255;
            __assign_255
          )
        ) else raise (__exn_254));
      let tempString1 = ref "" in (
        ignore (try let __assign_256 = Haxe_io_Path.directory (!tempString) in (
          tempString1 := __assign_256;
          __assign_256
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_257 -> raise (HxRuntime.Hx_return __ret_257)
          | HxRuntime.Hx_exception (__exn_v_258, __exn_tags_259) -> if true then let _hx = (__exn_v_258 : Obj.t) in (
            ignore _hx;
            let __assign_260 = "" in (
              tempString1 := __assign_260;
              __assign_260
            )
          ) else HxRuntime.hx_throw_typed __exn_v_258 __exn_tags_259
          | __exn_261 -> if true then let _hx = (Obj.repr __exn_261 : Obj.t) in (
            ignore _hx;
            let __assign_262 = "" in (
              tempString1 := __assign_262;
              __assign_262
            )
          ) else raise (__exn_261));
        ignore (if !tempString1 == Obj.magic (HxRuntime.hx_null) || HxString.length (!tempString1) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
        let _g = ref 0 in (
          ignore (try while !_g < 10 do try ignore ((
            ignore (let __old_263 = !_g in let __new_264 = HxInt.add __old_263 1 in (
              ignore (_g := __new_264);
              __old_263
            ));
            let candidate = Haxe_io_Path.join (let __arr_265 = HxArray.create () in (
              ignore (HxArray.push __arr_265 (!tempString1));
              ignore (HxArray.push __arr_265 "scripts");
              ignore (HxArray.push __arr_265 "hxhx");
              ignore (HxArray.push __arr_265 "build-hxhx-macro-host.sh");
              __arr_265
            )) in (
              ignore (if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr (!tempString1))) else ());
              let parent = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_266 = HxArray.create () in (
                ignore (HxArray.push __arr_266 (!tempString1));
                ignore (HxArray.push __arr_266 "..");
                __arr_266
              ))) in (
                ignore (if HxString.equals parent (!tempString1) then raise (HxRuntime.Hx_break) else ());
                let __assign_267 = parent in (
                  tempString1 := __assign_267;
                  __assign_267
                )
              )
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ""
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_268 -> Obj.obj __ret_268

let trim = fun s -> let tempResult = ref "" in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then let __assign_269 = "" in (
    tempResult := __assign_269;
    __assign_269
  ) else let __assign_270 = StringTools.trim s in (
    tempResult := __assign_270;
    __assign_270
  ));
  !tempResult
)

let isTrueEnv = fun name -> let v = trim (HxSys.getEnv name) in HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes"

let parseDelimitedList = fun raw -> try let out = HxArray.create () in (
  ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let s = StringTools.trim raw in (
    ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
    let tempArray = ref (Obj.magic ()) in (
      ignore (if HxString.indexOf s ";" 0 <> -1 then let __assign_271 = HxString.split s ";" in (
        tempArray := __assign_271;
        __assign_271
      ) else let __assign_272 = HxString.split s "," in (
        tempArray := __assign_272;
        __assign_272
      ));
      let _g = ref 0 in (
        ignore (try while !_g < HxArray.length (!tempArray) do try ignore (let p = HxArray.get (!tempArray) (!_g) in (
          ignore (let __old_273 = !_g in let __new_274 = HxInt.add __old_273 1 in (
            ignore (_g := __new_274);
            __new_274
          ));
          ignore (if p == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
          let t = StringTools.trim p in (
            ignore (if HxString.length t = 0 then raise (HxRuntime.Hx_continue) else ());
            if HxArray.indexOf out t 0 = -1 then ignore (HxArray.push out t) else ()
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        out
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_275 -> Obj.obj __ret_275

let isBuiltinMacroExpr = fun expr -> let e = trim expr in StringTools.startsWith e "BuiltinMacros." || StringTools.startsWith e "hxhxmacrohost.BuiltinMacros." || StringTools.startsWith e "hxhxmacrohost.BuiltinMacros" || StringTools.startsWith e "nullSafety(" || StringTools.startsWith e "Validator.register("

let anyNonBuiltinMacro = fun exprs -> try let _g = ref 0 in (
  ignore (while !_g < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g) in (
    ignore (let __old_276 = !_g in let __new_277 = HxInt.add __old_276 1 in (
      ignore (_g := __new_277);
      __new_277
    ));
    if not (isBuiltinMacroExpr e) then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_278 -> Obj.obj __ret_278

let shouldAutoBuildMacroHost = fun () -> let v = trim (HxSys.getEnv "HXHX_MACRO_HOST_AUTO_BUILD") in HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes"

let buildMacroHostExe = fun repoRoot extraCp entrypoints -> let script = Haxe_io_Path.join (let __arr_279 = HxArray.create () in (
  ignore (HxArray.push __arr_279 repoRoot);
  ignore (HxArray.push __arr_279 "scripts");
  ignore (HxArray.push __arr_279 "hxhx");
  ignore (HxArray.push __arr_279 "build-hxhx-macro-host.sh");
  __arr_279
)) in (
  ignore (if not (HxFileSystem.exists script) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("missing macro host build script: " ^ HxString.toStdString script)) ["Dynamic"; "String"]) else ());
  let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if extraCp != Obj.magic (HxRuntime.hx_null) && HxArray.length extraCp > 0 then let __assign_280 = HxArray.join extraCp ":" (fun x -> x) in (
      tempMaybeString := __assign_280;
      __assign_280
    ) else let __assign_281 = "" in (
      tempMaybeString := __assign_281;
      __assign_281
    ));
    ignore (HxSys.putEnv "HXHX_MACRO_HOST_EXTRA_CP" (Some (!tempMaybeString)));
    let tempMaybeString1 = ref (Obj.magic ()) in (
      ignore (if entrypoints != Obj.magic (HxRuntime.hx_null) && HxArray.length entrypoints > 0 then let __assign_282 = HxArray.join entrypoints ";" (fun x -> x) in (
        tempMaybeString1 := __assign_282;
        __assign_282
      ) else let __assign_283 = "" in (
        tempMaybeString1 := __assign_283;
        __assign_283
      ));
      ignore (HxSys.putEnv "HXHX_MACRO_HOST_ENTRYPOINTS" (Some (!tempMaybeString1)));
      let p = Sys_io_Process.create "bash" (let __arr_284 = HxArray.create () in (
        ignore (HxArray.push __arr_284 script);
        __arr_284
      )) (HxRuntime.hx_null) in let lines = HxArray.create () in (
        ignore (try while true do ignore (HxArray.push lines (let __obj_285 = p.stdout in __obj_285.readLine (Obj.magic __obj_285) ())) done with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_286 -> raise (HxRuntime.Hx_return __ret_286)
          | HxRuntime.Hx_exception (__exn_v_287, __exn_tags_288) -> if HxRuntime.tags_has __exn_tags_288 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_287 : Haxe_io_Eof.t) in (
            ignore _hx;
            ()
          ) else HxRuntime.hx_throw_typed __exn_v_287 __exn_tags_288
          | __exn_289 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_289) : Haxe_io_Eof.t) in (
            ignore _hx;
            ()
          ) else raise (__exn_289));
        let code = Sys_io_Process.exitCode p () in (
          ignore (Sys_io_Process.close p ());
          ignore (if code <> 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("macro host build failed with exit code " ^ string_of_int code)) ["Dynamic"; "String"]) else ());
          let exe = ref "" in let _g = ref 0 in let _g1 = HxArray.length lines in (
            ignore (while !_g < _g1 do ignore (let i = let __old_290 = !_g in let __new_291 = HxInt.add __old_290 1 in (
              ignore (_g := __new_291);
              __old_290
            ) in let l = trim (HxArray.get lines i) in if HxString.length l > 0 then ignore (let __assign_292 = l in (
              exe := __assign_292;
              __assign_292
            )) else ()) done);
            ignore (if HxString.length (!exe) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "macro host build produced no executable path") ["Dynamic"; "String"]) else ());
            !exe
          )
        )
      )
    )
  )
)

let findBuildMacroExprs = fun source -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let lex = HxLexer.create source in let t = ref (HxLexer.next lex ()) in (
    ignore (try while true do try ignore ((
      ignore (let _g = (!t).kind in match _g with
        | HxTokenKind.TEof -> raise (HxRuntime.Hx_return (Obj.repr out))
        | HxTokenKind.TKeyword _p0 -> ignore (let _g2 = _p0 in if (match _g2 with
          | HxKeyword.KPackage -> 0
          | HxKeyword.KImport -> 1
          | HxKeyword.KUsing -> 2
          | HxKeyword.KAs -> 3
          | HxKeyword.KClass -> 4
          | HxKeyword.KPublic -> 5
          | HxKeyword.KPrivate -> 6
          | HxKeyword.KStatic -> 7
          | HxKeyword.KInline -> 8
          | HxKeyword.KFunction -> 9
          | HxKeyword.KReturn -> 10
          | HxKeyword.KIf -> 11
          | HxKeyword.KElse -> 12
          | HxKeyword.KSwitch -> 13
          | HxKeyword.KCase -> 14
          | HxKeyword.KDefault -> 15
          | HxKeyword.KTry -> 16
          | HxKeyword.KCatch -> 17
          | HxKeyword.KThrow -> 18
          | HxKeyword.KWhile -> 19
          | HxKeyword.KDo -> 20
          | HxKeyword.KFor -> 21
          | HxKeyword.KIn -> 22
          | HxKeyword.KBreak -> 23
          | HxKeyword.KContinue -> 24
          | HxKeyword.KUntyped -> 25
          | HxKeyword.KCast -> 26
          | HxKeyword.KVar -> 27
          | HxKeyword.KFinal -> 28
          | HxKeyword.KNew -> 29
          | HxKeyword.KThis -> 30
          | HxKeyword.KSuper -> 31
          | HxKeyword.KTrue -> 32
          | HxKeyword.KFalse -> 33
          | HxKeyword.KNull -> 34) = 4 then raise (HxRuntime.Hx_return (Obj.repr out)) else ignore ())
        | HxTokenKind.TOther _p0 -> ignore (let _g2 = _p0 in let code = _g2 in if code = 64 then ignore (let t2 = HxLexer.next lex () in let t3 = HxLexer.next lex () in let t4 = HxLexer.next lex () in let tempBool = ref false in (
          ignore (let _g3 = t2.kind in let _g1 = t3.kind in let _g4 = t4.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 11 then if (match _g1 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 1 then let _g5 = match _g1 with
            | HxTokenKind.TIdent __enum_param_293 -> __enum_param_293
            | _ -> failwith "Unexpected enum parameter" in match _g5 with
            | "autoBuild" -> if (match _g4 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 8 then let __assign_295 = true in (
              tempBool := __assign_295;
              __assign_295
            ) else let __assign_296 = false in (
              tempBool := __assign_296;
              __assign_296
            )
            | "build" -> if (match _g4 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 8 then let __assign_297 = true in (
              tempBool := __assign_297;
              __assign_297
            ) else let __assign_298 = false in (
              tempBool := __assign_298;
              __assign_298
            )
            | _ -> let __assign_294 = false in (
              tempBool := __assign_294;
              __assign_294
            ) else let __assign_299 = false in (
            tempBool := __assign_299;
            __assign_299
          ) else let __assign_300 = false in (
            tempBool := __assign_300;
            __assign_300
          ));
          let isMeta = !tempBool in (
            ignore (if not (isMeta) then ignore ((
              ignore (let __assign_301 = HxLexer.next lex () in (
                t := __assign_301;
                __assign_301
              ));
              raise (HxRuntime.Hx_continue)
            )) else ());
            let startIndex = HxInt.add (HxPos.getIndex (t4.pos) ()) 1 in let depth = ref 1 in let endIndex = ref startIndex in let inner = ref (HxLexer.next lex ()) in (
              ignore (try while true do try ignore ((
                ignore (let _g3 = (!inner).kind in match _g3 with
                  | HxTokenKind.TEof -> ignore ((
                    ignore (let __assign_302 = HxString.length source in (
                      endIndex := __assign_302;
                      __assign_302
                    ));
                    raise (HxRuntime.Hx_break)
                  ))
                  | HxTokenKind.TLParen -> ignore (depth := HxInt.add (!depth) 1)
                  | HxTokenKind.TRParen -> ignore ((
                    ignore (depth := HxInt.sub (!depth) 1);
                    if !depth = 0 then ignore ((
                      ignore (let __assign_303 = HxPos.getIndex ((!inner).pos) () in (
                        endIndex := __assign_303;
                        __assign_303
                      ));
                      raise (HxRuntime.Hx_break)
                    )) else ()
                  ))
                  | _ -> ignore ());
                let __assign_304 = HxLexer.next lex () in (
                  inner := __assign_304;
                  __assign_304
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              let expr = trim (HxString.substring source startIndex (!endIndex)) in (
                ignore (if HxString.length expr > 0 then ignore (HxArray.push out expr) else ());
                ignore (let __assign_305 = HxLexer.next lex () in (
                  t := __assign_305;
                  __assign_305
                ));
                raise (HxRuntime.Hx_continue)
              )
            )
          )
        )) else ignore ())
        | _ -> ignore ());
      let __assign_306 = HxLexer.next lex () in (
        t := __assign_306;
        __assign_306
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    out
  )
) with
  | HxRuntime.Hx_return __ret_307 -> Obj.obj __ret_307

let parseGeneratedMembers = fun members -> try (
  ignore (if members == Obj.magic (HxRuntime.hx_null) || HxArray.length members = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_308 = HxAnon.create () in (
    ignore (HxAnon.set __anon_308 "functions" (Obj.repr (let __arr_309 = HxArray.create () in __arr_309)));
    ignore (HxAnon.set __anon_308 "fields" (Obj.repr (let __arr_310 = HxArray.create () in __arr_310)));
    __anon_308
  )))) else ());
  let combined = HxArray.join members "\n" (fun x -> x) in let fake = ("class __HxHxBuildFields {\n" ^ HxString.toStdString combined) ^ "\n}\n" in let p = HxParser.create fake in let decl = HxParser.parseModule p (Obj.magic (HxRuntime.hx_null)) in let cls = HxModuleDecl.getMainClass decl in let __anon_311 = HxAnon.create () in (
    ignore (HxAnon.set __anon_311 "functions" (Obj.repr (HxClassDecl.getFunctions cls)));
    ignore (HxAnon.set __anon_311 "fields" (Obj.repr (HxClassDecl.getFields cls)));
    __anon_311
  )
) with
  | HxRuntime.Hx_return __ret_312 -> Obj.obj __ret_312

let buildFieldsPayloadForParsed = fun pm -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let items = HxArray.create () in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_313 = !_g in let __new_314 = HxInt.add __old_313 1 in (
      ignore (_g := __new_314);
      __new_314
    ));
    HxArray.push items (let __anon_315 = HxAnon.create () in (
      ignore (HxAnon.set __anon_315 "name" (Obj.repr (HxFunctionDecl.getName fn)));
      ignore (HxAnon.set __anon_315 "kind" (Obj.repr "fun"));
      ignore (HxAnon.set __anon_315 "isStatic" (Obj.repr (HxFunctionDecl.getIsStatic fn)));
      ignore (HxAnon.set __anon_315 "visibility" (Obj.repr (HxRuntime.dynamic_toStdString (Obj.repr (HxFunctionDecl.getVisibility fn)))));
      __anon_315
    ))
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_316 = !_g in let __new_317 = HxInt.add __old_316 1 in (
      ignore (_g := __new_317);
      __new_317
    ));
    HxArray.push items (let __anon_318 = HxAnon.create () in (
      ignore (HxAnon.set __anon_318 "name" (Obj.repr (HxFieldDecl.getName f)));
      ignore (HxAnon.set __anon_318 "kind" (Obj.repr "var"));
      ignore (HxAnon.set __anon_318 "isStatic" (Obj.repr (HxFieldDecl.getIsStatic f)));
      ignore (HxAnon.set __anon_318 "visibility" (Obj.repr (HxRuntime.dynamic_toStdString (Obj.repr (HxFieldDecl.getVisibility f)))));
      __anon_318
    ))
  )) done);
  let parts = HxArray.create () in (
    ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen "c" (string_of_int (HxArray.length items))));
    ignore (let _g = ref 0 in let _g1 = HxArray.length items in while !_g < _g1 do ignore (let i = let __old_319 = !_g in let __new_320 = HxInt.add __old_319 1 in (
      ignore (_g := __new_320);
      __old_319
    ) in let it = HxArray.get items i in (
      ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("n" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "name")))));
      ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("k" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "kind")))));
      let tempString = ref "" in (
        ignore (if HxRuntime.dynamic_equals (Obj.obj (HxAnon.get (Obj.repr it) "isStatic")) (HxRuntime.box_bool true) then let __assign_321 = "1" in (
          tempString := __assign_321;
          __assign_321
        ) else let __assign_322 = "0" in (
          tempString := __assign_322;
          __assign_322
        ));
        ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("s" ^ string_of_int i) (!tempString)));
        HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("v" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "visibility"))))
      )
    )) done);
    HxArray.join parts " " (fun x -> x)
  )
)

let runOne = fun args -> try let tempStruct = ref (Obj.magic ()) in (
  ignore (try let __assign_323 = parseGlobalStage3Flags args in (
    tempStruct := __assign_323;
    __assign_323
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_324 -> raise (HxRuntime.Hx_return __ret_324)
    | HxRuntime.Hx_exception (__exn_v_325, __exn_tags_326) -> if true then let e = (__exn_v_325 : Obj.t) in (
      ignore e;
      raise (HxRuntime.Hx_return (Obj.repr (error (HxRuntime.dynamic_toStdString e))))
    ) else HxRuntime.hx_throw_typed __exn_v_325 __exn_tags_326
    | __exn_327 -> if true then let e = (Obj.repr __exn_327 : Obj.t) in (
      ignore e;
      raise (HxRuntime.Hx_return (Obj.repr (error (HxRuntime.dynamic_toStdString e))))
    ) else raise (__exn_327));
  let outDir = Obj.obj (HxAnon.get (!tempStruct) "outDir") in let typeOnly = Obj.obj (HxAnon.get (!tempStruct) "typeOnly") in let emitFullBodies = Obj.obj (HxAnon.get (!tempStruct) "emitFullBodies") in let noEmit = ref (Obj.obj (HxAnon.get (!tempStruct) "noEmit")) in let noRun = Obj.obj (HxAnon.get (!tempStruct) "noRun") in let rest = Obj.obj (HxAnon.get (!tempStruct) "rest") in let parsed = Hxhx_Stage1Compiler.stage1args_parse rest true in (
    ignore (if parsed == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 2)) else ());
    let sawInterp = parsed.defines != Obj.magic (HxRuntime.hx_null) && HxArray.indexOf (parsed.defines) "interp=1" 0 <> -1 in let emitFullBodies = emitFullBodies || sawInterp in (
      ignore (if HxString.length outDir = 0 then ignore (let __assign_328 = !noEmit || parsed.noOutput in (
        noEmit := __assign_328;
        __assign_328
      )) else ());
      let inferMainFromMacroExpr = fun expr -> try (
        ignore (if expr == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
        let s = ref (StringTools.trim expr) in (
          ignore (if HxString.length (!s) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
          let p = HxString.indexOf (!s) "(" 0 in (
            ignore (if p <> -1 then ignore (let __assign_329 = StringTools.trim (HxString.substr (!s) 0 p) in (
              s := __assign_329;
              __assign_329
            )) else ());
            let lastDot = HxString.lastIndexOf (!s) "." (HxString.length (!s)) in (
              ignore (if lastDot = -1 then raise (HxRuntime.Hx_return (Obj.repr (!s))) else ());
              StringTools.trim (HxString.substr (!s) 0 lastDot)
            )
          )
        )
      ) with
        | HxRuntime.Hx_return __ret_330 -> Obj.obj __ret_330 in let roots0 = HxArray.create () in (
        ignore (if parsed.main != Obj.magic (HxRuntime.hx_null) && HxString.length (parsed.main) > 0 then ignore (HxArray.push roots0 (parsed.main)) else ignore (if parsed.roots != Obj.magic (HxRuntime.hx_null) && HxArray.length (parsed.roots) > 0 then ignore (let _g = ref 0 in let _g1 = parsed.roots in while !_g < HxArray.length _g1 do ignore (let r = HxArray.get _g1 (!_g) in (
          ignore (let __old_331 = !_g in let __new_332 = HxInt.add __old_331 1 in (
            ignore (_g := __new_332);
            __new_332
          ));
          if r != Obj.magic (HxRuntime.hx_null) && HxString.length r > 0 then ignore (HxArray.push roots0 r) else ()
        )) done) else ignore (if HxArray.length (parsed.macros) > 0 then ignore (let inferred = inferMainFromMacroExpr (HxArray.get (parsed.macros) 0) in (
          ignore (if HxString.length inferred = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "missing -main <TypeName>"))) else ());
          HxArray.push roots0 inferred
        )) else ignore ((
          ignore (if Hxhx_Stage1Compiler.stage1args_getHadCmd parsed then ignore ((
            ignore (print_endline "stage3=skipped_cmd_only");
            raise (HxRuntime.Hx_return (Obj.repr 0))
          )) else ());
          raise (HxRuntime.Hx_return (Obj.repr (error "missing -main <TypeName>")))
        )))));
        ignore (if typeOnly && HxArray.length (parsed.macros) > 0 then ignore (let _g = ref 0 in let _g1 = HxArray.length (parsed.macros) in while !_g < _g1 do ignore (let i = let __old_333 = !_g in let __new_334 = HxInt.add __old_333 1 in (
          ignore (_g := __new_334);
          __old_333
        ) in print_endline ((("macro_skipped[" ^ string_of_int i) ^ "]=") ^ HxString.toStdString (HxArray.get (parsed.macros) i))) done) else ());
        let exprMacros = parseDelimitedList (HxSys.getEnv "HXHX_EXPR_MACROS") in let macroSession = ref (Obj.magic (HxRuntime.hx_null)) in let tempString = ref "" in (
          ignore (try let __assign_335 = HxSys.getCwd () in (
            tempString := __assign_335;
            __assign_335
          ) with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_336 -> raise (HxRuntime.Hx_return __ret_336)
            | HxRuntime.Hx_exception (__exn_v_337, __exn_tags_338) -> if true then let _hx = (__exn_v_337 : Obj.t) in (
              ignore _hx;
              let __assign_339 = "." in (
                tempString := __assign_339;
                __assign_339
              )
            ) else HxRuntime.hx_throw_typed __exn_v_337 __exn_tags_338
            | __exn_340 -> if true then let _hx = (Obj.repr __exn_340 : Obj.t) in (
              ignore _hx;
              let __assign_341 = "." in (
                tempString := __assign_341;
                __assign_341
              )
            ) else raise (__exn_340));
          let cwd = absFromCwd (!tempString) (parsed.cwd) in (
            ignore (if not (HxFileSystem.exists cwd) || not (HxFileSystem.isDirectory cwd) then raise (HxRuntime.Hx_return (Obj.repr (error ("cwd is not a directory: " ^ HxString.toStdString cwd)))) else ());
            let tempString1 = ref "" in (
              ignore (if HxString.length outDir > 0 then let __assign_342 = outDir in (
                tempString1 := __assign_342;
                __assign_342
              ) else let __assign_343 = "out_stage3" in (
                tempString1 := __assign_343;
                __assign_343
              ));
              let outAbs = absFromCwd cwd (!tempString1) in (
                ignore (Hxhx_macro_MacroState.reset ());
                let tempArray = ref (Obj.magic ()) in (
                  ignore (let seen = HxMap.create_string () in let out = HxArray.create () in (
                    ignore (let _g = ref 0 in let _g1 = parsed.libs in while !_g < HxArray.length _g1 do ignore (let lib = HxArray.get _g1 (!_g) in (
                      ignore (let __old_344 = !_g in let __new_345 = HxInt.add __old_344 1 in (
                        ignore (_g := __new_345);
                        __new_345
                      ));
                      HxArray.push out (resolveHaxelibSpec lib cwd seen 0)
                    )) done);
                    let __assign_346 = out in (
                      tempArray := __assign_346;
                      __assign_346
                    )
                  ));
                  let tempArray1 = ref (Obj.magic ()) in (
                    ignore (let out = HxArray.create () in (
                      ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                        ignore (let __old_347 = !_g in let __new_348 = HxInt.add __old_347 1 in (
                          ignore (_g := __new_348);
                          __new_348
                        ));
                        let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "defines") in while !_g2 < HxArray.length _g1 do ignore (let d = HxArray.get _g1 (!_g2) in (
                          ignore (let __old_349 = !_g2 in let __new_350 = HxInt.add __old_349 1 in (
                            ignore (_g2 := __new_350);
                            __new_350
                          ));
                          if HxArray.indexOf out d 0 = -1 then ignore (HxArray.push out d) else ()
                        )) done
                      )) done);
                      let __assign_351 = out in (
                        tempArray1 := __assign_351;
                        __assign_351
                      )
                    ));
                    let allDefines = HxArray.concat (parsed.defines) (!tempArray1) in (
                      ignore (Hxhx_macro_MacroState.seedFromCliDefines allDefines);
                      ignore (Hxhx_macro_MacroState.setGeneratedHxDir (Haxe_io_Path.join (let __arr_352 = HxArray.create () in (
                        ignore (HxArray.push __arr_352 outAbs);
                        ignore (HxArray.push __arr_352 "_gen_hx");
                        __arr_352
                      ))));
                      let tempArray2 = ref (Obj.magic ()) in (
                        ignore (let out = HxArray.create () in (
                          ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                            ignore (let __old_353 = !_g in let __new_354 = HxInt.add __old_353 1 in (
                              ignore (_g := __new_354);
                              __new_354
                            ));
                            let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "macros") in while !_g2 < HxArray.length _g1 do ignore (let m = HxArray.get _g1 (!_g2) in (
                              ignore (let __old_355 = !_g2 in let __new_356 = HxInt.add __old_355 1 in (
                                ignore (_g2 := __new_356);
                                __new_356
                              ));
                              if HxArray.indexOf out m 0 = -1 then ignore (HxArray.push out m) else ()
                            )) done
                          )) done);
                          let __assign_357 = out in (
                            tempArray2 := __assign_357;
                            __assign_357
                          )
                        ));
                        let runHaxelibMacros = isTrueEnv "HXHX_RUN_HAXELIB_MACROS" in let tempArray3 = ref (Obj.magic ()) in (
                          ignore (let tempArray4 = ref (Obj.magic ()) in (
                            ignore (let _this = parsed.classPaths in let _g = let __arr_358 = HxArray.create () in __arr_358 in (
                              ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                                ignore (let __old_359 = !_g1 in let __new_360 = HxInt.add __old_359 1 in (
                                  ignore (_g1 := __new_360);
                                  __new_360
                                ));
                                HxArray.push _g (absFromCwd cwd v)
                              )) done);
                              let __assign_361 = _g in (
                                tempArray4 := __assign_361;
                                __assign_361
                              )
                            ));
                            let libs = HxArray.create () in (
                              ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                                ignore (let __old_362 = !_g in let __new_363 = HxInt.add __old_362 1 in (
                                  ignore (_g := __new_363);
                                  __new_363
                                ));
                                let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "classPaths") in while !_g2 < HxArray.length _g1 do ignore (let p = HxArray.get _g1 (!_g2) in (
                                  ignore (let __old_364 = !_g2 in let __new_365 = HxInt.add __old_364 1 in (
                                    ignore (_g2 := __new_365);
                                    __new_365
                                  ));
                                  HxArray.push libs (absFromCwd cwd p)
                                )) done
                              )) done);
                              let outAll = HxArray.concat (!tempArray4) libs in let stdCp = trim (HxSys.getEnv "HAXE_STD_PATH") in if HxString.length stdCp > 0 then let stdAbs = Haxe_io_Path.normalize stdCp in let filtered = HxArray.create () in (
                                ignore (let _g = ref 0 in while !_g < HxArray.length outAll do ignore (let cp = HxArray.get outAll (!_g) in (
                                  ignore (let __old_366 = !_g in let __new_367 = HxInt.add __old_366 1 in (
                                    ignore (_g := __new_367);
                                    __new_367
                                  ));
                                  if not (HxString.equals (Haxe_io_Path.normalize cp) stdAbs) then ignore (HxArray.push filtered cp) else ()
                                )) done);
                                let __assign_368 = filtered in (
                                  tempArray3 := __assign_368;
                                  __assign_368
                                )
                              ) else let __assign_369 = outAll in (
                                tempArray3 := __assign_369;
                                __assign_369
                              )
                            )
                          ));
                          ignore (if not (typeOnly) && (HxArray.length (parsed.macros) > 0 || HxArray.length exprMacros > 0 || runHaxelibMacros && HxArray.length (!tempArray2) > 0) then ignore ((
                            ignore (if HxString.length (Hxhx_macro_MacroHostClient.resolveMacroHostExePath ()) = 0 && shouldAutoBuildMacroHost () then ignore (let repoRoot = inferRepoRootForScripts () in (
                              ignore (if HxString.length repoRoot = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "macro host auto-build enabled, but repo root could not be inferred (set HXHX_REPO_ROOT)"))) else ());
                              try let entrypoints = HxArray.create () in (
                                ignore (if runHaxelibMacros then ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray2) do ignore (let e = HxArray.get (!tempArray2) (!_g) in (
                                  ignore (let __old_370 = !_g in let __new_371 = HxInt.add __old_370 1 in (
                                    ignore (_g := __new_371);
                                    __new_371
                                  ));
                                  if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                                )) done) else ());
                                ignore (if anyNonBuiltinMacro (parsed.macros) then ignore (let _g = ref 0 in let _g1 = parsed.macros in while !_g < HxArray.length _g1 do ignore (let e = HxArray.get _g1 (!_g) in (
                                  ignore (let __old_372 = !_g in let __new_373 = HxInt.add __old_372 1 in (
                                    ignore (_g := __new_373);
                                    __new_373
                                  ));
                                  if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                                )) done) else ());
                                ignore (let _g = ref 0 in while !_g < HxArray.length exprMacros do ignore (let e = HxArray.get exprMacros (!_g) in (
                                  ignore (let __old_374 = !_g in let __new_375 = HxInt.add __old_374 1 in (
                                    ignore (_g := __new_375);
                                    __new_375
                                  ));
                                  if HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                                )) done);
                                let exe = buildMacroHostExe repoRoot (!tempArray3) entrypoints in HxSys.putEnv "HXHX_MACRO_HOST_EXE" (Some exe)
                              ) with
                                | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                | HxRuntime.Hx_return __ret_376 -> raise (HxRuntime.Hx_return __ret_376)
                                | HxRuntime.Hx_exception (__exn_v_377, __exn_tags_378) -> if true then let e = (__exn_v_377 : Obj.t) in (
                                  ignore e;
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                ) else HxRuntime.hx_throw_typed __exn_v_377 __exn_tags_378
                                | __exn_379 -> if true then let e = (Obj.repr __exn_379 : Obj.t) in (
                                  ignore e;
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                ) else raise (__exn_379)
                            )) else ());
                            ignore (try (
                              ignore (let __assign_380 = Hxhx_macro_MacroHostClient.openSession () in (
                                macroSession := __assign_380;
                                __assign_380
                              ));
                              ignore (if runHaxelibMacros then ignore (let _g = ref 0 in let _g1 = HxArray.length (!tempArray2) in while !_g < _g1 do ignore (let i = let __old_381 = !_g in let __new_382 = HxInt.add __old_381 1 in (
                                ignore (_g := __new_382);
                                __old_381
                              ) in print_endline ((("lib_macro_run[" ^ string_of_int i) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) (HxArray.get (!tempArray2) i)))) done) else ());
                              let _g = ref 0 in let _g1 = HxArray.length (parsed.macros) in while !_g < _g1 do ignore (let i = let __old_383 = !_g in let __new_384 = HxInt.add __old_383 1 in (
                                ignore (_g := __new_384);
                                __old_383
                              ) in print_endline ((("macro_run[" ^ string_of_int i) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) (HxArray.get (parsed.macros) i)))) done
                            ) with
                              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                              | HxRuntime.Hx_return __ret_385 -> raise (HxRuntime.Hx_return __ret_385)
                              | HxRuntime.Hx_exception (__exn_v_386, __exn_tags_387) -> if true then let e = (__exn_v_386 : Obj.t) in (
                                ignore e;
                                (
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_388 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_388;
                                      __assign_388
                                    )
                                  )) else ());
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("macro failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                )
                              ) else HxRuntime.hx_throw_typed __exn_v_386 __exn_tags_387
                              | __exn_389 -> if true then let e = (Obj.repr __exn_389 : Obj.t) in (
                                ignore e;
                                (
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_390 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_390;
                                      __assign_390
                                    )
                                  )) else ());
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("macro failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                )
                              ) else raise (__exn_389));
                            let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                              ignore (let __old_391 = !_g in let __new_392 = HxInt.add __old_391 1 in (
                                ignore (_g := __new_392);
                                __new_392
                              ));
                              if StringTools.startsWith name "HXHX_" then ignore (print_endline ((("macro_define[" ^ HxString.toStdString name) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroState.definedValue name))) else ()
                            )) done
                          )) else ());
                          let tempArray5 = ref (Obj.magic ()) in (
                            ignore (let tempArray6 = ref (Obj.magic ()) in (
                              ignore (let _this = parsed.classPaths in let _g = let __arr_393 = HxArray.create () in __arr_393 in (
                                ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                                  ignore (let __old_394 = !_g1 in let __new_395 = HxInt.add __old_394 1 in (
                                    ignore (_g1 := __new_395);
                                    __new_395
                                  ));
                                  HxArray.push _g (absFromCwd cwd v)
                                )) done);
                                let __assign_396 = _g in (
                                  tempArray6 := __assign_396;
                                  __assign_396
                                )
                              ));
                              let libs = HxArray.create () in (
                                ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                                  ignore (let __old_397 = !_g in let __new_398 = HxInt.add __old_397 1 in (
                                    ignore (_g := __new_398);
                                    __new_398
                                  ));
                                  let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "classPaths") in while !_g2 < HxArray.length _g1 do ignore (let p = HxArray.get _g1 (!_g2) in (
                                    ignore (let __old_399 = !_g2 in let __new_400 = HxInt.add __old_399 1 in (
                                      ignore (_g2 := __new_400);
                                      __new_400
                                    ));
                                    HxArray.push libs (absFromCwd cwd p)
                                  )) done
                                )) done);
                                let tempArray7 = ref (Obj.magic ()) in (
                                  ignore (let _this = Hxhx_macro_MacroState.listClassPaths () in let _g = let __arr_401 = HxArray.create () in __arr_401 in (
                                    ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                                      ignore (let __old_402 = !_g1 in let __new_403 = HxInt.add __old_402 1 in (
                                        ignore (_g1 := __new_403);
                                        __new_403
                                      ));
                                      HxArray.push _g (absFromCwd cwd v)
                                    )) done);
                                    let __assign_404 = _g in (
                                      tempArray7 := __assign_404;
                                      __assign_404
                                    )
                                  ));
                                  let out = HxArray.concat (HxArray.concat (!tempArray6) libs) (!tempArray7) in (
                                    ignore (if Hxhx_macro_MacroState.hasGeneratedHxModules () then ignore (HxArray.push out (Hxhx_macro_MacroState.getGeneratedHxDir ())) else ());
                                    let __assign_405 = out in (
                                      tempArray5 := __assign_405;
                                      __assign_405
                                    )
                                  )
                                )
                              )
                            ));
                            let definesMap = HxDefineMap.fromRawDefines allDefines in (
                              ignore (HxMap.set_string definesMap "sys" "1");
                              ignore (HxMap.set_string definesMap "ocaml" "1");
                              ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let n = HxArray.get _g1 (!_g) in (
                                ignore (let __old_406 = !_g in let __new_407 = HxInt.add __old_406 1 in (
                                  ignore (_g := __new_407);
                                  __new_407
                                ));
                                HxMap.set_string definesMap n (Hxhx_macro_MacroState.definedValue n)
                              )) done);
                              let roots = HxArray.concat roots0 (Hxhx_macro_MacroState.listIncludedModules ()) in let tempArray8 = ref (Obj.magic ()) in (
                                ignore (try let __assign_408 = ResolverStage.parseProjectRoots (!tempArray5) roots definesMap in (
                                  tempArray8 := __assign_408;
                                  __assign_408
                                ) with
                                  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                  | HxRuntime.Hx_return __ret_409 -> raise (HxRuntime.Hx_return __ret_409)
                                  | HxRuntime.Hx_exception (__exn_v_410, __exn_tags_411) -> if true then let e = (__exn_v_410 : Obj.t) in (
                                    ignore e;
                                    (
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                        let __assign_412 = Obj.magic (HxRuntime.hx_null) in (
                                          macroSession := __assign_412;
                                          __assign_412
                                        )
                                      )) else ());
                                      raise (HxRuntime.Hx_return (Obj.repr (error ("resolve failed: " ^ HxString.toStdString (formatException e)))))
                                    )
                                  ) else HxRuntime.hx_throw_typed __exn_v_410 __exn_tags_411
                                  | __exn_413 -> if true then let e = (Obj.repr __exn_413 : Obj.t) in (
                                    ignore e;
                                    (
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                        let __assign_414 = Obj.magic (HxRuntime.hx_null) in (
                                          macroSession := __assign_414;
                                          __assign_414
                                        )
                                      )) else ());
                                      raise (HxRuntime.Hx_return (Obj.repr (error ("resolve failed: " ^ HxString.toStdString (formatException e)))))
                                    )
                                  ) else raise (__exn_413));
                                ignore (if HxArray.length (!tempArray8) = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "resolver returned an empty module graph"))) else ());
                                ignore (print_endline ("resolved_modules=" ^ string_of_int (HxArray.length (!tempArray8))));
                                let anyBuildMacros = ref false in let buildExprsAll = HxArray.create () in (
                                  ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                    ignore (let __old_415 = !_g in let __new_416 = HxInt.add __old_415 1 in (
                                      ignore (_g := __new_416);
                                      __new_416
                                    ));
                                    let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in if HxArray.length exprs > 0 then ignore ((
                                      ignore (let __assign_417 = true in (
                                        anyBuildMacros := __assign_417;
                                        __assign_417
                                      ));
                                      let _g2 = ref 0 in while !_g2 < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g2) in (
                                        ignore (let __old_418 = !_g2 in let __new_419 = HxInt.add __old_418 1 in (
                                          ignore (_g2 := __new_419);
                                          __new_419
                                        ));
                                        HxArray.push buildExprsAll e
                                      )) done
                                    )) else ()
                                  )) done);
                                  ignore (if not (typeOnly) && !anyBuildMacros then ignore ((
                                    ignore (if !macroSession == Obj.magic (HxRuntime.hx_null) then ignore ((
                                      ignore (if HxString.length (Hxhx_macro_MacroHostClient.resolveMacroHostExePath ()) = 0 && shouldAutoBuildMacroHost () then ignore (let repoRoot = inferRepoRootForScripts () in (
                                        ignore (if HxString.length repoRoot = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "macro host auto-build enabled, but repo root could not be inferred (set HXHX_REPO_ROOT)"))) else ());
                                        try let entrypoints = HxArray.create () in (
                                          ignore (let _g = ref 0 in while !_g < HxArray.length buildExprsAll do ignore (let e = HxArray.get buildExprsAll (!_g) in (
                                            ignore (let __old_420 = !_g in let __new_421 = HxInt.add __old_420 1 in (
                                              ignore (_g := __new_421);
                                              __new_421
                                            ));
                                            if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                                          )) done);
                                          let exe = buildMacroHostExe repoRoot (!tempArray3) entrypoints in HxSys.putEnv "HXHX_MACRO_HOST_EXE" (Some exe)
                                        ) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_422 -> raise (HxRuntime.Hx_return __ret_422)
                                          | HxRuntime.Hx_exception (__exn_v_423, __exn_tags_424) -> if true then let e = (__exn_v_423 : Obj.t) in (
                                            ignore e;
                                            raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed (build macros): " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                          ) else HxRuntime.hx_throw_typed __exn_v_423 __exn_tags_424
                                          | __exn_425 -> if true then let e = (Obj.repr __exn_425 : Obj.t) in (
                                            ignore e;
                                            raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed (build macros): " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                          ) else raise (__exn_425)
                                      )) else ());
                                      try let __assign_426 = Hxhx_macro_MacroHostClient.openSession () in (
                                        macroSession := __assign_426;
                                        __assign_426
                                      ) with
                                        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                        | HxRuntime.Hx_return __ret_427 -> raise (HxRuntime.Hx_return __ret_427)
                                        | HxRuntime.Hx_exception (__exn_v_428, __exn_tags_429) -> if true then let e = (__exn_v_428 : Obj.t) in (
                                          ignore e;
                                          (
                                            ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                              ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                              let __assign_430 = Obj.magic (HxRuntime.hx_null) in (
                                                macroSession := __assign_430;
                                                __assign_430
                                              )
                                            )) else ());
                                            raise (HxRuntime.Hx_return (Obj.repr (error ("macro host required for @:build, but could not be started: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                          )
                                        ) else HxRuntime.hx_throw_typed __exn_v_428 __exn_tags_429
                                        | __exn_431 -> if true then let e = (Obj.repr __exn_431 : Obj.t) in (
                                          ignore e;
                                          (
                                            ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                              ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                              let __assign_432 = Obj.magic (HxRuntime.hx_null) in (
                                                macroSession := __assign_432;
                                                __assign_432
                                              )
                                            )) else ());
                                            raise (HxRuntime.Hx_return (Obj.repr (error ("macro host required for @:build, but could not be started: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                          )
                                        ) else raise (__exn_431)
                                    )) else ());
                                    let out2 = HxArray.create () in (
                                      ignore (let _g = ref 0 in try while !_g < HxArray.length (!tempArray8) do try ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                        ignore (let __old_433 = !_g in let __new_434 = HxInt.add __old_433 1 in (
                                          ignore (_g := __new_434);
                                          __new_434
                                        ));
                                        let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in (
                                          ignore (if HxArray.length exprs = 0 then ignore ((
                                            ignore (HxArray.push out2 m);
                                            raise (HxRuntime.Hx_continue)
                                          )) else ());
                                          let modulePath = ResolvedModule.getModulePath m in (
                                            ignore (Hxhx_macro_MacroState.clearBuildFields modulePath);
                                            ignore (Hxhx_macro_MacroState.setDefine "HXHX_BUILD_MODULE" modulePath);
                                            ignore (Hxhx_macro_MacroState.setDefine "HXHX_BUILD_FILE" (ResolvedModule.getFilePath m));
                                            ignore (Hxhx_macro_MacroState.setBuildFieldsPayload (buildFieldsPayloadForParsed pm));
                                            ignore (let _g2 = ref 0 in let _g1 = HxArray.length exprs in while !_g2 < _g1 do ignore (let i = let __old_435 = !_g2 in let __new_436 = HxInt.add __old_435 1 in (
                                              ignore (_g2 := __new_436);
                                              __old_435
                                            ) in let expr = HxArray.get exprs i in (
                                              ignore (print_endline ((((("build_macro[" ^ HxString.toStdString modulePath) ^ "][") ^ string_of_int i) ^ "]=") ^ HxString.toStdString expr));
                                              try print_endline ((((("build_macro_run[" ^ HxString.toStdString modulePath) ^ "][") ^ string_of_int i) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) expr)) with
                                                | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                                | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                                | HxRuntime.Hx_return __ret_437 -> raise (HxRuntime.Hx_return __ret_437)
                                                | HxRuntime.Hx_exception (__exn_v_438, __exn_tags_439) -> if true then let e = (__exn_v_438 : Obj.t) in (
                                                  ignore e;
                                                  (
                                                    ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                      ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                      let __assign_440 = Obj.magic (HxRuntime.hx_null) in (
                                                        macroSession := __assign_440;
                                                        __assign_440
                                                      )
                                                    )) else ());
                                                    raise (HxRuntime.Hx_return (Obj.repr (error ((("build macro failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                  )
                                                ) else HxRuntime.hx_throw_typed __exn_v_438 __exn_tags_439
                                                | __exn_441 -> if true then let e = (Obj.repr __exn_441 : Obj.t) in (
                                                  ignore e;
                                                  (
                                                    ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                      ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                      let __assign_442 = Obj.magic (HxRuntime.hx_null) in (
                                                        macroSession := __assign_442;
                                                        __assign_442
                                                      )
                                                    )) else ());
                                                    raise (HxRuntime.Hx_return (Obj.repr (error ((("build macro failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                  )
                                                ) else raise (__exn_441)
                                            )) done);
                                            let snippets = Hxhx_macro_MacroState.listBuildFields modulePath in (
                                              ignore (print_endline ((("build_fields[" ^ HxString.toStdString modulePath) ^ "]=") ^ string_of_int (HxArray.length snippets)));
                                              ignore (if HxArray.length snippets = 0 then ignore ((
                                                ignore (HxArray.push out2 m);
                                                raise (HxRuntime.Hx_continue)
                                              )) else ());
                                              let tempStruct1 = ref (Obj.magic ()) in (
                                                ignore (try let __assign_443 = parseGeneratedMembers snippets in (
                                                  tempStruct1 := __assign_443;
                                                  __assign_443
                                                ) with
                                                  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                                  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                                  | HxRuntime.Hx_return __ret_444 -> raise (HxRuntime.Hx_return __ret_444)
                                                  | HxRuntime.Hx_exception (__exn_v_445, __exn_tags_446) -> if true then let e = (__exn_v_445 : Obj.t) in (
                                                    ignore e;
                                                    (
                                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                        let __assign_447 = Obj.magic (HxRuntime.hx_null) in (
                                                          macroSession := __assign_447;
                                                          __assign_447
                                                        )
                                                      )) else ());
                                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("build fields parse failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                    )
                                                  ) else HxRuntime.hx_throw_typed __exn_v_445 __exn_tags_446
                                                  | __exn_448 -> if true then let e = (Obj.repr __exn_448 : Obj.t) in (
                                                    ignore e;
                                                    (
                                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                        let __assign_449 = Obj.magic (HxRuntime.hx_null) in (
                                                          macroSession := __assign_449;
                                                          __assign_449
                                                        )
                                                      )) else ());
                                                      raise (HxRuntime.Hx_return (Obj.repr (error ((("build fields parse failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                    )
                                                  ) else raise (__exn_448));
                                                let gen = !tempStruct1 in let oldDecl = ParsedModule.getDecl pm () in let oldCls = HxModuleDecl.getMainClass oldDecl in let genFnKeys = HxMap.create_string () in (
                                                  ignore (let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get gen "functions") in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                    ignore (let __old_450 = !_g2 in let __new_451 = HxInt.add __old_450 1 in (
                                                      ignore (_g2 := __new_451);
                                                      __new_451
                                                    ));
                                                    let key = HxFunctionDecl.getName fn in HxMap.set_string genFnKeys key true
                                                  )) done);
                                                  let genFieldKeys = HxMap.create_string () in (
                                                    ignore (let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get gen "fields") in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
                                                      ignore (let __old_452 = !_g2 in let __new_453 = HxInt.add __old_452 1 in (
                                                        ignore (_g2 := __new_453);
                                                        __new_453
                                                      ));
                                                      let key = HxFieldDecl.getName f in HxMap.set_string genFieldKeys key true
                                                    )) done);
                                                    let keptFns = HxArray.create () in (
                                                      ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions oldCls in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                        ignore (let __old_454 = !_g2 in let __new_455 = HxInt.add __old_454 1 in (
                                                          ignore (_g2 := __new_455);
                                                          __new_455
                                                        ));
                                                        let tempBool = ref false in (
                                                          ignore (let key = HxFunctionDecl.getName fn in let __assign_456 = HxMap.exists_string genFnKeys key in (
                                                            tempBool := __assign_456;
                                                            __assign_456
                                                          ));
                                                          if not (!tempBool) then ignore (HxArray.push keptFns fn) else ()
                                                        )
                                                      )) done);
                                                      let mergedFns = HxArray.concat keptFns (Obj.obj (HxAnon.get gen "functions")) in let keptFields = HxArray.create () in (
                                                        ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFields oldCls in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
                                                          ignore (let __old_457 = !_g2 in let __new_458 = HxInt.add __old_457 1 in (
                                                            ignore (_g2 := __new_458);
                                                            __new_458
                                                          ));
                                                          let tempBool1 = ref false in (
                                                            ignore (let key = HxFieldDecl.getName f in let __assign_459 = HxMap.exists_string genFieldKeys key in (
                                                              tempBool1 := __assign_459;
                                                              __assign_459
                                                            ));
                                                            if not (!tempBool1) then ignore (HxArray.push keptFields f) else ()
                                                          )
                                                        )) done);
                                                        let mergedFields = HxArray.concat keptFields (Obj.obj (HxAnon.get gen "fields")) in let newCls = HxClassDecl.create (HxClassDecl.getName oldCls) (HxClassDecl.getHasStaticMain oldCls) mergedFns mergedFields in let newClasses = HxArray.create () in (
                                                          ignore (let _g2 = ref 0 in let _g1 = HxModuleDecl.getClasses oldDecl in while !_g2 < HxArray.length _g1 do ignore (let c = HxArray.get _g1 (!_g2) in (
                                                            ignore (let __old_460 = !_g2 in let __new_461 = HxInt.add __old_460 1 in (
                                                              ignore (_g2 := __new_461);
                                                              __new_461
                                                            ));
                                                            if HxString.equals (HxClassDecl.getName c) (HxClassDecl.getName oldCls) then ignore (HxArray.push newClasses newCls) else ignore (HxArray.push newClasses c)
                                                          )) done);
                                                          let newDecl = HxModuleDecl.create (HxModuleDecl.getPackagePath oldDecl) (HxModuleDecl.getImports oldDecl) newCls newClasses (HxModuleDecl.getHeaderOnly oldDecl) (HxModuleDecl.getHasToplevelMain oldDecl) in let newParsed = ParsedModule.create (ParsedModule.getSource pm ()) newDecl (ParsedModule.getFilePath pm ()) in HxArray.push out2 (ResolvedModule.create modulePath (ResolvedModule.getFilePath m) newParsed)
                                                        )
                                                      )
                                                    )
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )) with
                                        | HxRuntime.Hx_continue -> () done with
                                        | HxRuntime.Hx_break -> ());
                                      let __assign_462 = out2 in (
                                        tempArray8 := __assign_462;
                                        __assign_462
                                      )
                                    )
                                  )) else ignore (if typeOnly && !anyBuildMacros then ignore (let i = ref 0 in let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                    ignore (let __old_463 = !_g in let __new_464 = HxInt.add __old_463 1 in (
                                      ignore (_g := __new_464);
                                      __new_464
                                    ));
                                    let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in let _g2 = ref 0 in while !_g2 < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g2) in (
                                      ignore (let __old_465 = !_g2 in let __new_466 = HxInt.add __old_465 1 in (
                                        ignore (_g2 := __new_466);
                                        __new_466
                                      ));
                                      ignore (print_endline ((((("build_macro_skipped[" ^ string_of_int (!i)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getModulePath m)) ^ ":") ^ HxString.toStdString e));
                                      i := HxInt.add (!i) 1
                                    )) done
                                  )) done) else ()));
                                  ignore (if not (typeOnly) && HxArray.length exprMacros > 0 then ignore ((
                                    ignore (if !macroSession == Obj.magic (HxRuntime.hx_null) then ignore ((
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                        let __assign_467 = Obj.magic (HxRuntime.hx_null) in (
                                          macroSession := __assign_467;
                                          __assign_467
                                        )
                                      )) else ());
                                      raise (HxRuntime.Hx_return (Obj.repr (error "expression macro expansion requested (HXHX_EXPR_MACROS), but no macro host session is available")))
                                    )) else ());
                                    let exp = Hxhx_ExprMacroExpander.expandResolvedModules (!tempArray8) (!macroSession) exprMacros in (
                                      ignore (let __assign_468 = Obj.obj (HxAnon.get exp "modules") in (
                                        tempArray8 := __assign_468;
                                        __assign_468
                                      ));
                                      print_endline ("expr_macros_expanded=" ^ string_of_int (Obj.obj (HxAnon.get exp "expandedCount")))
                                    )
                                  )) else ());
                                  let typerIndex = TyperIndex.build (!tempArray8) in let moduleLoader = ModuleLoader.create (!tempArray5) definesMap typerIndex in (
                                    ignore (moduleLoader.markResolvedAlready (Obj.magic moduleLoader) (!tempArray8));
                                    ignore (if typeOnly then ignore (let typedCount = ref 0 in let headerOnlyCount = ref 0 in let parsedMethodsTotal = ref 0 in let unsupportedExprsTotal = ref 0 in let unsupportedFilesCount = ref 0 in let traceUnsupported = isTrueEnv "HXHX_TRACE_UNSUPPORTED" in let unsupportedRawCount = ref 0 in let unsupportedFnCount = ref 0 in let rootFilePath = ResolvedModule.getFilePath (HxArray.get (!tempArray8) 0) in let rootTyped = ref (Obj.magic (HxRuntime.hx_null)) in let toType = HxArray.copy (!tempArray8) in let cursor = ref 0 in (
                                      ignore (while !cursor < HxArray.length toType do ignore (let m = HxArray.get toType (!cursor) in (
                                        ignore (cursor := HxInt.add (!cursor) 1);
                                        ignore (try let pm = ResolvedModule.getParsed m in let unsupportedInFile = countUnsupportedExprsInModule pm in (
                                          ignore (unsupportedExprsTotal := HxInt.add (!unsupportedExprsTotal) unsupportedInFile);
                                          ignore (if unsupportedInFile > 0 then ignore ((
                                            ignore (print_endline ((((((("unsupported_file[" ^ string_of_int (!unsupportedFilesCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ " header_only=") ^ HxString.toStdString (bool01 (HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ())))) ^ " unsupported_exprs=") ^ string_of_int unsupportedInFile));
                                            ignore (if traceUnsupported then ignore (let cls = HxModuleDecl.getMainClass (ParsedModule.getDecl pm ()) in (
                                              ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in try while !_g < HxArray.length _g1 do try ignore (let fn = HxArray.get _g1 (!_g) in (
                                                ignore (let __old_469 = !_g in let __new_470 = HxInt.add __old_469 1 in (
                                                  ignore (_g := __new_470);
                                                  __new_470
                                                ));
                                                let fnUnsupported = countUnsupportedExprsInFunction fn in (
                                                  ignore (if fnUnsupported <= 0 then raise (HxRuntime.Hx_continue) else ());
                                                  ignore (print_endline ((((((("unsupported_fn[" ^ string_of_int (!unsupportedFnCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":") ^ HxString.toStdString (HxFunctionDecl.getName fn)) ^ " unsupported_exprs=") ^ string_of_int fnUnsupported));
                                                  ignore (unsupportedFnCount := HxInt.add (!unsupportedFnCount) 1);
                                                  if !unsupportedFnCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                )
                                              )) with
                                                | HxRuntime.Hx_continue -> () done with
                                                | HxRuntime.Hx_break -> ());
                                              let _g = ref 0 in let _g1 = collectUnsupportedExprRawInModule pm 20 in try while !_g < HxArray.length _g1 do try ignore (let raw = HxArray.get _g1 (!_g) in (
                                                ignore (let __old_471 = !_g in let __new_472 = HxInt.add __old_471 1 in (
                                                  ignore (_g := __new_472);
                                                  __new_472
                                                ));
                                                let escaped = escapeOneLine raw in let tempNumber = ref 0 in (
                                                  ignore (if raw == Obj.magic (HxRuntime.hx_null) then let __assign_473 = 0 in (
                                                    tempNumber := __assign_473;
                                                    __assign_473
                                                  ) else let __assign_474 = HxString.length raw in (
                                                    tempNumber := __assign_474;
                                                    __assign_474
                                                  ));
                                                  ignore (print_endline ((((((("unsupported_expr[" ^ string_of_int (!unsupportedRawCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":raw=") ^ HxString.toStdString escaped) ^ " len=") ^ string_of_int (!tempNumber)));
                                                  ignore (unsupportedRawCount := HxInt.add (!unsupportedRawCount) 1);
                                                  if !unsupportedRawCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                )
                                              )) with
                                                | HxRuntime.Hx_continue -> () done with
                                                | HxRuntime.Hx_break -> ()
                                            )) else ());
                                            unsupportedFilesCount := HxInt.add (!unsupportedFilesCount) 1
                                          )) else ());
                                          ignore (if HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ()) then ignore ((
                                            ignore (print_endline ((("header_only_file[" ^ string_of_int (!headerOnlyCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)));
                                            headerOnlyCount := HxInt.add (!headerOnlyCount) 1
                                          )) else ());
                                          ignore (parsedMethodsTotal := HxInt.add (!parsedMethodsTotal) (HxArray.length (HxClassDecl.getFunctions (HxModuleDecl.getMainClass (ParsedModule.getDecl pm ())))));
                                          let typed = TyperStage.typeResolvedModule m typerIndex moduleLoader in (
                                            ignore (if HxString.equals (ResolvedModule.getFilePath m) rootFilePath then ignore (let __assign_475 = typed in (
                                              rootTyped := __assign_475;
                                              __assign_475
                                            )) else ());
                                            typedCount := HxInt.add (!typedCount) 1
                                          )
                                        ) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_476 -> raise (HxRuntime.Hx_return __ret_476)
                                          | HxRuntime.Hx_exception (__exn_v_477, __exn_tags_478) -> if true then let e = (__exn_v_477 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_479 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_479;
                                                  __assign_479
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_477 __exn_tags_478
                                          | __exn_480 -> if true then let e = (Obj.repr __exn_480 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_481 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_481;
                                                  __assign_481
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                            )
                                          ) else raise (__exn_480));
                                        let _g = ref 0 in let _g1 = moduleLoader.drainNewModules (Obj.magic moduleLoader) () in while !_g < HxArray.length _g1 do ignore (let nm = HxArray.get _g1 (!_g) in (
                                          ignore (let __old_482 = !_g in let __new_483 = HxInt.add __old_482 1 in (
                                            ignore (_g := __new_483);
                                            __new_483
                                          ));
                                          ignore (HxArray.push (!tempArray8) nm);
                                          HxArray.push toType nm
                                        )) done
                                      )) done);
                                      ignore (if !rootTyped != Obj.magic (HxRuntime.hx_null) then ignore (let fns = TyClassEnv.getFunctions (TyModuleEnv.getMainClass (TypedModule.getEnv (!rootTyped) ()) ()) () in let _g = ref 0 in let _g1 = HxArray.length fns in while !_g < _g1 do ignore (let i = let __old_484 = !_g in let __new_485 = HxInt.add __old_484 1 in (
                                        ignore (_g := __new_485);
                                        __old_484
                                      ) in let tf = HxArray.get fns i in let locals = TyFunctionEnv.getLocals tf () in let localsParts = HxArray.create () in (
                                        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length locals do ignore (let l = HxArray.get locals (!_g2) in (
                                          ignore (let __old_486 = !_g2 in let __new_487 = HxInt.add __old_486 1 in (
                                            ignore (_g2 := __new_487);
                                            __new_487
                                          ));
                                          HxArray.push localsParts ((HxString.toStdString (TySymbol.getName l ()) ^ ":") ^ HxString.toStdString (TyType.toString (TySymbol.getType l ()) ()))
                                        )) done);
                                        let params = TyFunctionEnv.getParams tf () in let paramParts = HxArray.create () in (
                                          ignore (let _g2 = ref 0 in while !_g2 < HxArray.length params do ignore (let p = HxArray.get params (!_g2) in (
                                            ignore (let __old_488 = !_g2 in let __new_489 = HxInt.add __old_488 1 in (
                                              ignore (_g2 := __new_489);
                                              __new_489
                                            ));
                                            HxArray.push paramParts ((HxString.toStdString (TySymbol.getName p ()) ^ ":") ^ HxString.toStdString (TyType.toString (TySymbol.getType p ()) ()))
                                          )) done);
                                          print_endline ((((((((((("typed_fn[" ^ string_of_int i) ^ "]=") ^ HxString.toStdString (TyFunctionEnv.getName tf ())) ^ " args=") ^ HxString.toStdString (HxArray.join paramParts "," (fun x -> x))) ^ " locals=") ^ HxString.toStdString (HxArray.join localsParts "," (fun x -> x))) ^ " ret=") ^ HxString.toStdString (TyType.toString (TyFunctionEnv.getReturnType tf ()) ())) ^ " inferred=") ^ HxString.toStdString (TyType.toString (TyFunctionEnv.getReturnExprType tf ()) ()))
                                        )
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterTypingHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_490 = !_g in let __new_491 = HxInt.add __old_490 1 in (
                                        ignore (_g := __new_491);
                                        __old_490
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterTyping" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_492 -> raise (HxRuntime.Hx_return __ret_492)
                                          | HxRuntime.Hx_exception (__exn_v_493, __exn_tags_494) -> if true then let e = (__exn_v_493 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_495 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_495;
                                                  __assign_495
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_493 __exn_tags_494
                                          | __exn_496 -> if true then let e = (Obj.repr __exn_496 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_497 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_497;
                                                  __assign_497
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_496));
                                        print_endline (("hook_afterTyping[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listOnGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_498 = !_g in let __new_499 = HxInt.add __old_498 1 in (
                                        ignore (_g := __new_499);
                                        __old_498
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "onGenerate" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_500 -> raise (HxRuntime.Hx_return __ret_500)
                                          | HxRuntime.Hx_exception (__exn_v_501, __exn_tags_502) -> if true then let e = (__exn_v_501 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_503 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_503;
                                                  __assign_503
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_501 __exn_tags_502
                                          | __exn_504 -> if true then let e = (Obj.repr __exn_504 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_505 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_505;
                                                  __assign_505
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_504));
                                        print_endline (("hook_onGenerate[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_506 = !_g in let __new_507 = HxInt.add __old_506 1 in (
                                        ignore (_g := __new_507);
                                        __old_506
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterGenerate" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_508 -> raise (HxRuntime.Hx_return __ret_508)
                                          | HxRuntime.Hx_exception (__exn_v_509, __exn_tags_510) -> if true then let e = (__exn_v_509 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_511 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_511;
                                                  __assign_511
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_509 __exn_tags_510
                                          | __exn_512 -> if true then let e = (Obj.repr __exn_512 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_513 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_513;
                                                  __assign_513
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_512));
                                        print_endline (("hook_afterGenerate[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                        ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                        let __assign_514 = Obj.magic (HxRuntime.hx_null) in (
                                          macroSession := __assign_514;
                                          __assign_514
                                        )
                                      )) else ());
                                      ignore (print_endline ("typed_modules=" ^ string_of_int (!typedCount)));
                                      ignore (print_endline ("header_only_modules=" ^ string_of_int (!headerOnlyCount)));
                                      ignore (print_endline ("parsed_methods_total=" ^ string_of_int (!parsedMethodsTotal)));
                                      ignore (print_endline ("unsupported_exprs_total=" ^ string_of_int (!unsupportedExprsTotal)));
                                      ignore (print_endline ("unsupported_files=" ^ string_of_int (!unsupportedFilesCount)));
                                      ignore (print_endline "stage3=type_only_ok");
                                      raise (HxRuntime.Hx_return (Obj.repr 0))
                                    )) else ());
                                    let typedModules = HxArray.create () in let toType = HxArray.copy (!tempArray8) in let cursor = ref 0 in (
                                      ignore (while !cursor < HxArray.length toType do ignore (let m = HxArray.get toType (!cursor) in (
                                        ignore (cursor := HxInt.add (!cursor) 1);
                                        ignore (try HxArray.push typedModules (TyperStage.typeResolvedModule m typerIndex moduleLoader) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_515 -> raise (HxRuntime.Hx_return __ret_515)
                                          | HxRuntime.Hx_exception (__exn_v_516, __exn_tags_517) -> if true then let e = (__exn_v_516 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_518 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_518;
                                                  __assign_518
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_516 __exn_tags_517
                                          | __exn_519 -> if true then let e = (Obj.repr __exn_519 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_520 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_520;
                                                  __assign_520
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                            )
                                          ) else raise (__exn_519));
                                        let _g = ref 0 in let _g1 = moduleLoader.drainNewModules (Obj.magic moduleLoader) () in while !_g < HxArray.length _g1 do ignore (let nm = HxArray.get _g1 (!_g) in (
                                          ignore (let __old_521 = !_g in let __new_522 = HxInt.add __old_521 1 in (
                                            ignore (_g := __new_522);
                                            __new_522
                                          ));
                                          ignore (HxArray.push (!tempArray8) nm);
                                          HxArray.push toType nm
                                        )) done
                                      )) done);
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterTypingHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_523 = !_g in let __new_524 = HxInt.add __old_523 1 in (
                                        ignore (_g := __new_524);
                                        __old_523
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterTyping" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_525 -> raise (HxRuntime.Hx_return __ret_525)
                                          | HxRuntime.Hx_exception (__exn_v_526, __exn_tags_527) -> if true then let e = (__exn_v_526 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_528 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_528;
                                                  __assign_528
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_526 __exn_tags_527
                                          | __exn_529 -> if true then let e = (Obj.repr __exn_529 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_530 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_530;
                                                  __assign_530
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_529));
                                        print_endline (("hook_afterTyping[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listOnGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_531 = !_g in let __new_532 = HxInt.add __old_531 1 in (
                                        ignore (_g := __new_532);
                                        __old_531
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "onGenerate" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_533 -> raise (HxRuntime.Hx_return __ret_533)
                                          | HxRuntime.Hx_exception (__exn_v_534, __exn_tags_535) -> if true then let e = (__exn_v_534 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_536 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_536;
                                                  __assign_536
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_534 __exn_tags_535
                                          | __exn_537 -> if true then let e = (Obj.repr __exn_537 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_538 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_538;
                                                  __assign_538
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_537));
                                        print_endline (("hook_onGenerate[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i = let __old_539 = !_g in let __new_540 = HxInt.add __old_539 1 in (
                                        ignore (_g := __new_540);
                                        __old_539
                                      ) in (
                                        ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterGenerate" (HxArray.get hooks i) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_541 -> raise (HxRuntime.Hx_return __ret_541)
                                          | HxRuntime.Hx_exception (__exn_v_542, __exn_tags_543) -> if true then let e = (__exn_v_542 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_544 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_544;
                                                  __assign_544
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_542 __exn_tags_543
                                          | __exn_545 -> if true then let e = (Obj.repr __exn_545 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_546 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_546;
                                                  __assign_546
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_545));
                                        print_endline (("hook_afterGenerate[" ^ string_of_int i) ^ "]=ok")
                                      )) done) else ());
                                      let generated = HxArray.create () in (
                                        ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listOcamlModuleNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                                          ignore (let __old_547 = !_g in let __new_548 = HxInt.add __old_547 1 in (
                                            ignore (_g := __new_548);
                                            __new_548
                                          ));
                                          HxArray.push generated (let __anon_549 = HxAnon.create () in (
                                            ignore (HxAnon.set __anon_549 "name" (Obj.repr name));
                                            ignore (HxAnon.set __anon_549 "source" (Obj.repr (Hxhx_macro_MacroState.getOcamlModuleSource name)));
                                            __anon_549
                                          ))
                                        )) done);
                                        let expanded = MacroStage.expandProgram typedModules generated in (
                                          ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                                            ignore (let __old_550 = !_g in let __new_551 = HxInt.add __old_550 1 in (
                                              ignore (_g := __new_551);
                                              __new_551
                                            ));
                                            if StringTools.startsWith name "HXHX_" then ignore (print_endline ((("macro_define2[" ^ HxString.toStdString name) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroState.definedValue name))) else ()
                                          )) done);
                                          ignore (if !noEmit then ignore (let headerOnlyCount = ref 0 in let unsupportedExprsTotal = ref 0 in let unsupportedFilesCount = ref 0 in let traceUnsupported = isTrueEnv "HXHX_TRACE_UNSUPPORTED" in let unsupportedRawCount = ref 0 in let unsupportedFnCount = ref 0 in let unsupportedFileIndex = ref 0 in (
                                            ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                              ignore (let __old_552 = !_g in let __new_553 = HxInt.add __old_552 1 in (
                                                ignore (_g := __new_553);
                                                __new_553
                                              ));
                                              let pm = ResolvedModule.getParsed m in (
                                                ignore (if HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ()) then ignore (headerOnlyCount := HxInt.add (!headerOnlyCount) 1) else ());
                                                let unsupportedInFile = countUnsupportedExprsInModule pm in (
                                                  ignore (unsupportedExprsTotal := HxInt.add (!unsupportedExprsTotal) unsupportedInFile);
                                                  if unsupportedInFile > 0 then ignore ((
                                                    ignore (unsupportedFilesCount := HxInt.add (!unsupportedFilesCount) 1);
                                                    ignore (print_endline ((((((("unsupported_file[" ^ string_of_int (!unsupportedFileIndex)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ " header_only=") ^ HxString.toStdString (bool01 (HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ())))) ^ " unsupported_exprs=") ^ string_of_int unsupportedInFile));
                                                    ignore (unsupportedFileIndex := HxInt.add (!unsupportedFileIndex) 1);
                                                    if traceUnsupported then ignore (let cls = HxModuleDecl.getMainClass (ParsedModule.getDecl pm ()) in (
                                                      ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions cls in try while !_g2 < HxArray.length _g1 do try ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                        ignore (let __old_554 = !_g2 in let __new_555 = HxInt.add __old_554 1 in (
                                                          ignore (_g2 := __new_555);
                                                          __new_555
                                                        ));
                                                        let fnUnsupported = countUnsupportedExprsInFunction fn in (
                                                          ignore (if fnUnsupported <= 0 then raise (HxRuntime.Hx_continue) else ());
                                                          ignore (print_endline ((((((("unsupported_fn[" ^ string_of_int (!unsupportedFnCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":") ^ HxString.toStdString (HxFunctionDecl.getName fn)) ^ " unsupported_exprs=") ^ string_of_int fnUnsupported));
                                                          ignore (unsupportedFnCount := HxInt.add (!unsupportedFnCount) 1);
                                                          if !unsupportedFnCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                        )
                                                      )) with
                                                        | HxRuntime.Hx_continue -> () done with
                                                        | HxRuntime.Hx_break -> ());
                                                      let _g2 = ref 0 in let _g1 = collectUnsupportedExprRawInModule pm 20 in try while !_g2 < HxArray.length _g1 do try ignore (let raw = HxArray.get _g1 (!_g2) in (
                                                        ignore (let __old_556 = !_g2 in let __new_557 = HxInt.add __old_556 1 in (
                                                          ignore (_g2 := __new_557);
                                                          __new_557
                                                        ));
                                                        let escaped = escapeOneLine raw in let tempNumber1 = ref 0 in (
                                                          ignore (if raw == Obj.magic (HxRuntime.hx_null) then let __assign_558 = 0 in (
                                                            tempNumber1 := __assign_558;
                                                            __assign_558
                                                          ) else let __assign_559 = HxString.length raw in (
                                                            tempNumber1 := __assign_559;
                                                            __assign_559
                                                          ));
                                                          ignore (print_endline ((((((("unsupported_expr[" ^ string_of_int (!unsupportedRawCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":raw=") ^ HxString.toStdString escaped) ^ " len=") ^ string_of_int (!tempNumber1)));
                                                          ignore (unsupportedRawCount := HxInt.add (!unsupportedRawCount) 1);
                                                          if !unsupportedRawCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                        )
                                                      )) with
                                                        | HxRuntime.Hx_continue -> () done with
                                                        | HxRuntime.Hx_break -> ()
                                                    )) else ()
                                                  )) else ()
                                                )
                                              )
                                            )) done);
                                            ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                              ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                              let __assign_560 = Obj.magic (HxRuntime.hx_null) in (
                                                macroSession := __assign_560;
                                                __assign_560
                                              )
                                            )) else ());
                                            ignore (print_endline ("typed_modules=" ^ string_of_int (HxArray.length typedModules)));
                                            ignore (print_endline ("header_only_modules=" ^ string_of_int (!headerOnlyCount)));
                                            ignore (print_endline ("unsupported_exprs_total=" ^ string_of_int (!unsupportedExprsTotal)));
                                            ignore (print_endline ("unsupported_files=" ^ string_of_int (!unsupportedFilesCount)));
                                            ignore (print_endline "stage3=no_emit_ok");
                                            raise (HxRuntime.Hx_return (Obj.repr 0))
                                          )) else ());
                                          let tempString2 = ref "" in (
                                            ignore (try let __assign_561 = EmitterStage.emitToDir expanded outAbs emitFullBodies in (
                                              tempString2 := __assign_561;
                                              __assign_561
                                            ) with
                                              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                              | HxRuntime.Hx_return __ret_562 -> raise (HxRuntime.Hx_return __ret_562)
                                              | HxRuntime.Hx_exception (__exn_v_563, __exn_tags_564) -> if true then let e = (__exn_v_563 : Obj.t) in (
                                                ignore e;
                                                (
                                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                    let __assign_565 = Obj.magic (HxRuntime.hx_null) in (
                                                      macroSession := __assign_565;
                                                      __assign_565
                                                    )
                                                  )) else ());
                                                  raise (HxRuntime.Hx_return (Obj.repr (error ("emit failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                )
                                              ) else HxRuntime.hx_throw_typed __exn_v_563 __exn_tags_564
                                              | __exn_566 -> if true then let e = (Obj.repr __exn_566 : Obj.t) in (
                                                ignore e;
                                                (
                                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                    let __assign_567 = Obj.magic (HxRuntime.hx_null) in (
                                                      macroSession := __assign_567;
                                                      __assign_567
                                                    )
                                                  )) else ());
                                                  raise (HxRuntime.Hx_return (Obj.repr (error ("emit failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                )
                                              ) else raise (__exn_566));
                                            ignore (print_endline "stage3=ok");
                                            ignore (print_endline ("outDir=" ^ HxString.toStdString outAbs));
                                            ignore (print_endline ("exe=" ^ HxString.toStdString (!tempString2)));
                                            ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                              ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                              let __assign_568 = Obj.magic (HxRuntime.hx_null) in (
                                                macroSession := __assign_568;
                                                __assign_568
                                              )
                                            )) else ());
                                            ignore (if noRun then ignore ((
                                              ignore (print_endline "run=skipped");
                                              raise (HxRuntime.Hx_return (Obj.repr 0))
                                            )) else ());
                                            let code = HxSys.command (!tempString2) (Some (let __arr_569 = HxArray.create () in __arr_569)) in (
                                              ignore (if code <> 0 then raise (HxRuntime.Hx_return (Obj.repr (error ("built executable failed with exit code " ^ string_of_int code)))) else ());
                                              ignore (print_endline "run=ok");
                                              0
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_570 -> Obj.obj __ret_570

let findFlagValue = fun args a b -> try let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore (let t = HxArray.get args (!i) in (
    ignore (if (HxString.equals t a || HxString.equals t b) && HxInt.add (!i) 1 < HxArray.length args then raise (HxRuntime.Hx_return (Obj.repr (HxArray.get args (HxInt.add (!i) 1)))) else ());
    let __old_583 = !i in let __new_584 = HxInt.add __old_583 1 in (
      ignore (i := __new_584);
      __old_583
    )
  )) done);
  Obj.magic (HxRuntime.hx_null)
) with
  | HxRuntime.Hx_return __ret_585 -> Obj.obj __ret_585

let findManyFlagValues = fun args a b c -> let out = HxArray.create () in let i = ref 0 in (
  ignore (try while !i < HxArray.length args do try ignore (let t = HxArray.get args (!i) in let hx_match = HxString.equals t a || HxString.equals t b || c != Obj.magic (HxRuntime.hx_null) && HxString.equals t c in (
    ignore (if hx_match && HxInt.add (!i) 1 < HxArray.length args then ignore ((
      ignore (HxArray.push out (HxArray.get args (HxInt.add (!i) 1)));
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    let __old_586 = !i in let __new_587 = HxInt.add __old_586 1 in (
      ignore (i := __new_587);
      __old_586
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  out
)

let summarizeArgs = fun args -> try let joined = HxArray.join args " " (fun x -> x) in let maxLen = 160 in (
  ignore (if HxString.length joined <= maxLen then raise (HxRuntime.Hx_return (Obj.repr joined)) else ());
  HxString.toStdString (HxString.substr joined 0 maxLen) ^ "..."
) with
  | HxRuntime.Hx_return __ret_588 -> Obj.obj __ret_588

let run = fun args -> try let tempStruct = ref (Obj.magic ()) in (
  ignore (try let __assign_571 = parseGlobalStage3Flags args in (
    tempStruct := __assign_571;
    __assign_571
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_572 -> raise (HxRuntime.Hx_return __ret_572)
    | HxRuntime.Hx_exception (__exn_v_573, __exn_tags_574) -> if true then let e = (__exn_v_573 : Obj.t) in (
      ignore e;
      raise (HxRuntime.Hx_return (Obj.repr (error (HxRuntime.dynamic_toStdString e))))
    ) else HxRuntime.hx_throw_typed __exn_v_573 __exn_tags_574
    | __exn_575 -> if true then let e = (Obj.repr __exn_575 : Obj.t) in (
      ignore e;
      raise (HxRuntime.Hx_return (Obj.repr (error (HxRuntime.dynamic_toStdString e))))
    ) else raise (__exn_575));
  let units = Hxhx_Hxml.expandArgsToUnits (Obj.obj (HxAnon.get (!tempStruct) "rest")) in (
    ignore (if units == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (error "failed to expand .hxml args (multi-unit)"))) else ());
    ignore (if HxArray.length units <= 1 then raise (HxRuntime.Hx_return (Obj.repr (runOne args))) else ());
    let _g = ref 0 in let _g1 = HxArray.length units in (
      ignore (while !_g < _g1 do ignore (let idx = let __old_576 = !_g in let __new_577 = HxInt.add __old_576 1 in (
        ignore (_g := __new_577);
        __old_576
      ) in let u = HxArray.get units idx in let unitArgs = HxArray.create () in (
        ignore (if Obj.obj (HxAnon.get (!tempStruct) "typeOnly") then ignore (HxArray.push unitArgs "--hxhx-type-only") else ());
        ignore (if Obj.obj (HxAnon.get (!tempStruct) "noEmit") then ignore (HxArray.push unitArgs "--hxhx-no-emit") else ());
        ignore (if Obj.obj (HxAnon.get (!tempStruct) "noRun") then ignore (HxArray.push unitArgs "--hxhx-no-run") else ());
        ignore (if Obj.obj (HxAnon.get (!tempStruct) "emitFullBodies") then ignore (HxArray.push unitArgs "--hxhx-emit-full-bodies") else ());
        ignore (if Obj.obj (HxAnon.get (!tempStruct) "outDir") != Obj.magic (HxRuntime.hx_null) && HxString.length (Obj.obj (HxAnon.get (!tempStruct) "outDir")) > 0 && not (hasFlag u "--hxhx-out") then ignore ((
          ignore (HxArray.push unitArgs "--hxhx-out");
          HxArray.push unitArgs ((HxString.toStdString (Obj.obj (HxAnon.get (!tempStruct) "outDir")) ^ "_u") ^ string_of_int idx)
        )) else ());
        let _g2 = ref 0 in (
          ignore (while !_g2 < HxArray.length u do ignore (let a = HxArray.get u (!_g2) in (
            ignore (let __old_578 = !_g2 in let __new_579 = HxInt.add __old_578 1 in (
              ignore (_g2 := __new_579);
              __new_579
            ));
            HxArray.push unitArgs a
          )) done);
          ignore (if HxString.equals (HxSys.getEnv "HXHX_TRACE_UNITS") "1" then ignore (let main = findFlagValue u "-main" "--main" in let cp = findManyFlagValues u "-cp" "--class-path" "-p" in let tempMaybeString = ref (Obj.magic ()) in (
            ignore (if main == Obj.magic (HxRuntime.hx_null) then let __assign_580 = "<none>" in (
              tempMaybeString := __assign_580;
              __assign_580
            ) else let __assign_581 = main in (
              tempMaybeString := __assign_581;
              __assign_581
            ));
            print_endline ((((((("hxhx(stage3): unit_begin idx=" ^ string_of_int idx) ^ " main=") ^ HxString.toStdString (!tempMaybeString)) ^ " cp=") ^ HxString.toStdString (HxArray.join cp "," (fun x -> x))) ^ " args=") ^ HxString.toStdString (summarizeArgs u))
          )) else ());
          let code = runOne unitArgs in if code <> 0 then raise (HxRuntime.Hx_return (Obj.repr code)) else ()
        )
      )) done);
      0
    )
  )
) with
  | HxRuntime.Hx_return __ret_582 -> Obj.obj __ret_582
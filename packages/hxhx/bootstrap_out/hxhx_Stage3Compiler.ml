# 1 "hxhx_Stage3Compiler.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.Stage3Compiler *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.Stage3Compiler" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.Stage3Compiler" } : t)

let error = fun msg -> (
  ignore (print_endline ("hxhx(stage3): " ^ HxString.toStdString msg));
  2
)

let escapeOneLine = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  StringTools.replace (StringTools.replace (StringTools.replace (StringTools.replace s "\\" "\\\\") "\r" "\\r") "\n" "\\n") "\t" "\\t"
) with
  | HxRuntime.Hx_return __ret_1 -> Obj.obj __ret_1

let rec countUnsupportedExprsInExpr = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let tempResult = ref 0 in (
    ignore (if e == Obj.magic (HxRuntime.hx_null) then let __assign_2 = 0 in (
      tempResult := __assign_2;
      __assign_2
    ) else match let __enum_idx_38 = e in if __enum_idx_38 == HxRuntime.hx_null then -1 else match Obj.obj __enum_idx_38 with
      | HxExpr.ENull -> 0
      | HxExpr.EBool _ -> 1
      | HxExpr.EString _ -> 2
      | HxExpr.EInt _ -> 3
      | HxExpr.EFloat _ -> 4
      | HxExpr.EThis -> 5
      | HxExpr.ESuper -> 6
      | HxExpr.EIdent _ -> 7
      | HxExpr.EField (_, _) -> 8
      | HxExpr.ECall (_, _) -> 9
      | HxExpr.ENew (_, _) -> 10
      | HxExpr.EUnop (_, _) -> 11
      | HxExpr.EBinop (_, _, _) -> 12
      | HxExpr.EUnsupported _ -> 13 with
      | 8 -> let _g = let __enum_param_5 = e in if __enum_param_5 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_5 with
        | HxExpr.EField (__enum_param_4, _) -> __enum_param_4
        | _ -> failwith "Unexpected enum parameter" in (
        ignore (let __enum_param_7 = e in if __enum_param_7 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_7 with
          | HxExpr.EField (_, __enum_param_6) -> __enum_param_6
          | _ -> failwith "Unexpected enum parameter");
        let obj = _g in let __assign_8 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr obj)) in (
          tempResult := __assign_8;
          __assign_8
        )
      )
      | 9 -> let _g = let __enum_param_10 = e in if __enum_param_10 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_10 with
        | HxExpr.ECall (__enum_param_9, _) -> __enum_param_9
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_12 = e in if __enum_param_12 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_12 with
        | HxExpr.ECall (_, __enum_param_11) -> __enum_param_11
        | _ -> failwith "Unexpected enum parameter" in let callee = _g in let args = _g1 in let c = ref (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr callee))) in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
          ignore (let __old_13 = !_g2 in let __new_14 = HxInt.add __old_13 1 in (
            ignore (_g2 := __new_14);
            __new_14
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)))
        )) done);
        let __assign_15 = !c in (
          tempResult := __assign_15;
          __assign_15
        )
      )
      | 10 -> let _g = let __enum_param_17 = e in if __enum_param_17 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_17 with
        | HxExpr.ENew (__enum_param_16, _) -> __enum_param_16
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_19 = e in if __enum_param_19 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_19 with
        | HxExpr.ENew (_, __enum_param_18) -> __enum_param_18
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let args = _g1 in let c = ref 0 in (
          ignore (let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
            ignore (let __old_20 = !_g2 in let __new_21 = HxInt.add __old_20 1 in (
              ignore (_g2 := __new_21);
              __new_21
            ));
            c := HxInt.add (!c) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)))
          )) done);
          let __assign_22 = !c in (
            tempResult := __assign_22;
            __assign_22
          )
        )
      )
      | 11 -> let _g = let __enum_param_24 = e in if __enum_param_24 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_24 with
        | HxExpr.EUnop (__enum_param_23, _) -> __enum_param_23
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_26 = e in if __enum_param_26 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_26 with
        | HxExpr.EUnop (_, __enum_param_25) -> __enum_param_25
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let expr = _g1 in let __assign_27 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
          tempResult := __assign_27;
          __assign_27
        )
      )
      | 12 -> let _g = let __enum_param_29 = e in if __enum_param_29 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_29 with
        | HxExpr.EBinop (__enum_param_28, _, _) -> __enum_param_28
        | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_31 = e in if __enum_param_31 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_31 with
        | HxExpr.EBinop (_, __enum_param_30, _) -> __enum_param_30
        | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_33 = e in if __enum_param_33 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_33 with
        | HxExpr.EBinop (_, _, __enum_param_32) -> __enum_param_32
        | _ -> failwith "Unexpected enum parameter" in (
        ignore _g;
        let left = _g1 in let right = _g2 in let __assign_34 = HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr left))) (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr right))) in (
          tempResult := __assign_34;
          __assign_34
        )
      )
      | 13 -> (
        ignore (let __enum_param_36 = e in if __enum_param_36 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_36 with
          | HxExpr.EUnsupported __enum_param_35 -> __enum_param_35
          | _ -> failwith "Unexpected enum parameter");
        let __assign_37 = 1 in (
          tempResult := __assign_37;
          __assign_37
        )
      )
      | _ -> let __assign_3 = 0 in (
        tempResult := __assign_3;
        __assign_3
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_39 -> Obj.obj __ret_39

let rec collectUnsupportedExprRawInExpr = fun e out max -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxArray.length out >= max then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  if e == Obj.magic (HxRuntime.hx_null) then ignore () else ignore (match let __enum_idx_68 = e in if __enum_idx_68 == HxRuntime.hx_null then -1 else match Obj.obj __enum_idx_68 with
    | HxExpr.ENull -> 0
    | HxExpr.EBool _ -> 1
    | HxExpr.EString _ -> 2
    | HxExpr.EInt _ -> 3
    | HxExpr.EFloat _ -> 4
    | HxExpr.EThis -> 5
    | HxExpr.ESuper -> 6
    | HxExpr.EIdent _ -> 7
    | HxExpr.EField (_, _) -> 8
    | HxExpr.ECall (_, _) -> 9
    | HxExpr.ENew (_, _) -> 10
    | HxExpr.EUnop (_, _) -> 11
    | HxExpr.EBinop (_, _, _) -> 12
    | HxExpr.EUnsupported _ -> 13 with
    | 8 -> ignore (let _g = let __enum_param_41 = e in if __enum_param_41 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_41 with
      | HxExpr.EField (__enum_param_40, _) -> __enum_param_40
      | _ -> failwith "Unexpected enum parameter" in (
      ignore (let __enum_param_43 = e in if __enum_param_43 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_43 with
        | HxExpr.EField (_, __enum_param_42) -> __enum_param_42
        | _ -> failwith "Unexpected enum parameter");
      let obj = _g in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr obj)) out max
    ))
    | 9 -> ignore (let _g = let __enum_param_45 = e in if __enum_param_45 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_45 with
      | HxExpr.ECall (__enum_param_44, _) -> __enum_param_44
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_47 = e in if __enum_param_47 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_47 with
      | HxExpr.ECall (_, __enum_param_46) -> __enum_param_46
      | _ -> failwith "Unexpected enum parameter" in let callee = _g in let args = _g1 in (
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr callee)) out max);
      let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
        ignore (let __old_48 = !_g2 in let __new_49 = HxInt.add __old_48 1 in (
          ignore (_g2 := __new_49);
          __new_49
        ));
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)) out max
      )) done
    ))
    | 10 -> ignore (let _g = let __enum_param_51 = e in if __enum_param_51 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_51 with
      | HxExpr.ENew (__enum_param_50, _) -> __enum_param_50
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_53 = e in if __enum_param_53 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_53 with
      | HxExpr.ENew (_, __enum_param_52) -> __enum_param_52
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let args = _g1 in let _g2 = ref 0 in while !_g2 < HxArray.length args do ignore (let a = HxArray.get args (!_g2) in (
        ignore (let __old_54 = !_g2 in let __new_55 = HxInt.add __old_54 1 in (
          ignore (_g2 := __new_55);
          __new_55
        ));
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr a)) out max
      )) done
    ))
    | 11 -> ignore (let _g = let __enum_param_57 = e in if __enum_param_57 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_57 with
      | HxExpr.EUnop (__enum_param_56, _) -> __enum_param_56
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_59 = e in if __enum_param_59 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_59 with
      | HxExpr.EUnop (_, __enum_param_58) -> __enum_param_58
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let expr = _g1 in collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
    | 12 -> ignore (let _g = let __enum_param_61 = e in if __enum_param_61 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_61 with
      | HxExpr.EBinop (__enum_param_60, _, _) -> __enum_param_60
      | _ -> failwith "Unexpected enum parameter" in let _g1 = let __enum_param_63 = e in if __enum_param_63 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_63 with
      | HxExpr.EBinop (_, __enum_param_62, _) -> __enum_param_62
      | _ -> failwith "Unexpected enum parameter" in let _g2 = let __enum_param_65 = e in if __enum_param_65 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_65 with
      | HxExpr.EBinop (_, _, __enum_param_64) -> __enum_param_64
      | _ -> failwith "Unexpected enum parameter" in (
      ignore _g;
      let left = _g1 in let right = _g2 in (
        ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr left)) out max);
        collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr right)) out max
      )
    ))
    | 13 -> ignore (let _g = let __enum_param_67 = e in if __enum_param_67 == HxRuntime.hx_null then failwith "Unexpected enum parameter" else match Obj.obj __enum_param_67 with
      | HxExpr.EUnsupported __enum_param_66 -> __enum_param_66
      | _ -> failwith "Unexpected enum parameter" in let raw = _g in if HxArray.length out < max then ignore (HxArray.push out raw) else ())
    | _ -> ignore ())
) with
  | HxRuntime.Hx_return __ret_69 -> Obj.obj __ret_69

let rec collectUnsupportedExprRawInStmt = fun s out max -> try (
  ignore (if HxArray.length out >= max then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  match s with
    | HxStmt.SBlock (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let stmts = _g in (
      ignore _g1;
      let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let ss = HxArray.get stmts (!_g2) in (
        ignore (let __old_70 = !_g2 in let __new_71 = HxInt.add __old_70 1 in (
          ignore (_g2 := __new_71);
          __new_71
        ));
        collectUnsupportedExprRawInStmt ss out max
      )) done
    ))
    | HxStmt.SVar (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in (
      ignore _g;
      ignore _g1;
      let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in (
        ignore _g3;
        collectUnsupportedExprRawInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) out max
      )
    ))
    | HxStmt.SIf (_p0, _p1, _p2, _p3) -> ignore (let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
      ignore _g3;
      ignore (collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond)) out max);
      ignore (collectUnsupportedExprRawInStmt thenBranch out max);
      if elseBranch != Obj.magic (HxRuntime.hx_null) then ignore (collectUnsupportedExprRawInStmt (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) out max) else ()
    ))
    | HxStmt.SReturnVoid _p0 -> ignore (let _g = _p0 in (
      ignore _g;
      ()
    ))
    | HxStmt.SReturn (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
    | HxStmt.SExpr (_p0, _p1) -> ignore (let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      collectUnsupportedExprRawInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) out max
    ))
) with
  | HxRuntime.Hx_return __ret_72 -> Obj.obj __ret_72

let collectUnsupportedExprRawInModule = fun pm max -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let out = HxArray.create () in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_73 = !_g in let __new_74 = HxInt.add __old_73 1 in (
      ignore (_g := __new_74);
      __new_74
    ));
    collectUnsupportedExprRawInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (HxFieldDecl.getInit f))) out max
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_75 = !_g in let __new_76 = HxInt.add __old_75 1 in (
      ignore (_g := __new_76);
      __new_76
    ));
    let _g2 = ref 0 in let _g3 = HxFunctionDecl.getBody fn in while !_g2 < HxArray.length _g3 do ignore (let s = HxArray.get _g3 (!_g2) in (
      ignore (let __old_77 = !_g2 in let __new_78 = HxInt.add __old_77 1 in (
        ignore (_g2 := __new_78);
        __new_78
      ));
      collectUnsupportedExprRawInStmt s out max
    )) done
  )) done);
  out
)

let rec countUnsupportedExprsInStmt = fun s -> let tempResult = ref 0 in (
  ignore (match s with
    | HxStmt.SBlock (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let stmts = _g in (
      ignore _g1;
      let c = ref 0 in (
        ignore (let _g2 = ref 0 in while !_g2 < HxArray.length stmts do ignore (let ss = HxArray.get stmts (!_g2) in (
          ignore (let __old_79 = !_g2 in let __new_80 = HxInt.add __old_79 1 in (
            ignore (_g2 := __new_80);
            __new_80
          ));
          c := HxInt.add (!c) (countUnsupportedExprsInStmt ss)
        )) done);
        let __assign_81 = !c in (
          tempResult := __assign_81;
          __assign_81
        )
      )
    )
    | HxStmt.SVar (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _p2) in let _g3 = _p3 in (
      ignore _g;
      ignore _g1;
      let init = Obj.obj (HxEnum.unbox_or_obj "HxExpr" _g2) in (
        ignore _g3;
        let __assign_82 = countUnsupportedExprsInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" init)) in (
          tempResult := __assign_82;
          __assign_82
        )
      )
    )
    | HxStmt.SIf (_p0, _p1, _p2, _p3) -> let _g = _p0 in let _g1 = _p1 in let _g2 = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _p2) in let _g3 = _p3 in let cond = _g in let thenBranch = _g1 in let elseBranch = Obj.obj (HxEnum.unbox_or_obj "HxStmt" _g2) in (
      ignore _g3;
      let tempNumber = ref 0 in (
        ignore (if elseBranch == Obj.magic (HxRuntime.hx_null) then let __assign_83 = 0 in (
          tempNumber := __assign_83;
          __assign_83
        ) else let __assign_84 = countUnsupportedExprsInStmt (Obj.obj (HxEnum.unbox_or_obj "HxStmt" elseBranch)) in (
          tempNumber := __assign_84;
          __assign_84
        ));
        let __assign_85 = HxInt.add (HxInt.add (countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr cond))) (countUnsupportedExprsInStmt thenBranch)) (!tempNumber) in (
          tempResult := __assign_85;
          __assign_85
        )
      )
    )
    | HxStmt.SReturnVoid _p0 -> let _g = _p0 in (
      ignore _g;
      let __assign_86 = 0 in (
        tempResult := __assign_86;
        __assign_86
      )
    )
    | HxStmt.SReturn (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      let __assign_87 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
        tempResult := __assign_87;
        __assign_87
      )
    )
    | HxStmt.SExpr (_p0, _p1) -> let _g = _p0 in let _g1 = _p1 in let expr = _g in (
      ignore _g1;
      let __assign_88 = countUnsupportedExprsInExpr (HxEnum.box_if_needed "HxExpr" (Obj.repr expr)) in (
        tempResult := __assign_88;
        __assign_88
      )
    ));
  !tempResult
)

let countUnsupportedExprsInModule = fun pm -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let c = ref 0 in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_89 = !_g in let __new_90 = HxInt.add __old_89 1 in (
      ignore (_g := __new_90);
      __new_90
    ));
    c := HxInt.add (!c) (countUnsupportedExprsInExpr (Obj.obj (HxEnum.unbox_or_obj "HxExpr" (HxFieldDecl.getInit f))))
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_91 = !_g in let __new_92 = HxInt.add __old_91 1 in (
      ignore (_g := __new_92);
      __new_92
    ));
    let _g2 = ref 0 in let _g3 = HxFunctionDecl.getBody fn in while !_g2 < HxArray.length _g3 do ignore (let s = HxArray.get _g3 (!_g2) in (
      ignore (let __old_93 = !_g2 in let __new_94 = HxInt.add __old_93 1 in (
        ignore (_g2 := __new_94);
        __new_94
      ));
      c := HxInt.add (!c) (countUnsupportedExprsInStmt s)
    )) done
  )) done);
  !c
)

let countUnsupportedExprsInFunction = fun fn -> let c = ref 0 in let _g = ref 0 in let _g1 = HxFunctionDecl.getBody fn in (
  ignore (while !_g < HxArray.length _g1 do ignore (let s = HxArray.get _g1 (!_g) in (
    ignore (let __old_95 = !_g in let __new_96 = HxInt.add __old_95 1 in (
      ignore (_g := __new_96);
      __new_96
    ));
    c := HxInt.add (!c) (countUnsupportedExprsInStmt s)
  )) done);
  !c
)

let bool01 = fun v -> let tempResult = ref "" in (
  ignore (if v then let __assign_97 = "1" in (
    tempResult := __assign_97;
    __assign_97
  ) else let __assign_98 = "0" in (
    tempResult := __assign_98;
    __assign_98
  ));
  !tempResult
)

let formatException = fun e -> try (
  ignore (if HxType.isOfType e (HxType.class_ "String") then raise (HxRuntime.Hx_return (Obj.repr (Obj.obj e))) else ());
  try (
    ignore (if HxType.isOfType e (HxType.class_ "TyperError") then ignore (let te = Obj.obj e in let p = TyperError.getPos te () in let tempNumber = ref 0 in (
      ignore (if p == Obj.magic (HxRuntime.hx_null) then let __assign_99 = 0 in (
        tempNumber := __assign_99;
        __assign_99
      ) else let __assign_100 = HxPos.getLine p () in (
        tempNumber := __assign_100;
        __assign_100
      ));
      let line = !tempNumber in let tempNumber1 = ref 0 in (
        ignore (if p == Obj.magic (HxRuntime.hx_null) then let __assign_101 = 0 in (
          tempNumber1 := __assign_101;
          __assign_101
        ) else let __assign_102 = HxPos.getColumn p () in (
          tempNumber1 := __assign_102;
          __assign_102
        ));
        let col = !tempNumber1 in raise (HxRuntime.Hx_return (Obj.repr ((((((HxString.toStdString (TyperError.getFilePath te ()) ^ ":") ^ string_of_int line) ^ ":") ^ string_of_int col) ^ ": ") ^ HxString.toStdString (TyperError.getMessage te ()))))
      )
    )) else ());
    let msg = HxRuntime.dynamic_toStdString e in let debug = HxSys.getEnv "HXHX_DEBUG_EXN" in (
      ignore (if HxString.equals debug "1" || HxString.equals debug "true" || HxString.equals debug "yes" then ignore (let details = ref ("typeof=" ^ HxString.toStdString (HxRuntime.dynamic_toStdString (Obj.repr (let __typeof_v_103 = e in if HxRuntime.is_null __typeof_v_103 then Type.TNull else if HxRuntime.is_boxed_bool __typeof_v_103 then Type.TBool else if Obj.is_int __typeof_v_103 then Type.TInt else if Obj.tag __typeof_v_103 = Obj.double_tag then Type.TFloat else if Obj.tag __typeof_v_103 = Obj.string_tag then Type.TClass (HxType.class_ "String") else if Obj.tag __typeof_v_103 = Obj.closure_tag then Type.TFunction else match HxEnum.name_opt __typeof_v_103 with
        | Some __enum_name_104 -> Type.TEnum (HxType.enum_ __enum_name_104)
        | _ -> let __cls_105 = HxType.getClass __typeof_v_103 in if HxRuntime.is_null __cls_105 then Type.TObject else Type.TClass __cls_105)))) in let cls = HxType.getClass e in (
        ignore (if cls != Obj.magic (HxRuntime.hx_null) then ignore (details := HxString.toStdString (!details) ^ ";class=" ^ HxString.toStdString (HxType.getClassName cls)) else ());
        let fields = HxAnon.fields e in (
          ignore (if fields != Obj.magic (HxRuntime.hx_null) && HxArray.length fields > 0 then ignore (details := HxString.toStdString (!details) ^ ";fields=" ^ HxString.toStdString (HxArray.join fields "," (fun x -> x))) else ());
          ignore (if HxAnon.has e "message" then ignore (details := HxString.toStdString (!details) ^ ";message=" ^ HxString.toStdString (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get e "message")))) else ());
          raise (HxRuntime.Hx_return (Obj.repr ((HxString.toStdString msg ^ " :: ") ^ HxString.toStdString (!details))))
        )
      )) else ());
      raise (HxRuntime.Hx_return (Obj.repr msg))
    )
  ) with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_106 -> raise (HxRuntime.Hx_return __ret_106)
    | HxRuntime.Hx_exception (__exn_v_107, __exn_tags_108) -> if true then let _hx = (__exn_v_107 : Obj.t) in (
      ignore _hx;
      raise (HxRuntime.Hx_return (Obj.repr (HxRuntime.dynamic_toStdString e)))
    ) else HxRuntime.hx_throw_typed __exn_v_107 __exn_tags_108
    | __exn_109 -> if true then let _hx = (Obj.repr __exn_109 : Obj.t) in (
      ignore _hx;
      raise (HxRuntime.Hx_return (Obj.repr (HxRuntime.dynamic_toStdString e)))
    ) else raise (__exn_109)
) with
  | HxRuntime.Hx_return __ret_110 -> Obj.obj __ret_110

let haxelibBin = fun () -> let v = HxSys.getEnv "HAXELIB_BIN" in let tempResult = ref "" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then let __assign_111 = "haxelib" in (
    tempResult := __assign_111;
    __assign_111
  ) else let __assign_112 = v in (
    tempResult := __assign_112;
    __assign_112
  ));
  !tempResult
)

let resolveHaxelibSpecViaProcess = fun lib -> try let classPaths = HxArray.create () in let defines = HxArray.create () in let macros = HxArray.create () in let unknownArgs = HxArray.create () in let p = Sys_io_Process.create (haxelibBin ()) (let __arr_119 = HxArray.create () in (
  ignore (HxArray.push __arr_119 "path");
  ignore (HxArray.push __arr_119 lib);
  __arr_119
)) (HxRuntime.hx_null) in (
  ignore (try try while true do try ignore (let raw = let __obj_120 = p.stdout in __obj_120.readLine (Obj.magic __obj_120) () in let line = StringTools.trim raw in (
    ignore (if HxString.length line = 0 then raise (HxRuntime.Hx_continue) else ());
    ignore (if not (StringTools.startsWith line "-") then ignore ((
      ignore (HxArray.push classPaths line);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "-D " then ignore (let def = StringTools.trim (HxString.substr line 3 (-1)) in (
      ignore (if HxString.length def > 0 then ignore (HxArray.push defines def) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "--macro " then ignore (let expr = StringTools.trim (HxString.substr line 8 (-1)) in (
      ignore (if HxString.length expr > 0 then ignore (HxArray.push macros expr) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "-cp " then ignore (let cp = StringTools.trim (HxString.substr line 4 (-1)) in (
      ignore (if HxString.length cp > 0 then ignore (HxArray.push classPaths cp) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if StringTools.startsWith line "--class-path " then ignore (let cp = StringTools.trim (HxString.substr line 13 (-1)) in (
      ignore (if HxString.length cp > 0 then ignore (HxArray.push classPaths cp) else ());
      raise (HxRuntime.Hx_continue)
    )) else ());
    HxArray.push unknownArgs line
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> () with
    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
    | HxRuntime.Hx_return __ret_121 -> raise (HxRuntime.Hx_return __ret_121)
    | HxRuntime.Hx_exception (__exn_v_122, __exn_tags_123) -> if HxRuntime.tags_has __exn_tags_123 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_122 : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else HxRuntime.hx_throw_typed __exn_v_122 __exn_tags_123
    | __exn_124 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_124) : Haxe_io_Eof.t) in (
      ignore _hx;
      ()
    ) else raise (__exn_124));
  let code = Sys_io_Process.exitCode p () in (
    ignore (if code <> 0 then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ((("haxelib path " ^ HxString.toStdString lib) ^ " failed with exit code ") ^ string_of_int code)) ["Dynamic"; "String"]))) else ());
    let __anon_125 = HxAnon.create () in (
      ignore (HxAnon.set __anon_125 "classPaths" (Obj.repr classPaths));
      ignore (HxAnon.set __anon_125 "defines" (Obj.repr defines));
      ignore (HxAnon.set __anon_125 "macros" (Obj.repr macros));
      ignore (HxAnon.set __anon_125 "unknownArgs" (Obj.repr unknownArgs));
      __anon_125
    )
  )
) with
  | HxRuntime.Hx_return __ret_126 -> Obj.obj __ret_126

let findHaxeLibrariesHxml = fun lib cwd -> try let tempString = ref "" in (
  ignore (if cwd == Obj.magic (HxRuntime.hx_null) || HxString.length cwd = 0 then let __assign_137 = "." in (
    tempString := __assign_137;
    __assign_137
  ) else let __assign_138 = cwd in (
    tempString := __assign_138;
    __assign_138
  ));
  let _g = ref 0 in (
    ignore (try while !_g < 10 do try ignore ((
      ignore (let __old_139 = !_g in let __new_140 = HxInt.add __old_139 1 in (
        ignore (_g := __new_140);
        __old_139
      ));
      let candidate = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_141 = HxArray.create () in (
        ignore (HxArray.push __arr_141 (!tempString));
        ignore (HxArray.push __arr_141 "haxe_libraries");
        ignore (HxArray.push __arr_141 (HxString.toStdString lib ^ ".hxml"));
        __arr_141
      ))) in (
        ignore (if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ());
        let parent = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_142 = HxArray.create () in (
          ignore (HxArray.push __arr_142 (!tempString));
          ignore (HxArray.push __arr_142 "..");
          __arr_142
        ))) in (
          ignore (if HxString.equals parent (!tempString) then raise (HxRuntime.Hx_break) else ());
          let __assign_143 = parent in (
            tempString := __assign_143;
            __assign_143
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ""
  )
) with
  | HxRuntime.Hx_return __ret_144 -> Obj.obj __ret_144

let rec resolveHaxelibSpec = fun lib cwd seen depth -> try (
  ignore (if depth > 25 then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ("haxelib resolution depth exceeded while resolving: " ^ HxString.toStdString lib)) ["Dynamic"; "String"]))) else ());
  ignore (if HxMap.exists_string seen lib then raise (HxRuntime.Hx_return (Obj.repr (let __anon_113 = HxAnon.create () in (
    ignore (HxAnon.set __anon_113 "classPaths" (Obj.repr (let __arr_114 = HxArray.create () in __arr_114)));
    ignore (HxAnon.set __anon_113 "defines" (Obj.repr (let __arr_115 = HxArray.create () in __arr_115)));
    ignore (HxAnon.set __anon_113 "macros" (Obj.repr (let __arr_116 = HxArray.create () in __arr_116)));
    ignore (HxAnon.set __anon_113 "unknownArgs" (Obj.repr (let __arr_117 = HxArray.create () in __arr_117)));
    __anon_113
  )))) else ());
  ignore (HxMap.set_string seen lib true);
  let hxmlPath = findHaxeLibrariesHxml lib cwd in (
    ignore (if HxString.length hxmlPath > 0 then raise (HxRuntime.Hx_return (Obj.repr (resolveHaxelibSpecFromHxml hxmlPath cwd seen depth))) else ());
    resolveHaxelibSpecViaProcess lib
  )
) with
  | HxRuntime.Hx_return __ret_118 -> Obj.obj __ret_118
and resolveHaxelibSpecFromHxml = fun hxmlPath cwd seen depth -> try let args = Hxhx_Hxml.parseFile hxmlPath in (
  ignore (if args == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ("failed to parse haxelib hxml: " ^ HxString.toStdString hxmlPath)) ["Dynamic"; "String"]))) else ());
  let classPaths = HxArray.create () in let defines = HxArray.create () in let macros = HxArray.create () in let unknownArgs = HxArray.create () in let i = ref 0 in (
    ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in match a with
      | "--class-path" | "-cp" | "-p" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf classPaths v 0 = -1 then ignore (HxArray.push classPaths v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | "--library" | "-lib" -> ignore ((
        ignore (if HxInt.add (!i) 1 >= HxArray.length args then raise (HxRuntime.Hx_return (Obj.repr (HxType.hx_throw_typed_rtti (Obj.repr ((("malformed haxelib hxml (missing value after " ^ HxString.toStdString a) ^ "): ") ^ HxString.toStdString hxmlPath)) ["Dynamic"; "String"]))) else ());
        let dep = HxArray.get args (HxInt.add (!i) 1) in let depSpec = resolveHaxelibSpec dep cwd seen (HxInt.add depth 1) in (
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "classPaths") in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
            ignore (let __old_127 = !_g in let __new_128 = HxInt.add __old_127 1 in (
              ignore (_g := __new_128);
              __new_128
            ));
            if cp == Obj.magic (HxRuntime.hx_null) || HxString.length cp = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf classPaths cp 0 = -1 then ignore (HxArray.push classPaths cp) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "defines") in while !_g < HxArray.length _g1 do ignore (let d = HxArray.get _g1 (!_g) in (
            ignore (let __old_129 = !_g in let __new_130 = HxInt.add __old_129 1 in (
              ignore (_g := __new_130);
              __new_130
            ));
            if d == Obj.magic (HxRuntime.hx_null) || HxString.length d = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf defines d 0 = -1 then ignore (HxArray.push defines d) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "macros") in while !_g < HxArray.length _g1 do ignore (let m = HxArray.get _g1 (!_g) in (
            ignore (let __old_131 = !_g in let __new_132 = HxInt.add __old_131 1 in (
              ignore (_g := __new_132);
              __new_132
            ));
            if m == Obj.magic (HxRuntime.hx_null) || HxString.length m = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf macros m 0 = -1 then ignore (HxArray.push macros m) else ())
          )) done);
          ignore (let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get depSpec "unknownArgs") in while !_g < HxArray.length _g1 do ignore (let u = HxArray.get _g1 (!_g) in (
            ignore (let __old_133 = !_g in let __new_134 = HxInt.add __old_133 1 in (
              ignore (_g := __new_134);
              __new_134
            ));
            if u == Obj.magic (HxRuntime.hx_null) || HxString.length u = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf unknownArgs u 0 = -1 then ignore (HxArray.push unknownArgs u) else ())
          )) done);
          i := HxInt.add (!i) 2
        )
      ))
      | "--macro" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf macros v 0 = -1 then ignore (HxArray.push macros v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | "-D" -> ignore ((
        ignore (if HxInt.add (!i) 1 < HxArray.length args then ignore (let v = HxArray.get args (HxInt.add (!i) 1) in if v == Obj.magic (HxRuntime.hx_null) || HxString.length v = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf defines v 0 = -1 then ignore (HxArray.push defines v) else ())) else ());
        i := HxInt.add (!i) 2
      ))
      | _ -> ignore ((
        ignore (if a != Obj.magic (HxRuntime.hx_null) && HxString.length a > 0 && StringTools.startsWith a "-" then ignore (if a == Obj.magic (HxRuntime.hx_null) || HxString.length a = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxArray.indexOf unknownArgs a 0 = -1 then ignore (HxArray.push unknownArgs a) else ())) else ());
        i := HxInt.add (!i) 1
      ))) done);
    let __anon_135 = HxAnon.create () in (
      ignore (HxAnon.set __anon_135 "classPaths" (Obj.repr classPaths));
      ignore (HxAnon.set __anon_135 "defines" (Obj.repr defines));
      ignore (HxAnon.set __anon_135 "macros" (Obj.repr macros));
      ignore (HxAnon.set __anon_135 "unknownArgs" (Obj.repr unknownArgs));
      __anon_135
    )
  )
) with
  | HxRuntime.Hx_return __ret_136 -> Obj.obj __ret_136

let absFromCwd = fun cwd path -> try (
  ignore (if path == Obj.magic (HxRuntime.hx_null) || HxString.length path = 0 then raise (HxRuntime.Hx_return (Obj.repr cwd)) else ());
  let tempResult = ref "" in (
    ignore (if Haxe_io_Path.isAbsolute path then let __assign_145 = Haxe_io_Path.normalize path in (
      tempResult := __assign_145;
      __assign_145
    ) else let __assign_146 = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_147 = HxArray.create () in (
      ignore (HxArray.push __arr_147 cwd);
      ignore (HxArray.push __arr_147 path);
      __arr_147
    ))) in (
      tempResult := __assign_146;
      __assign_146
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_148 -> Obj.obj __ret_148

let inferRepoRootForScripts = fun () -> try let env = HxSys.getEnv "HXHX_REPO_ROOT" in (
  ignore (if env != Obj.magic (HxRuntime.hx_null) && HxString.length env > 0 && HxFileSystem.exists env && HxFileSystem.isDirectory env then raise (HxRuntime.Hx_return (Obj.repr env)) else ());
  let prog = HxSys.programPath () in (
    ignore (if prog == Obj.magic (HxRuntime.hx_null) || HxString.length prog = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let tempString = ref "" in (
      ignore (try let __assign_149 = HxFileSystem.fullPath prog in (
        tempString := __assign_149;
        __assign_149
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_150 -> raise (HxRuntime.Hx_return __ret_150)
        | HxRuntime.Hx_exception (__exn_v_151, __exn_tags_152) -> if true then let _hx = (__exn_v_151 : Obj.t) in (
          ignore _hx;
          let __assign_153 = prog in (
            tempString := __assign_153;
            __assign_153
          )
        ) else HxRuntime.hx_throw_typed __exn_v_151 __exn_tags_152
        | __exn_154 -> if true then let _hx = (Obj.repr __exn_154 : Obj.t) in (
          ignore _hx;
          let __assign_155 = prog in (
            tempString := __assign_155;
            __assign_155
          )
        ) else raise (__exn_154));
      let tempString1 = ref "" in (
        ignore (try let __assign_156 = Haxe_io_Path.directory (!tempString) in (
          tempString1 := __assign_156;
          __assign_156
        ) with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_157 -> raise (HxRuntime.Hx_return __ret_157)
          | HxRuntime.Hx_exception (__exn_v_158, __exn_tags_159) -> if true then let _hx = (__exn_v_158 : Obj.t) in (
            ignore _hx;
            let __assign_160 = "" in (
              tempString1 := __assign_160;
              __assign_160
            )
          ) else HxRuntime.hx_throw_typed __exn_v_158 __exn_tags_159
          | __exn_161 -> if true then let _hx = (Obj.repr __exn_161 : Obj.t) in (
            ignore _hx;
            let __assign_162 = "" in (
              tempString1 := __assign_162;
              __assign_162
            )
          ) else raise (__exn_161));
        ignore (if !tempString1 == Obj.magic (HxRuntime.hx_null) || HxString.length (!tempString1) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
        let _g = ref 0 in (
          ignore (try while !_g < 10 do try ignore ((
            ignore (let __old_163 = !_g in let __new_164 = HxInt.add __old_163 1 in (
              ignore (_g := __new_164);
              __old_163
            ));
            let candidate = Haxe_io_Path.join (let __arr_165 = HxArray.create () in (
              ignore (HxArray.push __arr_165 (!tempString1));
              ignore (HxArray.push __arr_165 "scripts");
              ignore (HxArray.push __arr_165 "hxhx");
              ignore (HxArray.push __arr_165 "build-hxhx-macro-host.sh");
              __arr_165
            )) in (
              ignore (if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr (!tempString1))) else ());
              let parent = Haxe_io_Path.normalize (Haxe_io_Path.join (let __arr_166 = HxArray.create () in (
                ignore (HxArray.push __arr_166 (!tempString1));
                ignore (HxArray.push __arr_166 "..");
                __arr_166
              ))) in (
                ignore (if HxString.equals parent (!tempString1) then raise (HxRuntime.Hx_break) else ());
                let __assign_167 = parent in (
                  tempString1 := __assign_167;
                  __assign_167
                )
              )
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ""
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_168 -> Obj.obj __ret_168

let trim = fun s -> let tempResult = ref "" in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then let __assign_169 = "" in (
    tempResult := __assign_169;
    __assign_169
  ) else let __assign_170 = StringTools.trim s in (
    tempResult := __assign_170;
    __assign_170
  ));
  !tempResult
)

let isTrueEnv = fun name -> let v = trim (HxSys.getEnv name) in HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes"

let parseDelimitedList = fun raw -> try let out = HxArray.create () in (
  ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let s = StringTools.trim raw in (
    ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
    let tempArray = ref (Obj.magic ()) in (
      ignore (if HxString.indexOf s ";" 0 <> -1 then let __assign_171 = HxString.split s ";" in (
        tempArray := __assign_171;
        __assign_171
      ) else let __assign_172 = HxString.split s "," in (
        tempArray := __assign_172;
        __assign_172
      ));
      let _g = ref 0 in (
        ignore (try while !_g < HxArray.length (!tempArray) do try ignore (let p = HxArray.get (!tempArray) (!_g) in (
          ignore (let __old_173 = !_g in let __new_174 = HxInt.add __old_173 1 in (
            ignore (_g := __new_174);
            __new_174
          ));
          ignore (if p == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
          let t = StringTools.trim p in (
            ignore (if HxString.length t = 0 then raise (HxRuntime.Hx_continue) else ());
            if HxArray.indexOf out t 0 = -1 then ignore (HxArray.push out t) else ()
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        out
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_175 -> Obj.obj __ret_175

let isBuiltinMacroExpr = fun expr -> let e = trim expr in StringTools.startsWith e "BuiltinMacros." || StringTools.startsWith e "hxhxmacrohost.BuiltinMacros." || StringTools.startsWith e "hxhxmacrohost.BuiltinMacros"

let anyNonBuiltinMacro = fun exprs -> try let _g = ref 0 in (
  ignore (while !_g < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g) in (
    ignore (let __old_176 = !_g in let __new_177 = HxInt.add __old_176 1 in (
      ignore (_g := __new_177);
      __new_177
    ));
    if not (isBuiltinMacroExpr e) then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
  )) done);
  false
) with
  | HxRuntime.Hx_return __ret_178 -> Obj.obj __ret_178

let shouldAutoBuildMacroHost = fun () -> let v = trim (HxSys.getEnv "HXHX_MACRO_HOST_AUTO_BUILD") in HxString.equals v "1" || HxString.equals v "true" || HxString.equals v "yes"

let buildMacroHostExe = fun repoRoot extraCp entrypoints -> let script = Haxe_io_Path.join (let __arr_179 = HxArray.create () in (
  ignore (HxArray.push __arr_179 repoRoot);
  ignore (HxArray.push __arr_179 "scripts");
  ignore (HxArray.push __arr_179 "hxhx");
  ignore (HxArray.push __arr_179 "build-hxhx-macro-host.sh");
  __arr_179
)) in (
  ignore (if not (HxFileSystem.exists script) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("missing macro host build script: " ^ HxString.toStdString script)) ["Dynamic"; "String"]) else ());
  let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if extraCp != Obj.magic (HxRuntime.hx_null) && HxArray.length extraCp > 0 then let __assign_180 = HxArray.join extraCp ":" (fun x -> x) in (
      tempMaybeString := __assign_180;
      __assign_180
    ) else let __assign_181 = "" in (
      tempMaybeString := __assign_181;
      __assign_181
    ));
    ignore (HxSys.putEnv "HXHX_MACRO_HOST_EXTRA_CP" (Some (!tempMaybeString)));
    let tempMaybeString1 = ref (Obj.magic ()) in (
      ignore (if entrypoints != Obj.magic (HxRuntime.hx_null) && HxArray.length entrypoints > 0 then let __assign_182 = HxArray.join entrypoints ";" (fun x -> x) in (
        tempMaybeString1 := __assign_182;
        __assign_182
      ) else let __assign_183 = "" in (
        tempMaybeString1 := __assign_183;
        __assign_183
      ));
      ignore (HxSys.putEnv "HXHX_MACRO_HOST_ENTRYPOINTS" (Some (!tempMaybeString1)));
      let p = Sys_io_Process.create "bash" (let __arr_184 = HxArray.create () in (
        ignore (HxArray.push __arr_184 script);
        __arr_184
      )) (HxRuntime.hx_null) in let lines = HxArray.create () in (
        ignore (try while true do ignore (HxArray.push lines (let __obj_185 = p.stdout in __obj_185.readLine (Obj.magic __obj_185) ())) done with
          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
          | HxRuntime.Hx_return __ret_186 -> raise (HxRuntime.Hx_return __ret_186)
          | HxRuntime.Hx_exception (__exn_v_187, __exn_tags_188) -> if HxRuntime.tags_has __exn_tags_188 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_187 : Haxe_io_Eof.t) in (
            ignore _hx;
            ()
          ) else HxRuntime.hx_throw_typed __exn_v_187 __exn_tags_188
          | __exn_189 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_189) : Haxe_io_Eof.t) in (
            ignore _hx;
            ()
          ) else raise (__exn_189));
        let code = Sys_io_Process.exitCode p () in (
          ignore (Sys_io_Process.close p ());
          ignore (if code <> 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("macro host build failed with exit code " ^ string_of_int code)) ["Dynamic"; "String"]) else ());
          let exe = ref "" in let _g = ref 0 in let _g1 = HxArray.length lines in (
            ignore (while !_g < _g1 do ignore (let i = let __old_190 = !_g in let __new_191 = HxInt.add __old_190 1 in (
              ignore (_g := __new_191);
              __old_190
            ) in let l = trim (HxArray.get lines i) in if HxString.length l > 0 then ignore (let __assign_192 = l in (
              exe := __assign_192;
              __assign_192
            )) else ()) done);
            ignore (if HxString.length (!exe) = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr "macro host build produced no executable path") ["Dynamic"; "String"]) else ());
            !exe
          )
        )
      )
    )
  )
)

let findBuildMacroExprs = fun source -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let lex = HxLexer.create source in let t = ref (HxLexer.next lex ()) in (
    ignore (try while true do try ignore ((
      ignore (let _g = (!t).kind in match _g with
        | HxTokenKind.TEof -> raise (HxRuntime.Hx_return (Obj.repr out))
        | HxTokenKind.TKeyword _p0 -> ignore (let _g2 = _p0 in if (match _g2 with
          | HxKeyword.KPackage -> 0
          | HxKeyword.KImport -> 1
          | HxKeyword.KUsing -> 2
          | HxKeyword.KAs -> 3
          | HxKeyword.KClass -> 4
          | HxKeyword.KPublic -> 5
          | HxKeyword.KPrivate -> 6
          | HxKeyword.KStatic -> 7
          | HxKeyword.KFunction -> 8
          | HxKeyword.KReturn -> 9
          | HxKeyword.KIf -> 10
          | HxKeyword.KElse -> 11
          | HxKeyword.KSwitch -> 12
          | HxKeyword.KCase -> 13
          | HxKeyword.KDefault -> 14
          | HxKeyword.KTry -> 15
          | HxKeyword.KCatch -> 16
          | HxKeyword.KThrow -> 17
          | HxKeyword.KWhile -> 18
          | HxKeyword.KDo -> 19
          | HxKeyword.KFor -> 20
          | HxKeyword.KBreak -> 21
          | HxKeyword.KContinue -> 22
          | HxKeyword.KUntyped -> 23
          | HxKeyword.KCast -> 24
          | HxKeyword.KVar -> 25
          | HxKeyword.KFinal -> 26
          | HxKeyword.KNew -> 27
          | HxKeyword.KThis -> 28
          | HxKeyword.KSuper -> 29
          | HxKeyword.KTrue -> 30
          | HxKeyword.KFalse -> 31
          | HxKeyword.KNull -> 32) = 4 then raise (HxRuntime.Hx_return (Obj.repr out)) else ignore ())
        | HxTokenKind.TOther _p0 -> ignore (let _g2 = _p0 in let code = _g2 in if code = 64 then ignore (let t2 = HxLexer.next lex () in let t3 = HxLexer.next lex () in let t4 = HxLexer.next lex () in let tempBool = ref false in (
          ignore (let _g3 = t2.kind in let _g1 = t3.kind in let _g4 = t4.kind in if (match _g3 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 11 then if (match _g1 with
            | HxTokenKind.TEof -> 0
            | HxTokenKind.TIdent _ -> 1
            | HxTokenKind.TString _ -> 2
            | HxTokenKind.TInt _ -> 3
            | HxTokenKind.TFloat _ -> 4
            | HxTokenKind.TKeyword _ -> 5
            | HxTokenKind.TLBrace -> 6
            | HxTokenKind.TRBrace -> 7
            | HxTokenKind.TLParen -> 8
            | HxTokenKind.TRParen -> 9
            | HxTokenKind.TSemicolon -> 10
            | HxTokenKind.TColon -> 11
            | HxTokenKind.TDot -> 12
            | HxTokenKind.TComma -> 13
            | HxTokenKind.TOther _ -> 14) = 1 then let _g5 = match _g1 with
            | HxTokenKind.TIdent __enum_param_193 -> __enum_param_193
            | _ -> failwith "Unexpected enum parameter" in match _g5 with
            | "autoBuild" -> if (match _g4 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 8 then let __assign_195 = true in (
              tempBool := __assign_195;
              __assign_195
            ) else let __assign_196 = false in (
              tempBool := __assign_196;
              __assign_196
            )
            | "build" -> if (match _g4 with
              | HxTokenKind.TEof -> 0
              | HxTokenKind.TIdent _ -> 1
              | HxTokenKind.TString _ -> 2
              | HxTokenKind.TInt _ -> 3
              | HxTokenKind.TFloat _ -> 4
              | HxTokenKind.TKeyword _ -> 5
              | HxTokenKind.TLBrace -> 6
              | HxTokenKind.TRBrace -> 7
              | HxTokenKind.TLParen -> 8
              | HxTokenKind.TRParen -> 9
              | HxTokenKind.TSemicolon -> 10
              | HxTokenKind.TColon -> 11
              | HxTokenKind.TDot -> 12
              | HxTokenKind.TComma -> 13
              | HxTokenKind.TOther _ -> 14) = 8 then let __assign_197 = true in (
              tempBool := __assign_197;
              __assign_197
            ) else let __assign_198 = false in (
              tempBool := __assign_198;
              __assign_198
            )
            | _ -> let __assign_194 = false in (
              tempBool := __assign_194;
              __assign_194
            ) else let __assign_199 = false in (
            tempBool := __assign_199;
            __assign_199
          ) else let __assign_200 = false in (
            tempBool := __assign_200;
            __assign_200
          ));
          let isMeta = !tempBool in (
            ignore (if not (isMeta) then ignore ((
              ignore (let __assign_201 = HxLexer.next lex () in (
                t := __assign_201;
                __assign_201
              ));
              raise (HxRuntime.Hx_continue)
            )) else ());
            let startIndex = HxInt.add (HxPos.getIndex (t4.pos) ()) 1 in let depth = ref 1 in let endIndex = ref startIndex in let inner = ref (HxLexer.next lex ()) in (
              ignore (try while true do try ignore ((
                ignore (let _g3 = (!inner).kind in match _g3 with
                  | HxTokenKind.TEof -> ignore ((
                    ignore (let __assign_202 = HxString.length source in (
                      endIndex := __assign_202;
                      __assign_202
                    ));
                    raise (HxRuntime.Hx_break)
                  ))
                  | HxTokenKind.TLParen -> ignore (depth := HxInt.add (!depth) 1)
                  | HxTokenKind.TRParen -> ignore ((
                    ignore (depth := HxInt.sub (!depth) 1);
                    if !depth = 0 then ignore ((
                      ignore (let __assign_203 = HxPos.getIndex ((!inner).pos) () in (
                        endIndex := __assign_203;
                        __assign_203
                      ));
                      raise (HxRuntime.Hx_break)
                    )) else ()
                  ))
                  | _ -> ignore ());
                let __assign_204 = HxLexer.next lex () in (
                  inner := __assign_204;
                  __assign_204
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              let expr = trim (HxString.substring source startIndex (!endIndex)) in (
                ignore (if HxString.length expr > 0 then ignore (HxArray.push out expr) else ());
                ignore (let __assign_205 = HxLexer.next lex () in (
                  t := __assign_205;
                  __assign_205
                ));
                raise (HxRuntime.Hx_continue)
              )
            )
          )
        )) else ignore ())
        | _ -> ignore ());
      let __assign_206 = HxLexer.next lex () in (
        t := __assign_206;
        __assign_206
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    out
  )
) with
  | HxRuntime.Hx_return __ret_207 -> Obj.obj __ret_207

let parseGeneratedMembers = fun members -> try (
  ignore (if members == Obj.magic (HxRuntime.hx_null) || HxArray.length members = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_208 = HxAnon.create () in (
    ignore (HxAnon.set __anon_208 "functions" (Obj.repr (let __arr_209 = HxArray.create () in __arr_209)));
    ignore (HxAnon.set __anon_208 "fields" (Obj.repr (let __arr_210 = HxArray.create () in __arr_210)));
    __anon_208
  )))) else ());
  let combined = HxArray.join members "\n" (fun x -> x) in let fake = ("class __HxHxBuildFields {\n" ^ HxString.toStdString combined) ^ "\n}\n" in let p = HxParser.create fake in let decl = HxParser.parseModule p () in let cls = HxModuleDecl.getMainClass decl in let __anon_211 = HxAnon.create () in (
    ignore (HxAnon.set __anon_211 "functions" (Obj.repr (HxClassDecl.getFunctions cls)));
    ignore (HxAnon.set __anon_211 "fields" (Obj.repr (HxClassDecl.getFields cls)));
    __anon_211
  )
) with
  | HxRuntime.Hx_return __ret_212 -> Obj.obj __ret_212

let buildFieldsPayloadForParsed = fun pm -> let decl = ParsedModule.getDecl pm () in let cls = HxModuleDecl.getMainClass decl in let items = HxArray.create () in (
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
    ignore (let __old_213 = !_g in let __new_214 = HxInt.add __old_213 1 in (
      ignore (_g := __new_214);
      __new_214
    ));
    HxArray.push items (let __anon_215 = HxAnon.create () in (
      ignore (HxAnon.set __anon_215 "name" (Obj.repr (HxFunctionDecl.getName fn)));
      ignore (HxAnon.set __anon_215 "kind" (Obj.repr "fun"));
      ignore (HxAnon.set __anon_215 "isStatic" (Obj.repr (HxFunctionDecl.getIsStatic fn)));
      ignore (HxAnon.set __anon_215 "visibility" (Obj.repr (HxRuntime.dynamic_toStdString (Obj.repr (HxFunctionDecl.getVisibility fn)))));
      __anon_215
    ))
  )) done);
  ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
    ignore (let __old_216 = !_g in let __new_217 = HxInt.add __old_216 1 in (
      ignore (_g := __new_217);
      __new_217
    ));
    HxArray.push items (let __anon_218 = HxAnon.create () in (
      ignore (HxAnon.set __anon_218 "name" (Obj.repr (HxFieldDecl.getName f)));
      ignore (HxAnon.set __anon_218 "kind" (Obj.repr "var"));
      ignore (HxAnon.set __anon_218 "isStatic" (Obj.repr (HxFieldDecl.getIsStatic f)));
      ignore (HxAnon.set __anon_218 "visibility" (Obj.repr (HxRuntime.dynamic_toStdString (Obj.repr (HxFieldDecl.getVisibility f)))));
      __anon_218
    ))
  )) done);
  let parts = HxArray.create () in (
    ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen "c" (string_of_int (HxArray.length items))));
    ignore (let _g = ref 0 in let _g1 = HxArray.length items in while !_g < _g1 do ignore (let i = let __old_219 = !_g in let __new_220 = HxInt.add __old_219 1 in (
      ignore (_g := __new_220);
      __old_219
    ) in let it = HxArray.get items i in (
      ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("n" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "name")))));
      ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("k" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "kind")))));
      let tempString = ref "" in (
        ignore (if HxRuntime.dynamic_equals (Obj.obj (HxAnon.get (Obj.repr it) "isStatic")) (HxRuntime.box_bool true) then let __assign_221 = "1" in (
          tempString := __assign_221;
          __assign_221
        ) else let __assign_222 = "0" in (
          tempString := __assign_222;
          __assign_222
        ));
        ignore (HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("s" ^ string_of_int i) (!tempString)));
        HxArray.push parts (Hxhx_macro_MacroProtocol.encodeLen ("v" ^ string_of_int i) (HxRuntime.dynamic_toStdString (Obj.obj (HxAnon.get (Obj.repr it) "visibility"))))
      )
    )) done);
    HxArray.join parts " " (fun x -> x)
  )
)

let run = fun args -> try let outDir = ref "" in let typeOnly = ref false in let emitFullBodies = ref false in let noEmit = ref false in let rest = HxArray.create () in let i = ref 0 in (
  ignore (while !i < HxArray.length args do ignore (let a = HxArray.get args (!i) in match a with
    | "--hxhx-emit-full-bodies" -> ignore ((
      ignore (let __assign_223 = true in (
        emitFullBodies := __assign_223;
        __assign_223
      ));
      i := HxInt.add (!i) 1
    ))
    | "--hxhx-no-emit" -> ignore ((
      ignore (let __assign_224 = true in (
        noEmit := __assign_224;
        __assign_224
      ));
      i := HxInt.add (!i) 1
    ))
    | "--hxhx-out" -> ignore ((
      ignore (if HxInt.add (!i) 1 >= HxArray.length args then raise (HxRuntime.Hx_return (Obj.repr (error "missing value after --hxhx-out"))) else ());
      ignore (let __assign_225 = HxArray.get args (HxInt.add (!i) 1) in (
        outDir := __assign_225;
        __assign_225
      ));
      i := HxInt.add (!i) 2
    ))
    | "--hxhx-type-only" -> ignore ((
      ignore (let __assign_226 = true in (
        typeOnly := __assign_226;
        __assign_226
      ));
      i := HxInt.add (!i) 1
    ))
    | _ -> ignore ((
      ignore (HxArray.push rest a);
      i := HxInt.add (!i) 1
    ))) done);
  let parsed = Hxhx_Stage1Compiler.stage1args_parse rest true in (
    ignore (if parsed == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr 2)) else ());
    ignore (if parsed.main == Obj.magic (HxRuntime.hx_null) || HxString.length (parsed.main) = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "missing -main <TypeName>"))) else ());
    ignore (if !typeOnly && HxArray.length (parsed.macros) > 0 then ignore (let _g = ref 0 in let _g1 = HxArray.length (parsed.macros) in while !_g < _g1 do ignore (let i2 = let __old_227 = !_g in let __new_228 = HxInt.add __old_227 1 in (
      ignore (_g := __new_228);
      __old_227
    ) in print_endline ((("macro_skipped[" ^ string_of_int i2) ^ "]=") ^ HxString.toStdString (HxArray.get (parsed.macros) i2))) done) else ());
    let exprMacros = parseDelimitedList (HxSys.getEnv "HXHX_EXPR_MACROS") in let macroSession = ref (Obj.magic (HxRuntime.hx_null)) in let tempString = ref "" in (
      ignore (try let __assign_229 = HxSys.getCwd () in (
        tempString := __assign_229;
        __assign_229
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_230 -> raise (HxRuntime.Hx_return __ret_230)
        | HxRuntime.Hx_exception (__exn_v_231, __exn_tags_232) -> if true then let _hx = (__exn_v_231 : Obj.t) in (
          ignore _hx;
          let __assign_233 = "." in (
            tempString := __assign_233;
            __assign_233
          )
        ) else HxRuntime.hx_throw_typed __exn_v_231 __exn_tags_232
        | __exn_234 -> if true then let _hx = (Obj.repr __exn_234 : Obj.t) in (
          ignore _hx;
          let __assign_235 = "." in (
            tempString := __assign_235;
            __assign_235
          )
        ) else raise (__exn_234));
      let cwd = absFromCwd (!tempString) (parsed.cwd) in (
        ignore (if not (HxFileSystem.exists cwd) || not (HxFileSystem.isDirectory cwd) then raise (HxRuntime.Hx_return (Obj.repr (error ("cwd is not a directory: " ^ HxString.toStdString cwd)))) else ());
        let tempString1 = ref "" in (
          ignore (if HxString.length (!outDir) > 0 then let __assign_236 = !outDir in (
            tempString1 := __assign_236;
            __assign_236
          ) else let __assign_237 = "out_stage3" in (
            tempString1 := __assign_237;
            __assign_237
          ));
          let outAbs = absFromCwd cwd (!tempString1) in (
            ignore (Hxhx_macro_MacroState.reset ());
            let tempArray = ref (Obj.magic ()) in (
              ignore (let seen = HxMap.create_string () in let out = HxArray.create () in (
                ignore (let _g = ref 0 in let _g1 = parsed.libs in while !_g < HxArray.length _g1 do ignore (let lib = HxArray.get _g1 (!_g) in (
                  ignore (let __old_238 = !_g in let __new_239 = HxInt.add __old_238 1 in (
                    ignore (_g := __new_239);
                    __new_239
                  ));
                  HxArray.push out (resolveHaxelibSpec lib cwd seen 0)
                )) done);
                let __assign_240 = out in (
                  tempArray := __assign_240;
                  __assign_240
                )
              ));
              let tempArray1 = ref (Obj.magic ()) in (
                ignore (let out = HxArray.create () in (
                  ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                    ignore (let __old_241 = !_g in let __new_242 = HxInt.add __old_241 1 in (
                      ignore (_g := __new_242);
                      __new_242
                    ));
                    let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "defines") in while !_g2 < HxArray.length _g1 do ignore (let d = HxArray.get _g1 (!_g2) in (
                      ignore (let __old_243 = !_g2 in let __new_244 = HxInt.add __old_243 1 in (
                        ignore (_g2 := __new_244);
                        __new_244
                      ));
                      if HxArray.indexOf out d 0 = -1 then ignore (HxArray.push out d) else ()
                    )) done
                  )) done);
                  let __assign_245 = out in (
                    tempArray1 := __assign_245;
                    __assign_245
                  )
                ));
                let allDefines = HxArray.concat (parsed.defines) (!tempArray1) in (
                  ignore (Hxhx_macro_MacroState.seedFromCliDefines allDefines);
                  ignore (Hxhx_macro_MacroState.setGeneratedHxDir (Haxe_io_Path.join (let __arr_246 = HxArray.create () in (
                    ignore (HxArray.push __arr_246 outAbs);
                    ignore (HxArray.push __arr_246 "_gen_hx");
                    __arr_246
                  ))));
                  let tempArray2 = ref (Obj.magic ()) in (
                    ignore (let out = HxArray.create () in (
                      ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                        ignore (let __old_247 = !_g in let __new_248 = HxInt.add __old_247 1 in (
                          ignore (_g := __new_248);
                          __new_248
                        ));
                        let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "macros") in while !_g2 < HxArray.length _g1 do ignore (let m = HxArray.get _g1 (!_g2) in (
                          ignore (let __old_249 = !_g2 in let __new_250 = HxInt.add __old_249 1 in (
                            ignore (_g2 := __new_250);
                            __new_250
                          ));
                          if HxArray.indexOf out m 0 = -1 then ignore (HxArray.push out m) else ()
                        )) done
                      )) done);
                      let __assign_251 = out in (
                        tempArray2 := __assign_251;
                        __assign_251
                      )
                    ));
                    let runHaxelibMacros = isTrueEnv "HXHX_RUN_HAXELIB_MACROS" in let tempArray3 = ref (Obj.magic ()) in (
                      ignore (let tempArray4 = ref (Obj.magic ()) in (
                        ignore (let _this = parsed.classPaths in let _g = let __arr_252 = HxArray.create () in __arr_252 in (
                          ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                            ignore (let __old_253 = !_g1 in let __new_254 = HxInt.add __old_253 1 in (
                              ignore (_g1 := __new_254);
                              __new_254
                            ));
                            HxArray.push _g (absFromCwd cwd v)
                          )) done);
                          let __assign_255 = _g in (
                            tempArray4 := __assign_255;
                            __assign_255
                          )
                        ));
                        let libs = HxArray.create () in (
                          ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                            ignore (let __old_256 = !_g in let __new_257 = HxInt.add __old_256 1 in (
                              ignore (_g := __new_257);
                              __new_257
                            ));
                            let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "classPaths") in while !_g2 < HxArray.length _g1 do ignore (let p = HxArray.get _g1 (!_g2) in (
                              ignore (let __old_258 = !_g2 in let __new_259 = HxInt.add __old_258 1 in (
                                ignore (_g2 := __new_259);
                                __new_259
                              ));
                              HxArray.push libs (absFromCwd cwd p)
                            )) done
                          )) done);
                          let outAll = HxArray.concat (!tempArray4) libs in let stdCp = trim (HxSys.getEnv "HAXE_STD_PATH") in if HxString.length stdCp > 0 then let stdAbs = Haxe_io_Path.normalize stdCp in let filtered = HxArray.create () in (
                            ignore (let _g = ref 0 in while !_g < HxArray.length outAll do ignore (let cp = HxArray.get outAll (!_g) in (
                              ignore (let __old_260 = !_g in let __new_261 = HxInt.add __old_260 1 in (
                                ignore (_g := __new_261);
                                __new_261
                              ));
                              if not (HxString.equals (Haxe_io_Path.normalize cp) stdAbs) then ignore (HxArray.push filtered cp) else ()
                            )) done);
                            let __assign_262 = filtered in (
                              tempArray3 := __assign_262;
                              __assign_262
                            )
                          ) else let __assign_263 = outAll in (
                            tempArray3 := __assign_263;
                            __assign_263
                          )
                        )
                      ));
                      ignore (if not (!typeOnly) && (HxArray.length (parsed.macros) > 0 || HxArray.length exprMacros > 0 || runHaxelibMacros && HxArray.length (!tempArray2) > 0) then ignore ((
                        ignore (if HxString.length (Hxhx_macro_MacroHostClient.resolveMacroHostExePath ()) = 0 && shouldAutoBuildMacroHost () then ignore (let repoRoot = inferRepoRootForScripts () in (
                          ignore (if HxString.length repoRoot = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "macro host auto-build enabled, but repo root could not be inferred (set HXHX_REPO_ROOT)"))) else ());
                          try let entrypoints = HxArray.create () in (
                            ignore (if runHaxelibMacros then ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray2) do ignore (let e = HxArray.get (!tempArray2) (!_g) in (
                              ignore (let __old_264 = !_g in let __new_265 = HxInt.add __old_264 1 in (
                                ignore (_g := __new_265);
                                __new_265
                              ));
                              if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                            )) done) else ());
                            ignore (if anyNonBuiltinMacro (parsed.macros) then ignore (let _g = ref 0 in let _g1 = parsed.macros in while !_g < HxArray.length _g1 do ignore (let e = HxArray.get _g1 (!_g) in (
                              ignore (let __old_266 = !_g in let __new_267 = HxInt.add __old_266 1 in (
                                ignore (_g := __new_267);
                                __new_267
                              ));
                              if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                            )) done) else ());
                            ignore (let _g = ref 0 in while !_g < HxArray.length exprMacros do ignore (let e = HxArray.get exprMacros (!_g) in (
                              ignore (let __old_268 = !_g in let __new_269 = HxInt.add __old_268 1 in (
                                ignore (_g := __new_269);
                                __new_269
                              ));
                              if HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                            )) done);
                            let exe = buildMacroHostExe repoRoot (!tempArray3) entrypoints in HxSys.putEnv "HXHX_MACRO_HOST_EXE" (Some exe)
                          ) with
                            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                            | HxRuntime.Hx_return __ret_270 -> raise (HxRuntime.Hx_return __ret_270)
                            | HxRuntime.Hx_exception (__exn_v_271, __exn_tags_272) -> if true then let e = (__exn_v_271 : Obj.t) in (
                              ignore e;
                              raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                            ) else HxRuntime.hx_throw_typed __exn_v_271 __exn_tags_272
                            | __exn_273 -> if true then let e = (Obj.repr __exn_273 : Obj.t) in (
                              ignore e;
                              raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                            ) else raise (__exn_273)
                        )) else ());
                        ignore (try (
                          ignore (let __assign_274 = Hxhx_macro_MacroHostClient.openSession () in (
                            macroSession := __assign_274;
                            __assign_274
                          ));
                          ignore (if runHaxelibMacros then ignore (let _g = ref 0 in let _g1 = HxArray.length (!tempArray2) in while !_g < _g1 do ignore (let i2 = let __old_275 = !_g in let __new_276 = HxInt.add __old_275 1 in (
                            ignore (_g := __new_276);
                            __old_275
                          ) in print_endline ((("lib_macro_run[" ^ string_of_int i2) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) (HxArray.get (!tempArray2) i2)))) done) else ());
                          let _g = ref 0 in let _g1 = HxArray.length (parsed.macros) in while !_g < _g1 do ignore (let i2 = let __old_277 = !_g in let __new_278 = HxInt.add __old_277 1 in (
                            ignore (_g := __new_278);
                            __old_277
                          ) in print_endline ((("macro_run[" ^ string_of_int i2) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) (HxArray.get (parsed.macros) i2)))) done
                        ) with
                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                          | HxRuntime.Hx_return __ret_279 -> raise (HxRuntime.Hx_return __ret_279)
                          | HxRuntime.Hx_exception (__exn_v_280, __exn_tags_281) -> if true then let e = (__exn_v_280 : Obj.t) in (
                            ignore e;
                            (
                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                let __assign_282 = Obj.magic (HxRuntime.hx_null) in (
                                  macroSession := __assign_282;
                                  __assign_282
                                )
                              )) else ());
                              raise (HxRuntime.Hx_return (Obj.repr (error ("macro failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                            )
                          ) else HxRuntime.hx_throw_typed __exn_v_280 __exn_tags_281
                          | __exn_283 -> if true then let e = (Obj.repr __exn_283 : Obj.t) in (
                            ignore e;
                            (
                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                let __assign_284 = Obj.magic (HxRuntime.hx_null) in (
                                  macroSession := __assign_284;
                                  __assign_284
                                )
                              )) else ());
                              raise (HxRuntime.Hx_return (Obj.repr (error ("macro failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                            )
                          ) else raise (__exn_283));
                        let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                          ignore (let __old_285 = !_g in let __new_286 = HxInt.add __old_285 1 in (
                            ignore (_g := __new_286);
                            __new_286
                          ));
                          if StringTools.startsWith name "HXHX_" then ignore (print_endline ((("macro_define[" ^ HxString.toStdString name) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroState.definedValue name))) else ()
                        )) done
                      )) else ());
                      let tempArray5 = ref (Obj.magic ()) in (
                        ignore (let tempArray6 = ref (Obj.magic ()) in (
                          ignore (let _this = parsed.classPaths in let _g = let __arr_287 = HxArray.create () in __arr_287 in (
                            ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                              ignore (let __old_288 = !_g1 in let __new_289 = HxInt.add __old_288 1 in (
                                ignore (_g1 := __new_289);
                                __new_289
                              ));
                              HxArray.push _g (absFromCwd cwd v)
                            )) done);
                            let __assign_290 = _g in (
                              tempArray6 := __assign_290;
                              __assign_290
                            )
                          ));
                          let libs = HxArray.create () in (
                            ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray) do ignore (let s = HxArray.get (!tempArray) (!_g) in (
                              ignore (let __old_291 = !_g in let __new_292 = HxInt.add __old_291 1 in (
                                ignore (_g := __new_292);
                                __new_292
                              ));
                              let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get s "classPaths") in while !_g2 < HxArray.length _g1 do ignore (let p = HxArray.get _g1 (!_g2) in (
                                ignore (let __old_293 = !_g2 in let __new_294 = HxInt.add __old_293 1 in (
                                  ignore (_g2 := __new_294);
                                  __new_294
                                ));
                                HxArray.push libs (absFromCwd cwd p)
                              )) done
                            )) done);
                            let tempArray7 = ref (Obj.magic ()) in (
                              ignore (let _this = Hxhx_macro_MacroState.listClassPaths () in let _g = let __arr_295 = HxArray.create () in __arr_295 in (
                                ignore (let _g1 = ref 0 in while !_g1 < HxArray.length _this do ignore (let v = HxArray.get _this (!_g1) in (
                                  ignore (let __old_296 = !_g1 in let __new_297 = HxInt.add __old_296 1 in (
                                    ignore (_g1 := __new_297);
                                    __new_297
                                  ));
                                  HxArray.push _g (absFromCwd cwd v)
                                )) done);
                                let __assign_298 = _g in (
                                  tempArray7 := __assign_298;
                                  __assign_298
                                )
                              ));
                              let out = HxArray.concat (HxArray.concat (!tempArray6) libs) (!tempArray7) in (
                                ignore (if Hxhx_macro_MacroState.hasGeneratedHxModules () then ignore (HxArray.push out (Hxhx_macro_MacroState.getGeneratedHxDir ())) else ());
                                let __assign_299 = out in (
                                  tempArray5 := __assign_299;
                                  __assign_299
                                )
                              )
                            )
                          )
                        ));
                        let definesMap = HxDefineMap.fromRawDefines allDefines in (
                          ignore (HxMap.set_string definesMap "sys" "1");
                          ignore (HxMap.set_string definesMap "ocaml" "1");
                          ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let n = HxArray.get _g1 (!_g) in (
                            ignore (let __old_300 = !_g in let __new_301 = HxInt.add __old_300 1 in (
                              ignore (_g := __new_301);
                              __new_301
                            ));
                            HxMap.set_string definesMap n (Hxhx_macro_MacroState.definedValue n)
                          )) done);
                          let roots = HxArray.concat (let __arr_302 = HxArray.create () in (
                            ignore (HxArray.push __arr_302 (parsed.main));
                            __arr_302
                          )) (Hxhx_macro_MacroState.listIncludedModules ()) in let tempArray8 = ref (Obj.magic ()) in (
                            ignore (try let __assign_303 = ResolverStage.parseProjectRoots (!tempArray5) roots definesMap in (
                              tempArray8 := __assign_303;
                              __assign_303
                            ) with
                              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                              | HxRuntime.Hx_return __ret_304 -> raise (HxRuntime.Hx_return __ret_304)
                              | HxRuntime.Hx_exception (__exn_v_305, __exn_tags_306) -> if true then let e = (__exn_v_305 : Obj.t) in (
                                ignore e;
                                (
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_307 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_307;
                                      __assign_307
                                    )
                                  )) else ());
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("resolve failed: " ^ HxString.toStdString (formatException e)))))
                                )
                              ) else HxRuntime.hx_throw_typed __exn_v_305 __exn_tags_306
                              | __exn_308 -> if true then let e = (Obj.repr __exn_308 : Obj.t) in (
                                ignore e;
                                (
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_309 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_309;
                                      __assign_309
                                    )
                                  )) else ());
                                  raise (HxRuntime.Hx_return (Obj.repr (error ("resolve failed: " ^ HxString.toStdString (formatException e)))))
                                )
                              ) else raise (__exn_308));
                            ignore (if HxArray.length (!tempArray8) = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "resolver returned an empty module graph"))) else ());
                            ignore (print_endline ("resolved_modules=" ^ string_of_int (HxArray.length (!tempArray8))));
                            let anyBuildMacros = ref false in let buildExprsAll = HxArray.create () in (
                              ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                ignore (let __old_310 = !_g in let __new_311 = HxInt.add __old_310 1 in (
                                  ignore (_g := __new_311);
                                  __new_311
                                ));
                                let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in if HxArray.length exprs > 0 then ignore ((
                                  ignore (let __assign_312 = true in (
                                    anyBuildMacros := __assign_312;
                                    __assign_312
                                  ));
                                  let _g2 = ref 0 in while !_g2 < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g2) in (
                                    ignore (let __old_313 = !_g2 in let __new_314 = HxInt.add __old_313 1 in (
                                      ignore (_g2 := __new_314);
                                      __new_314
                                    ));
                                    HxArray.push buildExprsAll e
                                  )) done
                                )) else ()
                              )) done);
                              ignore (if not (!typeOnly) && !anyBuildMacros then ignore ((
                                ignore (if !macroSession == Obj.magic (HxRuntime.hx_null) then ignore ((
                                  ignore (if HxString.length (Hxhx_macro_MacroHostClient.resolveMacroHostExePath ()) = 0 && shouldAutoBuildMacroHost () then ignore (let repoRoot = inferRepoRootForScripts () in (
                                    ignore (if HxString.length repoRoot = 0 then raise (HxRuntime.Hx_return (Obj.repr (error "macro host auto-build enabled, but repo root could not be inferred (set HXHX_REPO_ROOT)"))) else ());
                                    try let entrypoints = HxArray.create () in (
                                      ignore (let _g = ref 0 in while !_g < HxArray.length buildExprsAll do ignore (let e = HxArray.get buildExprsAll (!_g) in (
                                        ignore (let __old_315 = !_g in let __new_316 = HxInt.add __old_315 1 in (
                                          ignore (_g := __new_316);
                                          __new_316
                                        ));
                                        if not (isBuiltinMacroExpr e) && HxArray.indexOf entrypoints e 0 = -1 then ignore (HxArray.push entrypoints e) else ()
                                      )) done);
                                      let exe = buildMacroHostExe repoRoot (!tempArray3) entrypoints in HxSys.putEnv "HXHX_MACRO_HOST_EXE" (Some exe)
                                    ) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_317 -> raise (HxRuntime.Hx_return __ret_317)
                                      | HxRuntime.Hx_exception (__exn_v_318, __exn_tags_319) -> if true then let e = (__exn_v_318 : Obj.t) in (
                                        ignore e;
                                        raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed (build macros): " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                      ) else HxRuntime.hx_throw_typed __exn_v_318 __exn_tags_319
                                      | __exn_320 -> if true then let e = (Obj.repr __exn_320 : Obj.t) in (
                                        ignore e;
                                        raise (HxRuntime.Hx_return (Obj.repr (error ("macro host auto-build failed (build macros): " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                      ) else raise (__exn_320)
                                  )) else ());
                                  try let __assign_321 = Hxhx_macro_MacroHostClient.openSession () in (
                                    macroSession := __assign_321;
                                    __assign_321
                                  ) with
                                    | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                    | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                    | HxRuntime.Hx_return __ret_322 -> raise (HxRuntime.Hx_return __ret_322)
                                    | HxRuntime.Hx_exception (__exn_v_323, __exn_tags_324) -> if true then let e = (__exn_v_323 : Obj.t) in (
                                      ignore e;
                                      (
                                        ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                          ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                          let __assign_325 = Obj.magic (HxRuntime.hx_null) in (
                                            macroSession := __assign_325;
                                            __assign_325
                                          )
                                        )) else ());
                                        raise (HxRuntime.Hx_return (Obj.repr (error ("macro host required for @:build, but could not be started: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                      )
                                    ) else HxRuntime.hx_throw_typed __exn_v_323 __exn_tags_324
                                    | __exn_326 -> if true then let e = (Obj.repr __exn_326 : Obj.t) in (
                                      ignore e;
                                      (
                                        ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                          ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                          let __assign_327 = Obj.magic (HxRuntime.hx_null) in (
                                            macroSession := __assign_327;
                                            __assign_327
                                          )
                                        )) else ());
                                        raise (HxRuntime.Hx_return (Obj.repr (error ("macro host required for @:build, but could not be started: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                      )
                                    ) else raise (__exn_326)
                                )) else ());
                                let out2 = HxArray.create () in (
                                  ignore (let _g = ref 0 in try while !_g < HxArray.length (!tempArray8) do try ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                    ignore (let __old_328 = !_g in let __new_329 = HxInt.add __old_328 1 in (
                                      ignore (_g := __new_329);
                                      __new_329
                                    ));
                                    let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in (
                                      ignore (if HxArray.length exprs = 0 then ignore ((
                                        ignore (HxArray.push out2 m);
                                        raise (HxRuntime.Hx_continue)
                                      )) else ());
                                      let modulePath = ResolvedModule.getModulePath m in (
                                        ignore (Hxhx_macro_MacroState.clearBuildFields modulePath);
                                        ignore (Hxhx_macro_MacroState.setDefine "HXHX_BUILD_MODULE" modulePath);
                                        ignore (Hxhx_macro_MacroState.setDefine "HXHX_BUILD_FILE" (ResolvedModule.getFilePath m));
                                        ignore (Hxhx_macro_MacroState.setBuildFieldsPayload (buildFieldsPayloadForParsed pm));
                                        ignore (let _g2 = ref 0 in let _g1 = HxArray.length exprs in while !_g2 < _g1 do ignore (let i2 = let __old_330 = !_g2 in let __new_331 = HxInt.add __old_330 1 in (
                                          ignore (_g2 := __new_331);
                                          __old_330
                                        ) in let expr = HxArray.get exprs i2 in (
                                          ignore (print_endline ((((("build_macro[" ^ HxString.toStdString modulePath) ^ "][") ^ string_of_int i2) ^ "]=") ^ HxString.toStdString expr));
                                          try print_endline ((((("build_macro_run[" ^ HxString.toStdString modulePath) ^ "][") ^ string_of_int i2) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroHostClient.macrohostsession_run (!macroSession) expr)) with
                                            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                            | HxRuntime.Hx_return __ret_332 -> raise (HxRuntime.Hx_return __ret_332)
                                            | HxRuntime.Hx_exception (__exn_v_333, __exn_tags_334) -> if true then let e = (__exn_v_333 : Obj.t) in (
                                              ignore e;
                                              (
                                                ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                  ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                  let __assign_335 = Obj.magic (HxRuntime.hx_null) in (
                                                    macroSession := __assign_335;
                                                    __assign_335
                                                  )
                                                )) else ());
                                                raise (HxRuntime.Hx_return (Obj.repr (error ((("build macro failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                              )
                                            ) else HxRuntime.hx_throw_typed __exn_v_333 __exn_tags_334
                                            | __exn_336 -> if true then let e = (Obj.repr __exn_336 : Obj.t) in (
                                              ignore e;
                                              (
                                                ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                  ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                  let __assign_337 = Obj.magic (HxRuntime.hx_null) in (
                                                    macroSession := __assign_337;
                                                    __assign_337
                                                  )
                                                )) else ());
                                                raise (HxRuntime.Hx_return (Obj.repr (error ((("build macro failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                              )
                                            ) else raise (__exn_336)
                                        )) done);
                                        let snippets = Hxhx_macro_MacroState.listBuildFields modulePath in (
                                          ignore (print_endline ((("build_fields[" ^ HxString.toStdString modulePath) ^ "]=") ^ string_of_int (HxArray.length snippets)));
                                          ignore (if HxArray.length snippets = 0 then ignore ((
                                            ignore (HxArray.push out2 m);
                                            raise (HxRuntime.Hx_continue)
                                          )) else ());
                                          let tempStruct = ref (Obj.magic ()) in (
                                            ignore (try let __assign_338 = parseGeneratedMembers snippets in (
                                              tempStruct := __assign_338;
                                              __assign_338
                                            ) with
                                              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                              | HxRuntime.Hx_return __ret_339 -> raise (HxRuntime.Hx_return __ret_339)
                                              | HxRuntime.Hx_exception (__exn_v_340, __exn_tags_341) -> if true then let e = (__exn_v_340 : Obj.t) in (
                                                ignore e;
                                                (
                                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                    let __assign_342 = Obj.magic (HxRuntime.hx_null) in (
                                                      macroSession := __assign_342;
                                                      __assign_342
                                                    )
                                                  )) else ());
                                                  raise (HxRuntime.Hx_return (Obj.repr (error ((("build fields parse failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                )
                                              ) else HxRuntime.hx_throw_typed __exn_v_340 __exn_tags_341
                                              | __exn_343 -> if true then let e = (Obj.repr __exn_343 : Obj.t) in (
                                                ignore e;
                                                (
                                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                    let __assign_344 = Obj.magic (HxRuntime.hx_null) in (
                                                      macroSession := __assign_344;
                                                      __assign_344
                                                    )
                                                  )) else ());
                                                  raise (HxRuntime.Hx_return (Obj.repr (error ((("build fields parse failed: " ^ HxString.toStdString modulePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                                )
                                              ) else raise (__exn_343));
                                            let gen = !tempStruct in let oldDecl = ParsedModule.getDecl pm () in let oldCls = HxModuleDecl.getMainClass oldDecl in let genFnKeys = HxMap.create_string () in (
                                              ignore (let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get gen "functions") in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                ignore (let __old_345 = !_g2 in let __new_346 = HxInt.add __old_345 1 in (
                                                  ignore (_g2 := __new_346);
                                                  __new_346
                                                ));
                                                let key = HxFunctionDecl.getName fn in HxMap.set_string genFnKeys key true
                                              )) done);
                                              let genFieldKeys = HxMap.create_string () in (
                                                ignore (let _g2 = ref 0 in let _g1 = Obj.obj (HxAnon.get gen "fields") in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
                                                  ignore (let __old_347 = !_g2 in let __new_348 = HxInt.add __old_347 1 in (
                                                    ignore (_g2 := __new_348);
                                                    __new_348
                                                  ));
                                                  let key = HxFieldDecl.getName f in HxMap.set_string genFieldKeys key true
                                                )) done);
                                                let keptFns = HxArray.create () in (
                                                  ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions oldCls in while !_g2 < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                    ignore (let __old_349 = !_g2 in let __new_350 = HxInt.add __old_349 1 in (
                                                      ignore (_g2 := __new_350);
                                                      __new_350
                                                    ));
                                                    let tempBool = ref false in (
                                                      ignore (let key = HxFunctionDecl.getName fn in let __assign_351 = HxMap.exists_string genFnKeys key in (
                                                        tempBool := __assign_351;
                                                        __assign_351
                                                      ));
                                                      if not (!tempBool) then ignore (HxArray.push keptFns fn) else ()
                                                    )
                                                  )) done);
                                                  let mergedFns = HxArray.concat keptFns (Obj.obj (HxAnon.get gen "functions")) in let keptFields = HxArray.create () in (
                                                    ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFields oldCls in while !_g2 < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g2) in (
                                                      ignore (let __old_352 = !_g2 in let __new_353 = HxInt.add __old_352 1 in (
                                                        ignore (_g2 := __new_353);
                                                        __new_353
                                                      ));
                                                      let tempBool1 = ref false in (
                                                        ignore (let key = HxFieldDecl.getName f in let __assign_354 = HxMap.exists_string genFieldKeys key in (
                                                          tempBool1 := __assign_354;
                                                          __assign_354
                                                        ));
                                                        if not (!tempBool1) then ignore (HxArray.push keptFields f) else ()
                                                      )
                                                    )) done);
                                                    let mergedFields = HxArray.concat keptFields (Obj.obj (HxAnon.get gen "fields")) in let newCls = HxClassDecl.create (HxClassDecl.getName oldCls) (HxClassDecl.getHasStaticMain oldCls) mergedFns mergedFields in let newDecl = HxModuleDecl.create (HxModuleDecl.getPackagePath oldDecl) (HxModuleDecl.getImports oldDecl) newCls (HxModuleDecl.getHeaderOnly oldDecl) (HxModuleDecl.getHasToplevelMain oldDecl) in let newParsed = ParsedModule.create (ParsedModule.getSource pm ()) newDecl (ParsedModule.getFilePath pm ()) in HxArray.push out2 (ResolvedModule.create modulePath (ResolvedModule.getFilePath m) newParsed)
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )) with
                                    | HxRuntime.Hx_continue -> () done with
                                    | HxRuntime.Hx_break -> ());
                                  let __assign_355 = out2 in (
                                    tempArray8 := __assign_355;
                                    __assign_355
                                  )
                                )
                              )) else ignore (if !typeOnly && !anyBuildMacros then ignore (let i2 = ref 0 in let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                ignore (let __old_356 = !_g in let __new_357 = HxInt.add __old_356 1 in (
                                  ignore (_g := __new_357);
                                  __new_357
                                ));
                                let pm = ResolvedModule.getParsed m in let exprs = findBuildMacroExprs (ParsedModule.getSource pm ()) in let _g2 = ref 0 in while !_g2 < HxArray.length exprs do ignore (let e = HxArray.get exprs (!_g2) in (
                                  ignore (let __old_358 = !_g2 in let __new_359 = HxInt.add __old_358 1 in (
                                    ignore (_g2 := __new_359);
                                    __new_359
                                  ));
                                  ignore (print_endline ((((("build_macro_skipped[" ^ string_of_int (!i2)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getModulePath m)) ^ ":") ^ HxString.toStdString e));
                                  i2 := HxInt.add (!i2) 1
                                )) done
                              )) done) else ()));
                              ignore (if not (!typeOnly) && HxArray.length exprMacros > 0 then ignore ((
                                ignore (if !macroSession == Obj.magic (HxRuntime.hx_null) then ignore ((
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_360 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_360;
                                      __assign_360
                                    )
                                  )) else ());
                                  raise (HxRuntime.Hx_return (Obj.repr (error "expression macro expansion requested (HXHX_EXPR_MACROS), but no macro host session is available")))
                                )) else ());
                                let exp = Hxhx_ExprMacroExpander.expandResolvedModules (!tempArray8) (!macroSession) exprMacros in (
                                  ignore (let __assign_361 = Obj.obj (HxAnon.get exp "modules") in (
                                    tempArray8 := __assign_361;
                                    __assign_361
                                  ));
                                  print_endline ("expr_macros_expanded=" ^ string_of_int (Obj.obj (HxAnon.get exp "expandedCount")))
                                )
                              )) else ());
                              let typerIndex = TyperIndex.build (!tempArray8) in let moduleLoader = ModuleLoader.create (!tempArray5) definesMap typerIndex in (
                                ignore (moduleLoader.markResolvedAlready (Obj.magic moduleLoader) (!tempArray8));
                                ignore (if !typeOnly then ignore (let typedCount = ref 0 in let headerOnlyCount = ref 0 in let parsedMethodsTotal = ref 0 in let unsupportedExprsTotal = ref 0 in let unsupportedFilesCount = ref 0 in let traceUnsupported = isTrueEnv "HXHX_TRACE_UNSUPPORTED" in let unsupportedRawCount = ref 0 in let unsupportedFnCount = ref 0 in let rootFilePath = ResolvedModule.getFilePath (HxArray.get (!tempArray8) 0) in let rootTyped = ref (Obj.magic (HxRuntime.hx_null)) in let toType = HxArray.copy (!tempArray8) in let cursor = ref 0 in (
                                  ignore (while !cursor < HxArray.length toType do ignore (let m = HxArray.get toType (!cursor) in (
                                    ignore (cursor := HxInt.add (!cursor) 1);
                                    ignore (try let pm = ResolvedModule.getParsed m in let unsupportedInFile = countUnsupportedExprsInModule pm in (
                                      ignore (unsupportedExprsTotal := HxInt.add (!unsupportedExprsTotal) unsupportedInFile);
                                      ignore (if unsupportedInFile > 0 then ignore ((
                                        ignore (print_endline ((((((("unsupported_file[" ^ string_of_int (!unsupportedFilesCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ " header_only=") ^ HxString.toStdString (bool01 (HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ())))) ^ " unsupported_exprs=") ^ string_of_int unsupportedInFile));
                                        ignore (if traceUnsupported then ignore (let cls = HxModuleDecl.getMainClass (ParsedModule.getDecl pm ()) in (
                                          ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in try while !_g < HxArray.length _g1 do try ignore (let fn = HxArray.get _g1 (!_g) in (
                                            ignore (let __old_362 = !_g in let __new_363 = HxInt.add __old_362 1 in (
                                              ignore (_g := __new_363);
                                              __new_363
                                            ));
                                            let fnUnsupported = countUnsupportedExprsInFunction fn in (
                                              ignore (if fnUnsupported <= 0 then raise (HxRuntime.Hx_continue) else ());
                                              ignore (print_endline ((((((("unsupported_fn[" ^ string_of_int (!unsupportedFnCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":") ^ HxString.toStdString (HxFunctionDecl.getName fn)) ^ " unsupported_exprs=") ^ string_of_int fnUnsupported));
                                              ignore (unsupportedFnCount := HxInt.add (!unsupportedFnCount) 1);
                                              if !unsupportedFnCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                            )
                                          )) with
                                            | HxRuntime.Hx_continue -> () done with
                                            | HxRuntime.Hx_break -> ());
                                          let _g = ref 0 in let _g1 = collectUnsupportedExprRawInModule pm 20 in try while !_g < HxArray.length _g1 do try ignore (let raw = HxArray.get _g1 (!_g) in (
                                            ignore (let __old_364 = !_g in let __new_365 = HxInt.add __old_364 1 in (
                                              ignore (_g := __new_365);
                                              __new_365
                                            ));
                                            let escaped = escapeOneLine raw in let tempNumber = ref 0 in (
                                              ignore (if raw == Obj.magic (HxRuntime.hx_null) then let __assign_366 = 0 in (
                                                tempNumber := __assign_366;
                                                __assign_366
                                              ) else let __assign_367 = HxString.length raw in (
                                                tempNumber := __assign_367;
                                                __assign_367
                                              ));
                                              ignore (print_endline ((((((("unsupported_expr[" ^ string_of_int (!unsupportedRawCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":raw=") ^ HxString.toStdString escaped) ^ " len=") ^ string_of_int (!tempNumber)));
                                              ignore (unsupportedRawCount := HxInt.add (!unsupportedRawCount) 1);
                                              if !unsupportedRawCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                            )
                                          )) with
                                            | HxRuntime.Hx_continue -> () done with
                                            | HxRuntime.Hx_break -> ()
                                        )) else ());
                                        unsupportedFilesCount := HxInt.add (!unsupportedFilesCount) 1
                                      )) else ());
                                      ignore (if HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ()) then ignore ((
                                        ignore (print_endline ((("header_only_file[" ^ string_of_int (!headerOnlyCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)));
                                        headerOnlyCount := HxInt.add (!headerOnlyCount) 1
                                      )) else ());
                                      ignore (parsedMethodsTotal := HxInt.add (!parsedMethodsTotal) (HxArray.length (HxClassDecl.getFunctions (HxModuleDecl.getMainClass (ParsedModule.getDecl pm ())))));
                                      let typed = TyperStage.typeResolvedModule m typerIndex moduleLoader in (
                                        ignore (if HxString.equals (ResolvedModule.getFilePath m) rootFilePath then ignore (let __assign_368 = typed in (
                                          rootTyped := __assign_368;
                                          __assign_368
                                        )) else ());
                                        typedCount := HxInt.add (!typedCount) 1
                                      )
                                    ) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_369 -> raise (HxRuntime.Hx_return __ret_369)
                                      | HxRuntime.Hx_exception (__exn_v_370, __exn_tags_371) -> if true then let e = (__exn_v_370 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_372 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_372;
                                              __assign_372
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_370 __exn_tags_371
                                      | __exn_373 -> if true then let e = (Obj.repr __exn_373 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_374 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_374;
                                              __assign_374
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                        )
                                      ) else raise (__exn_373));
                                    let _g = ref 0 in let _g1 = moduleLoader.drainNewModules (Obj.magic moduleLoader) () in while !_g < HxArray.length _g1 do ignore (let nm = HxArray.get _g1 (!_g) in (
                                      ignore (let __old_375 = !_g in let __new_376 = HxInt.add __old_375 1 in (
                                        ignore (_g := __new_376);
                                        __new_376
                                      ));
                                      ignore (HxArray.push (!tempArray8) nm);
                                      HxArray.push toType nm
                                    )) done
                                  )) done);
                                  ignore (if !rootTyped != Obj.magic (HxRuntime.hx_null) then ignore (let fns = TyClassEnv.getFunctions (TyModuleEnv.getMainClass (TypedModule.getEnv (!rootTyped) ()) ()) () in let _g = ref 0 in let _g1 = HxArray.length fns in while !_g < _g1 do ignore (let i2 = let __old_377 = !_g in let __new_378 = HxInt.add __old_377 1 in (
                                    ignore (_g := __new_378);
                                    __old_377
                                  ) in let tf = HxArray.get fns i2 in let locals = TyFunctionEnv.getLocals tf () in let localsParts = HxArray.create () in (
                                    ignore (let _g2 = ref 0 in while !_g2 < HxArray.length locals do ignore (let l = HxArray.get locals (!_g2) in (
                                      ignore (let __old_379 = !_g2 in let __new_380 = HxInt.add __old_379 1 in (
                                        ignore (_g2 := __new_380);
                                        __new_380
                                      ));
                                      HxArray.push localsParts ((HxString.toStdString (TySymbol.getName l ()) ^ ":") ^ HxString.toStdString (TyType.toString (TySymbol.getType l ()) ()))
                                    )) done);
                                    let params = TyFunctionEnv.getParams tf () in let paramParts = HxArray.create () in (
                                      ignore (let _g2 = ref 0 in while !_g2 < HxArray.length params do ignore (let p = HxArray.get params (!_g2) in (
                                        ignore (let __old_381 = !_g2 in let __new_382 = HxInt.add __old_381 1 in (
                                          ignore (_g2 := __new_382);
                                          __new_382
                                        ));
                                        HxArray.push paramParts ((HxString.toStdString (TySymbol.getName p ()) ^ ":") ^ HxString.toStdString (TyType.toString (TySymbol.getType p ()) ()))
                                      )) done);
                                      print_endline ((((((((((("typed_fn[" ^ string_of_int i2) ^ "]=") ^ HxString.toStdString (TyFunctionEnv.getName tf ())) ^ " args=") ^ HxString.toStdString (HxArray.join paramParts "," (fun x -> x))) ^ " locals=") ^ HxString.toStdString (HxArray.join localsParts "," (fun x -> x))) ^ " ret=") ^ HxString.toStdString (TyType.toString (TyFunctionEnv.getReturnType tf ()) ())) ^ " inferred=") ^ HxString.toStdString (TyType.toString (TyFunctionEnv.getReturnExprType tf ()) ()))
                                    )
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterTypingHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_383 = !_g in let __new_384 = HxInt.add __old_383 1 in (
                                    ignore (_g := __new_384);
                                    __old_383
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterTyping" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_385 -> raise (HxRuntime.Hx_return __ret_385)
                                      | HxRuntime.Hx_exception (__exn_v_386, __exn_tags_387) -> if true then let e = (__exn_v_386 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_388 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_388;
                                              __assign_388
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_386 __exn_tags_387
                                      | __exn_389 -> if true then let e = (Obj.repr __exn_389 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_390 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_390;
                                              __assign_390
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_389));
                                    print_endline (("hook_afterTyping[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listOnGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_391 = !_g in let __new_392 = HxInt.add __old_391 1 in (
                                    ignore (_g := __new_392);
                                    __old_391
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "onGenerate" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_393 -> raise (HxRuntime.Hx_return __ret_393)
                                      | HxRuntime.Hx_exception (__exn_v_394, __exn_tags_395) -> if true then let e = (__exn_v_394 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_396 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_396;
                                              __assign_396
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_394 __exn_tags_395
                                      | __exn_397 -> if true then let e = (Obj.repr __exn_397 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_398 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_398;
                                              __assign_398
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_397));
                                    print_endline (("hook_onGenerate[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_399 = !_g in let __new_400 = HxInt.add __old_399 1 in (
                                    ignore (_g := __new_400);
                                    __old_399
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterGenerate" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_401 -> raise (HxRuntime.Hx_return __ret_401)
                                      | HxRuntime.Hx_exception (__exn_v_402, __exn_tags_403) -> if true then let e = (__exn_v_402 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_404 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_404;
                                              __assign_404
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_402 __exn_tags_403
                                      | __exn_405 -> if true then let e = (Obj.repr __exn_405 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_406 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_406;
                                              __assign_406
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_405));
                                    print_endline (("hook_afterGenerate[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                    ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                    let __assign_407 = Obj.magic (HxRuntime.hx_null) in (
                                      macroSession := __assign_407;
                                      __assign_407
                                    )
                                  )) else ());
                                  ignore (print_endline ("typed_modules=" ^ string_of_int (!typedCount)));
                                  ignore (print_endline ("header_only_modules=" ^ string_of_int (!headerOnlyCount)));
                                  ignore (print_endline ("parsed_methods_total=" ^ string_of_int (!parsedMethodsTotal)));
                                  ignore (print_endline ("unsupported_exprs_total=" ^ string_of_int (!unsupportedExprsTotal)));
                                  ignore (print_endline ("unsupported_files=" ^ string_of_int (!unsupportedFilesCount)));
                                  ignore (print_endline "stage3=type_only_ok");
                                  raise (HxRuntime.Hx_return (Obj.repr 0))
                                )) else ());
                                let typedModules = HxArray.create () in let toType = HxArray.copy (!tempArray8) in let cursor = ref 0 in (
                                  ignore (while !cursor < HxArray.length toType do ignore (let m = HxArray.get toType (!cursor) in (
                                    ignore (cursor := HxInt.add (!cursor) 1);
                                    ignore (try HxArray.push typedModules (TyperStage.typeResolvedModule m typerIndex moduleLoader) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_408 -> raise (HxRuntime.Hx_return __ret_408)
                                      | HxRuntime.Hx_exception (__exn_v_409, __exn_tags_410) -> if true then let e = (__exn_v_409 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_411 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_411;
                                              __assign_411
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_409 __exn_tags_410
                                      | __exn_412 -> if true then let e = (Obj.repr __exn_412 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_413 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_413;
                                              __assign_413
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ((("type failed: " ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ": ") ^ HxString.toStdString (formatException e)))))
                                        )
                                      ) else raise (__exn_412));
                                    let _g = ref 0 in let _g1 = moduleLoader.drainNewModules (Obj.magic moduleLoader) () in while !_g < HxArray.length _g1 do ignore (let nm = HxArray.get _g1 (!_g) in (
                                      ignore (let __old_414 = !_g in let __new_415 = HxInt.add __old_414 1 in (
                                        ignore (_g := __new_415);
                                        __new_415
                                      ));
                                      ignore (HxArray.push (!tempArray8) nm);
                                      HxArray.push toType nm
                                    )) done
                                  )) done);
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterTypingHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_416 = !_g in let __new_417 = HxInt.add __old_416 1 in (
                                    ignore (_g := __new_417);
                                    __old_416
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterTyping" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_418 -> raise (HxRuntime.Hx_return __ret_418)
                                      | HxRuntime.Hx_exception (__exn_v_419, __exn_tags_420) -> if true then let e = (__exn_v_419 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_421 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_421;
                                              __assign_421
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_419 __exn_tags_420
                                      | __exn_422 -> if true then let e = (Obj.repr __exn_422 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_423 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_423;
                                              __assign_423
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterTyping hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_422));
                                    print_endline (("hook_afterTyping[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listOnGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_424 = !_g in let __new_425 = HxInt.add __old_424 1 in (
                                    ignore (_g := __new_425);
                                    __old_424
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "onGenerate" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_426 -> raise (HxRuntime.Hx_return __ret_426)
                                      | HxRuntime.Hx_exception (__exn_v_427, __exn_tags_428) -> if true then let e = (__exn_v_427 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_429 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_429;
                                              __assign_429
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_427 __exn_tags_428
                                      | __exn_430 -> if true then let e = (Obj.repr __exn_430 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_431 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_431;
                                              __assign_431
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("onGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_430));
                                    print_endline (("hook_onGenerate[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore (let hooks = Hxhx_macro_MacroState.listAfterGenerateHookIds () in let _g = ref 0 in let _g1 = HxArray.length hooks in while !_g < _g1 do ignore (let i2 = let __old_432 = !_g in let __new_433 = HxInt.add __old_432 1 in (
                                    ignore (_g := __new_433);
                                    __old_432
                                  ) in (
                                    ignore (try Hxhx_macro_MacroHostClient.macrohostsession_runHook (!macroSession) "afterGenerate" (HxArray.get hooks i2) with
                                      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                      | HxRuntime.Hx_return __ret_434 -> raise (HxRuntime.Hx_return __ret_434)
                                      | HxRuntime.Hx_exception (__exn_v_435, __exn_tags_436) -> if true then let e = (__exn_v_435 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_437 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_437;
                                              __assign_437
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else HxRuntime.hx_throw_typed __exn_v_435 __exn_tags_436
                                      | __exn_438 -> if true then let e = (Obj.repr __exn_438 : Obj.t) in (
                                        ignore e;
                                        (
                                          ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                            ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                            let __assign_439 = Obj.magic (HxRuntime.hx_null) in (
                                              macroSession := __assign_439;
                                              __assign_439
                                            )
                                          )) else ());
                                          raise (HxRuntime.Hx_return (Obj.repr (error ("afterGenerate hook failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                        )
                                      ) else raise (__exn_438));
                                    print_endline (("hook_afterGenerate[" ^ string_of_int i2) ^ "]=ok")
                                  )) done) else ());
                                  let generated = HxArray.create () in (
                                    ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listOcamlModuleNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                                      ignore (let __old_440 = !_g in let __new_441 = HxInt.add __old_440 1 in (
                                        ignore (_g := __new_441);
                                        __new_441
                                      ));
                                      HxArray.push generated (let __anon_442 = HxAnon.create () in (
                                        ignore (HxAnon.set __anon_442 "name" (Obj.repr name));
                                        ignore (HxAnon.set __anon_442 "source" (Obj.repr (Hxhx_macro_MacroState.getOcamlModuleSource name)));
                                        __anon_442
                                      ))
                                    )) done);
                                    let expanded = MacroStage.expandProgram typedModules generated in (
                                      ignore (let _g = ref 0 in let _g1 = Hxhx_macro_MacroState.listDefineNames () in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
                                        ignore (let __old_443 = !_g in let __new_444 = HxInt.add __old_443 1 in (
                                          ignore (_g := __new_444);
                                          __new_444
                                        ));
                                        if StringTools.startsWith name "HXHX_" then ignore (print_endline ((("macro_define2[" ^ HxString.toStdString name) ^ "]=") ^ HxString.toStdString (Hxhx_macro_MacroState.definedValue name))) else ()
                                      )) done);
                                      ignore (if !noEmit then ignore (let headerOnlyCount = ref 0 in let unsupportedExprsTotal = ref 0 in let unsupportedFilesCount = ref 0 in let traceUnsupported = isTrueEnv "HXHX_TRACE_UNSUPPORTED" in let unsupportedRawCount = ref 0 in let unsupportedFnCount = ref 0 in (
                                        ignore (let _g = ref 0 in while !_g < HxArray.length (!tempArray8) do ignore (let m = HxArray.get (!tempArray8) (!_g) in (
                                          ignore (let __old_445 = !_g in let __new_446 = HxInt.add __old_445 1 in (
                                            ignore (_g := __new_446);
                                            __new_446
                                          ));
                                          let pm = ResolvedModule.getParsed m in (
                                            ignore (if HxModuleDecl.getHeaderOnly (ParsedModule.getDecl pm ()) then ignore (headerOnlyCount := HxInt.add (!headerOnlyCount) 1) else ());
                                            let unsupportedInFile = countUnsupportedExprsInModule pm in (
                                              ignore (unsupportedExprsTotal := HxInt.add (!unsupportedExprsTotal) unsupportedInFile);
                                              if unsupportedInFile > 0 then ignore ((
                                                ignore (unsupportedFilesCount := HxInt.add (!unsupportedFilesCount) 1);
                                                if traceUnsupported then ignore (let cls = HxModuleDecl.getMainClass (ParsedModule.getDecl pm ()) in (
                                                  ignore (let _g2 = ref 0 in let _g1 = HxClassDecl.getFunctions cls in try while !_g2 < HxArray.length _g1 do try ignore (let fn = HxArray.get _g1 (!_g2) in (
                                                    ignore (let __old_447 = !_g2 in let __new_448 = HxInt.add __old_447 1 in (
                                                      ignore (_g2 := __new_448);
                                                      __new_448
                                                    ));
                                                    let fnUnsupported = countUnsupportedExprsInFunction fn in (
                                                      ignore (if fnUnsupported <= 0 then raise (HxRuntime.Hx_continue) else ());
                                                      ignore (print_endline ((((((("unsupported_fn[" ^ string_of_int (!unsupportedFnCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":") ^ HxString.toStdString (HxFunctionDecl.getName fn)) ^ " unsupported_exprs=") ^ string_of_int fnUnsupported));
                                                      ignore (unsupportedFnCount := HxInt.add (!unsupportedFnCount) 1);
                                                      if !unsupportedFnCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                    )
                                                  )) with
                                                    | HxRuntime.Hx_continue -> () done with
                                                    | HxRuntime.Hx_break -> ());
                                                  let _g2 = ref 0 in let _g1 = collectUnsupportedExprRawInModule pm 20 in try while !_g2 < HxArray.length _g1 do try ignore (let raw = HxArray.get _g1 (!_g2) in (
                                                    ignore (let __old_449 = !_g2 in let __new_450 = HxInt.add __old_449 1 in (
                                                      ignore (_g2 := __new_450);
                                                      __new_450
                                                    ));
                                                    let escaped = escapeOneLine raw in let tempNumber1 = ref 0 in (
                                                      ignore (if raw == Obj.magic (HxRuntime.hx_null) then let __assign_451 = 0 in (
                                                        tempNumber1 := __assign_451;
                                                        __assign_451
                                                      ) else let __assign_452 = HxString.length raw in (
                                                        tempNumber1 := __assign_452;
                                                        __assign_452
                                                      ));
                                                      ignore (print_endline ((((((("unsupported_expr[" ^ string_of_int (!unsupportedRawCount)) ^ "]=") ^ HxString.toStdString (ResolvedModule.getFilePath m)) ^ ":raw=") ^ HxString.toStdString escaped) ^ " len=") ^ string_of_int (!tempNumber1)));
                                                      ignore (unsupportedRawCount := HxInt.add (!unsupportedRawCount) 1);
                                                      if !unsupportedRawCount >= 50 then raise (HxRuntime.Hx_break) else ()
                                                    )
                                                  )) with
                                                    | HxRuntime.Hx_continue -> () done with
                                                    | HxRuntime.Hx_break -> ()
                                                )) else ()
                                              )) else ()
                                            )
                                          )
                                        )) done);
                                        ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                          ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                          let __assign_453 = Obj.magic (HxRuntime.hx_null) in (
                                            macroSession := __assign_453;
                                            __assign_453
                                          )
                                        )) else ());
                                        ignore (print_endline ("typed_modules=" ^ string_of_int (HxArray.length typedModules)));
                                        ignore (print_endline ("header_only_modules=" ^ string_of_int (!headerOnlyCount)));
                                        ignore (print_endline ("unsupported_exprs_total=" ^ string_of_int (!unsupportedExprsTotal)));
                                        ignore (print_endline ("unsupported_files=" ^ string_of_int (!unsupportedFilesCount)));
                                        ignore (print_endline "stage3=no_emit_ok");
                                        raise (HxRuntime.Hx_return (Obj.repr 0))
                                      )) else ());
                                      let tempString2 = ref "" in (
                                        ignore (try let __assign_454 = EmitterStage.emitToDir expanded outAbs (!emitFullBodies) in (
                                          tempString2 := __assign_454;
                                          __assign_454
                                        ) with
                                          | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                                          | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                                          | HxRuntime.Hx_return __ret_455 -> raise (HxRuntime.Hx_return __ret_455)
                                          | HxRuntime.Hx_exception (__exn_v_456, __exn_tags_457) -> if true then let e = (__exn_v_456 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_458 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_458;
                                                  __assign_458
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("emit failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else HxRuntime.hx_throw_typed __exn_v_456 __exn_tags_457
                                          | __exn_459 -> if true then let e = (Obj.repr __exn_459 : Obj.t) in (
                                            ignore e;
                                            (
                                              ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                                ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                                let __assign_460 = Obj.magic (HxRuntime.hx_null) in (
                                                  macroSession := __assign_460;
                                                  __assign_460
                                                )
                                              )) else ());
                                              raise (HxRuntime.Hx_return (Obj.repr (error ("emit failed: " ^ HxString.toStdString (HxRuntime.dynamic_toStdString e)))))
                                            )
                                          ) else raise (__exn_459));
                                        ignore (print_endline "stage3=ok");
                                        ignore (print_endline ("outDir=" ^ HxString.toStdString outAbs));
                                        ignore (print_endline ("exe=" ^ HxString.toStdString (!tempString2)));
                                        ignore (if !macroSession != Obj.magic (HxRuntime.hx_null) then ignore ((
                                          ignore (Hxhx_macro_MacroHostClient.macrohostsession_close (!macroSession) ());
                                          let __assign_461 = Obj.magic (HxRuntime.hx_null) in (
                                            macroSession := __assign_461;
                                            __assign_461
                                          )
                                        )) else ());
                                        let code = HxSys.command (!tempString2) (Some (let __arr_462 = HxArray.create () in __arr_462)) in (
                                          ignore (if code <> 0 then raise (HxRuntime.Hx_return (Obj.repr (error ("built executable failed with exit code " ^ string_of_int code)))) else ());
                                          ignore (print_endline "run=ok");
                                          0
                                        )
                                      )
                                    )
                                  )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_463 -> Obj.obj __ret_463
# 1 "backend_ocaml_OcamlTargetCore.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: backend.ocaml.OcamlTargetCore *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; coreId : Obj.t -> unit -> string; emit : Obj.t -> Obj.t -> Backend_BackendContext.t -> Backend_EmitResult.t }

let __ctor = fun (self : t) () -> ignore ((
  ignore self;
  ()
))

let coreId__impl = fun (self : t) () -> (
  ignore self;
  "reflaxe.ocaml.target-core"
)

let emit__impl = fun (self : t) (program : Obj.t) (context : Backend_BackendContext.t) -> (
  ignore self;
  let entryPath = EmitterStage.emitToDir (Obj.obj program) (context.outputDir) (context.emitFullBodies) (context.buildExecutable) in let tempString = ref "" in (
    ignore (if context.buildExecutable then let __assign_1 = "entry_executable" in (
      tempString := __assign_1;
      __assign_1
    ) else let __assign_2 = "entry_planned_executable" in (
      tempString := __assign_2;
      __assign_2
    ));
    Backend_EmitResult.create entryPath (let __arr_3 = HxArray.create () in (
      ignore (HxArray.push __arr_3 (Backend_EmitArtifact.create (!tempString) entryPath));
      __arr_3
    )) (context.buildExecutable)
  )
)

let create = fun () -> let self = ({ __hx_type = HxType.class_ "backend.ocaml.OcamlTargetCore"; coreId = (fun o () -> coreId__impl (Obj.magic o) ()); emit = (fun o a0 a1 -> emit__impl (Obj.magic o) a0 a1) } : t) in (
  ignore ((
    ignore self;
    ()
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "backend.ocaml.OcamlTargetCore"; coreId = (fun o () -> coreId__impl (Obj.magic o) ()); emit = (fun o a0 a1 -> emit__impl (Obj.magic o) a0 a1) } : t)
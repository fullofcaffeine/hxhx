# 1 "HxConditionalCompilation.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: _HxConditionalCompilation.Token *)

type token =
| TIdent of string
| TString of string
| TNot
| TAnd
| TOr
| TLParen
| TRParen
| TEq
| TNeq
| TEof

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: _HxConditionalCompilation.ExprLexer *)

let __reflaxe_ocaml__ = ()

type exprlexer_t = { __hx_type : Obj.t; mutable s : string; mutable i : int }

let exprlexer_create = fun s2 -> let self = ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprLexer"; s = ""; i = 0 } : exprlexer_t) in (
  ignore ((
    ignore (let __assign_1 = 0 in (
      self.i <- __assign_1;
      __assign_1
    ));
    let tempRight = ref "" in (
      ignore (if s2 == Obj.magic (HxRuntime.hx_null) then let __assign_2 = "" in (
        tempRight := __assign_2;
        __assign_2
      ) else let __assign_3 = s2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      let __assign_4 = !tempRight in (
        self.s <- __assign_4;
        __assign_4
      )
    )
  ));
  self
)

let exprlexer___empty = fun () -> ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprLexer"; s = ""; i = 0 } : exprlexer_t)

let exprlexer_eof = fun self () -> self.i >= HxString.length (self.s)

let exprlexer_peek = fun self (off : int) -> let j = HxInt.add (self.i) off in let tempResult = ref 0 in (
  ignore (if j >= HxString.length (self.s) then let __assign_5 = -1 in (
    tempResult := __assign_5;
    __assign_5
  ) else let __assign_6 = let __nullable_int_7 = HxString.charCodeAt (self.s) j in if __nullable_int_7 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_7 in (
    tempResult := __assign_6;
    __assign_6
  ));
  !tempResult
)

let exprlexer_bump = fun self () -> let tempResult = ref 0 in (
  ignore (if self.i >= HxString.length (self.s) then let __assign_8 = -1 in (
    tempResult := __assign_8;
    __assign_8
  ) else let __assign_9 = let __nullable_int_13 = HxString.charCodeAt (self.s) (let __obj_10 = self in let __old_11 = __obj_10.i in let __new_12 = HxInt.add __old_11 1 in (
    ignore (__obj_10.i <- __new_12);
    __old_11
  )) in if __nullable_int_13 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_13 in (
    tempResult := __assign_9;
    __assign_9
  ));
  !tempResult
)

let exprlexer_isWs = fun self (c : int) -> (
  ignore self;
  c = 9 || c = 10 || c = 13 || c = 32
)

let exprlexer_isIdentStart = fun self (c : int) -> (
  ignore self;
  c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95
)

let exprlexer_isIdentCont = fun self (c : int) -> (
  ignore self;
  c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 || c >= 48 && c <= 57
)

let exprlexer_skipWs = fun self () -> ignore (try while true do try ignore (let tempNumber = ref 0 in let off = 0 in let j = HxInt.add (self.i) off in (
  ignore (if j >= HxString.length (self.s) then let __assign_14 = -1 in (
    tempNumber := __assign_14;
    __assign_14
  ) else let __assign_15 = let __nullable_int_16 = HxString.charCodeAt (self.s) j in if __nullable_int_16 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_16 in (
    tempNumber := __assign_15;
    __assign_15
  ));
  let c = !tempNumber in let tempRight = c = 9 || c = 10 || c = 13 || c = 32 in (
    ignore (if not (self.i < HxString.length (self.s) && tempRight) then raise (HxRuntime.Hx_break) else ());
    let __obj_17 = self in let __old_18 = __obj_17.i in let __new_19 = HxInt.add __old_18 1 in (
      ignore (__obj_17.i <- __new_19);
      __old_18
    )
  )
)) with
  | HxRuntime.Hx_continue -> () done with
  | HxRuntime.Hx_break -> ())

let exprlexer_readIdent = fun self () -> let start = self.i in (
  ignore (if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_20 = self in let __old_21 = __obj_20.i in let __new_22 = HxInt.add __old_21 1 in (
    ignore (__obj_20.i <- __new_22);
    __old_21
  ))));
  ignore (try while true do try ignore (let tempNumber = ref 0 in let off = 0 in let j = HxInt.add (self.i) off in (
    ignore (if j >= HxString.length (self.s) then let __assign_23 = -1 in (
      tempNumber := __assign_23;
      __assign_23
    ) else let __assign_24 = let __nullable_int_25 = HxString.charCodeAt (self.s) j in if __nullable_int_25 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_25 in (
      tempNumber := __assign_24;
      __assign_24
    ));
    let c = !tempNumber in let tempRight = c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 || c >= 48 && c <= 57 in (
      ignore (if not (self.i < HxString.length (self.s) && tempRight) then raise (HxRuntime.Hx_break) else ());
      if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_26 = self in let __old_27 = __obj_26.i in let __new_28 = HxInt.add __old_27 1 in (
        ignore (__obj_26.i <- __new_28);
        __old_27
      )))
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  HxString.substr (self.s) start (HxInt.sub (self.i) start)
)

let exprlexer_readString = fun self (q : int) -> try (
  ignore (if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_29 = self in let __old_30 = __obj_29.i in let __new_31 = HxInt.add __old_30 1 in (
    ignore (__obj_29.i <- __new_31);
    __old_30
  ))));
  let b = StringBuf.create () in (
    ignore (try while self.i < HxString.length (self.s) do try ignore (let tempNumber = ref 0 in (
      ignore (if self.i >= HxString.length (self.s) then let __assign_32 = -1 in (
        tempNumber := __assign_32;
        __assign_32
      ) else let __assign_33 = let __nullable_int_37 = HxString.charCodeAt (self.s) (let __obj_34 = self in let __old_35 = __obj_34.i in let __new_36 = HxInt.add __old_35 1 in (
        ignore (__obj_34.i <- __new_36);
        __old_35
      )) in if __nullable_int_37 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_37 in (
        tempNumber := __assign_33;
        __assign_33
      ));
      let c = !tempNumber in (
        ignore (if c = q then raise (HxRuntime.Hx_return (Obj.repr (StringBuf.toString b ()))) else ());
        ignore (if c = 92 && self.i < HxString.length (self.s) then ignore (let tempNumber1 = ref 0 in (
          ignore (if self.i >= HxString.length (self.s) then let __assign_38 = -1 in (
            tempNumber1 := __assign_38;
            __assign_38
          ) else let __assign_39 = let __nullable_int_43 = HxString.charCodeAt (self.s) (let __obj_40 = self in let __old_41 = __obj_40.i in let __new_42 = HxInt.add __old_41 1 in (
            ignore (__obj_40.i <- __new_42);
            __old_41
          )) in if __nullable_int_43 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_43 in (
            tempNumber1 := __assign_39;
            __assign_39
          ));
          let esc = !tempNumber1 in (
            ignore (match esc with
              | 34 -> ignore (StringBuf.addChar b 34)
              | 39 -> ignore (StringBuf.addChar b 39)
              | 92 -> ignore (StringBuf.addChar b 92)
              | 110 -> ignore (StringBuf.addChar b 10)
              | 114 -> ignore (StringBuf.addChar b 13)
              | 116 -> ignore (StringBuf.addChar b 9)
              | _ -> ignore (StringBuf.addChar b esc));
            raise (HxRuntime.Hx_continue)
          )
        )) else ());
        StringBuf.addChar b c
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    StringBuf.toString b ()
  )
) with
  | HxRuntime.Hx_return __ret_44 -> Obj.obj __ret_44

let rec exprlexer_next = fun self () -> try (
  ignore (exprlexer_skipWs self ());
  ignore (if self.i >= HxString.length (self.s) then raise (HxRuntime.Hx_return (Obj.repr TEof)) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let tempNumber = ref 0 in (
      ignore (let off = 0 in let j = HxInt.add (self.i) off in if j >= HxString.length (self.s) then let __assign_45 = -1 in (
        tempNumber := __assign_45;
        __assign_45
      ) else let __assign_46 = let __nullable_int_47 = HxString.charCodeAt (self.s) j in if __nullable_int_47 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_47 in (
        tempNumber := __assign_46;
        __assign_46
      ));
      let _g = !tempNumber in match _g with
        | 33 -> let tempLeft = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_53 = -1 in (
            tempLeft := __assign_53;
            __assign_53
          ) else let __assign_54 = let __nullable_int_55 = HxString.charCodeAt (self.s) j in if __nullable_int_55 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_55 in (
            tempLeft := __assign_54;
            __assign_54
          ));
          if !tempLeft = 61 then (
            ignore (let __recv_56 = self in __recv_56.i <- HxInt.add (__recv_56.i) 2);
            let __assign_57 = TNeq in (
              tempResult := __assign_57;
              __assign_57
            )
          ) else (
            ignore (let __obj_58 = self in let __old_59 = __obj_58.i in let __new_60 = HxInt.add __old_59 1 in (
              ignore (__obj_58.i <- __new_60);
              __old_59
            ));
            let __assign_61 = TNot in (
              tempResult := __assign_61;
              __assign_61
            )
          )
        )
        | 38 -> let tempLeft1 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_62 = -1 in (
            tempLeft1 := __assign_62;
            __assign_62
          ) else let __assign_63 = let __nullable_int_64 = HxString.charCodeAt (self.s) j in if __nullable_int_64 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_64 in (
            tempLeft1 := __assign_63;
            __assign_63
          ));
          if !tempLeft1 = 38 then (
            ignore (let __recv_65 = self in __recv_65.i <- HxInt.add (__recv_65.i) 2);
            let __assign_66 = TAnd in (
              tempResult := __assign_66;
              __assign_66
            )
          ) else (
            ignore (let __obj_67 = self in let __old_68 = __obj_67.i in let __new_69 = HxInt.add __old_68 1 in (
              ignore (__obj_67.i <- __new_69);
              __old_68
            ));
            let __assign_70 = TEof in (
              tempResult := __assign_70;
              __assign_70
            )
          )
        )
        | 34 | 39 -> let tempNumber1 = ref 0 in (
          ignore (let off = 0 in let j = HxInt.add (self.i) off in if j >= HxString.length (self.s) then let __assign_71 = -1 in (
            tempNumber1 := __assign_71;
            __assign_71
          ) else let __assign_72 = let __nullable_int_73 = HxString.charCodeAt (self.s) j in if __nullable_int_73 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_73 in (
            tempNumber1 := __assign_72;
            __assign_72
          ));
          let q = !tempNumber1 in let __assign_74 = TString (exprlexer_readString self q) in (
            tempResult := __assign_74;
            __assign_74
          )
        )
        | 40 -> (
          ignore (let __obj_75 = self in let __old_76 = __obj_75.i in let __new_77 = HxInt.add __old_76 1 in (
            ignore (__obj_75.i <- __new_77);
            __old_76
          ));
          let __assign_78 = TLParen in (
            tempResult := __assign_78;
            __assign_78
          )
        )
        | 41 -> (
          ignore (let __obj_79 = self in let __old_80 = __obj_79.i in let __new_81 = HxInt.add __old_80 1 in (
            ignore (__obj_79.i <- __new_81);
            __old_80
          ));
          let __assign_82 = TRParen in (
            tempResult := __assign_82;
            __assign_82
          )
        )
        | 61 -> let tempLeft2 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_83 = -1 in (
            tempLeft2 := __assign_83;
            __assign_83
          ) else let __assign_84 = let __nullable_int_85 = HxString.charCodeAt (self.s) j in if __nullable_int_85 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_85 in (
            tempLeft2 := __assign_84;
            __assign_84
          ));
          if !tempLeft2 = 61 then (
            ignore (let __recv_86 = self in __recv_86.i <- HxInt.add (__recv_86.i) 2);
            let __assign_87 = TEq in (
              tempResult := __assign_87;
              __assign_87
            )
          ) else (
            ignore (let __obj_88 = self in let __old_89 = __obj_88.i in let __new_90 = HxInt.add __old_89 1 in (
              ignore (__obj_88.i <- __new_90);
              __old_89
            ));
            let __assign_91 = TEof in (
              tempResult := __assign_91;
              __assign_91
            )
          )
        )
        | 124 -> let tempLeft3 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_92 = -1 in (
            tempLeft3 := __assign_92;
            __assign_92
          ) else let __assign_93 = let __nullable_int_94 = HxString.charCodeAt (self.s) j in if __nullable_int_94 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_94 in (
            tempLeft3 := __assign_93;
            __assign_93
          ));
          if !tempLeft3 = 124 then (
            ignore (let __recv_95 = self in __recv_95.i <- HxInt.add (__recv_95.i) 2);
            let __assign_96 = TOr in (
              tempResult := __assign_96;
              __assign_96
            )
          ) else (
            ignore (let __obj_97 = self in let __old_98 = __obj_97.i in let __new_99 = HxInt.add __old_98 1 in (
              ignore (__obj_97.i <- __new_99);
              __old_98
            ));
            let __assign_100 = TEof in (
              tempResult := __assign_100;
              __assign_100
            )
          )
        )
        | _ -> let c = _g in if c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 then let __assign_48 = TIdent (exprlexer_readIdent self ()) in (
          tempResult := __assign_48;
          __assign_48
        ) else (
          ignore (let __obj_49 = self in let __old_50 = __obj_49.i in let __new_51 = HxInt.add __old_50 1 in (
            ignore (__obj_49.i <- __new_51);
            __old_50
          ));
          let __assign_52 = exprlexer_next self () in (
            tempResult := __assign_52;
            __assign_52
          )
        )
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_101 -> Obj.obj __ret_101

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: _HxConditionalCompilation.ExprParser *)

let __reflaxe_ocaml__ = ()

type exprparser_t = { __hx_type : Obj.t; mutable lex : exprlexer_t; mutable defines : string HxMap.string_map; mutable cur : token }

let exprparser_create = fun expr defines2 -> let self = ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprParser"; lex = Obj.magic (); defines = Obj.magic (); cur = Obj.magic () } : exprparser_t) in (
  ignore ((
    ignore (let __assign_1 = exprlexer_create expr in (
      self.lex <- __assign_1;
      __assign_1
    ));
    let tempRight = ref (Obj.magic ()) in (
      ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_2 = HxMap.create_string () in (
        tempRight := __assign_2;
        __assign_2
      ) else let __assign_3 = defines2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      ignore (let __assign_4 = !tempRight in (
        self.defines <- __assign_4;
        __assign_4
      ));
      let __assign_5 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_5;
        __assign_5
      )
    )
  ));
  self
)

let exprparser___empty = fun () -> ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprParser"; lex = Obj.magic (); defines = Obj.magic (); cur = Obj.magic () } : exprparser_t)

let exprparser_bump = fun self () -> ignore (let __assign_6 = exprlexer_next (self.lex) () in (
  self.cur <- __assign_6;
  __assign_6
))

let exprparser_parseStringLit = fun self () -> let tempResult = ref "" in (
  ignore (let _g = self.cur in match _g with
    | TIdent _p0 -> let _g2 = _p0 in let s = _g2 in (
      ignore (let __assign_42 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_42;
        __assign_42
      ));
      let __assign_43 = s in (
        tempResult := __assign_43;
        __assign_43
      )
    )
    | TString _p0 -> let _g2 = _p0 in let s = _g2 in (
      ignore (let __assign_44 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_44;
        __assign_44
      ));
      let __assign_45 = s in (
        tempResult := __assign_45;
        __assign_45
      )
    )
    | _ -> let __assign_41 = "" in (
      tempResult := __assign_41;
      __assign_41
    ));
  !tempResult
)

let exprparser_definedValue = fun self (name : string) -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let tempResult = ref "" in (
    ignore (if HxMap.exists_string (self.defines) name then let __assign_46 = HxMap.get_string (self.defines) name in (
      tempResult := __assign_46;
      __assign_46
    ) else let __assign_47 = "" in (
      tempResult := __assign_47;
      __assign_47
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_48 -> Obj.obj __ret_48

let exprparser_parseIdentTail = fun self (name : string) -> try let tempRight = ref false in (
  ignore (let _g = self.cur in if (match _g with
    | TIdent _ -> 0
    | TString _ -> 1
    | TNot -> 2
    | TAnd -> 3
    | TOr -> 4
    | TLParen -> 5
    | TRParen -> 6
    | TEq -> 7
    | TNeq -> 8
    | TEof -> 9) = 5 then let __assign_25 = true in (
    tempRight := __assign_25;
    __assign_25
  ) else let __assign_26 = false in (
    tempRight := __assign_26;
    __assign_26
  ));
  ignore (if HxString.equals name "defined" && !tempRight then ignore ((
    ignore (let __assign_27 = exprlexer_next (self.lex) () in (
      self.cur <- __assign_27;
      __assign_27
    ));
    let key = ref "" in (
      ignore (let _g = self.cur in match _g with
        | TIdent _p0 -> ignore (let _g2 = _p0 in let n = _g2 in (
          ignore (let __assign_28 = n in (
            key := __assign_28;
            __assign_28
          ));
          let __assign_29 = exprlexer_next (self.lex) () in (
            self.cur <- __assign_29;
            __assign_29
          )
        ))
        | TString _p0 -> ignore (let _g2 = _p0 in let s = _g2 in (
          ignore (let __assign_30 = s in (
            key := __assign_30;
            __assign_30
          ));
          let __assign_31 = exprlexer_next (self.lex) () in (
            self.cur <- __assign_31;
            __assign_31
          )
        ))
        | _ -> ignore ());
      let tempBool = ref false in (
        ignore (let _g = self.cur in if (match _g with
          | TIdent _ -> 0
          | TString _ -> 1
          | TNot -> 2
          | TAnd -> 3
          | TOr -> 4
          | TLParen -> 5
          | TRParen -> 6
          | TEq -> 7
          | TNeq -> 8
          | TEof -> 9) = 6 then let __assign_32 = true in (
          tempBool := __assign_32;
          __assign_32
        ) else let __assign_33 = false in (
          tempBool := __assign_33;
          __assign_33
        ));
        ignore (if !tempBool then ignore (let __assign_34 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_34;
          __assign_34
        )) else ());
        raise (HxRuntime.Hx_return (Obj.repr (HxString.length (!key) > 0 && HxMap.exists_string (self.defines) (!key))))
      )
    )
  )) else ());
  let tempResult = ref false in (
    ignore (let _g = self.cur in match _g with
      | TEq -> (
        ignore (let __assign_36 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_36;
          __assign_36
        ));
        let lit = exprparser_parseStringLit self () in let __assign_37 = HxString.equals (exprparser_definedValue self name) lit in (
          tempResult := __assign_37;
          __assign_37
        )
      )
      | TNeq -> (
        ignore (let __assign_38 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_38;
          __assign_38
        ));
        let lit = exprparser_parseStringLit self () in let __assign_39 = not (HxString.equals (exprparser_definedValue self name) lit) in (
          tempResult := __assign_39;
          __assign_39
        )
      )
      | _ -> let __assign_35 = HxMap.exists_string (self.defines) name in (
        tempResult := __assign_35;
        __assign_35
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_40 -> Obj.obj __ret_40

let rec exprparser_parseOr = fun self () -> try let left = ref (exprparser_parseAnd self ()) in while true do ignore (let _g = self.cur in if (match _g with
  | TIdent _ -> 0
  | TString _ -> 1
  | TNot -> 2
  | TAnd -> 3
  | TOr -> 4
  | TLParen -> 5
  | TRParen -> 6
  | TEq -> 7
  | TNeq -> 8
  | TEof -> 9) = 4 then ignore ((
  ignore (let __assign_7 = exprlexer_next (self.lex) () in (
    self.cur <- __assign_7;
    __assign_7
  ));
  let __assign_8 = !left || exprparser_parseAnd self () in (
    left := __assign_8;
    __assign_8
  )
)) else raise (HxRuntime.Hx_return (Obj.repr (!left)))) done with
  | HxRuntime.Hx_return __ret_9 -> Obj.obj __ret_9
and exprparser_parseAnd = fun self () -> try let left = ref (exprparser_parseUnary self ()) in while true do ignore (let _g = self.cur in if (match _g with
  | TIdent _ -> 0
  | TString _ -> 1
  | TNot -> 2
  | TAnd -> 3
  | TOr -> 4
  | TLParen -> 5
  | TRParen -> 6
  | TEq -> 7
  | TNeq -> 8
  | TEof -> 9) = 3 then ignore ((
  ignore (let __assign_10 = exprlexer_next (self.lex) () in (
    self.cur <- __assign_10;
    __assign_10
  ));
  let __assign_11 = !left && exprparser_parseUnary self () in (
    left := __assign_11;
    __assign_11
  )
)) else raise (HxRuntime.Hx_return (Obj.repr (!left)))) done with
  | HxRuntime.Hx_return __ret_12 -> Obj.obj __ret_12
and exprparser_parseUnary = fun self () -> let tempResult = ref false in (
  ignore (let _g = self.cur in if (match _g with
    | TIdent _ -> 0
    | TString _ -> 1
    | TNot -> 2
    | TAnd -> 3
    | TOr -> 4
    | TLParen -> 5
    | TRParen -> 6
    | TEq -> 7
    | TNeq -> 8
    | TEof -> 9) = 2 then (
    ignore (let __assign_13 = exprlexer_next (self.lex) () in (
      self.cur <- __assign_13;
      __assign_13
    ));
    let __assign_14 = not (exprparser_parseUnary self ()) in (
      tempResult := __assign_14;
      __assign_14
    )
  ) else let __assign_15 = exprparser_parsePrimary self () in (
    tempResult := __assign_15;
    __assign_15
  ));
  !tempResult
)
and exprparser_parsePrimary = fun self () -> let tempResult = ref false in (
  ignore (let _g = self.cur in match _g with
    | TIdent _p0 -> let _g2 = _p0 in let name = _g2 in (
      ignore (let __assign_18 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_18;
        __assign_18
      ));
      let __assign_19 = exprparser_parseIdentTail self name in (
        tempResult := __assign_19;
        __assign_19
      )
    )
    | TLParen -> (
      ignore (let __assign_20 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_20;
        __assign_20
      ));
      let v = exprparser_parseOr self () in let tempBool = ref false in (
        ignore (let _g2 = self.cur in if (match _g2 with
          | TIdent _ -> 0
          | TString _ -> 1
          | TNot -> 2
          | TAnd -> 3
          | TOr -> 4
          | TLParen -> 5
          | TRParen -> 6
          | TEq -> 7
          | TNeq -> 8
          | TEof -> 9) = 6 then let __assign_21 = true in (
          tempBool := __assign_21;
          __assign_21
        ) else let __assign_22 = false in (
          tempBool := __assign_22;
          __assign_22
        ));
        ignore (if !tempBool then ignore (let __assign_23 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_23;
          __assign_23
        )) else ());
        let __assign_24 = v in (
          tempResult := __assign_24;
          __assign_24
        )
      )
    )
    | _ -> (
      ignore (let __assign_16 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_16;
        __assign_16
      ));
      let __assign_17 = false in (
        tempResult := __assign_17;
        __assign_17
      )
    ));
  !tempResult
)

let exprparser_parse = fun self () -> let v = exprparser_parseOr self () in v

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: HxConditionalCompilation *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "HxConditionalCompilation" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "HxConditionalCompilation" } : t)

let isSpace = fun c -> c = 9 || c = 32

let makeBlankLineLike = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) || HxString.length line = 0 then raise (HxRuntime.Hx_return (Obj.repr line)) else ());
  let b = StringBuf.create () in let _g = ref 0 in let _g1 = HxString.length line in (
    ignore (while !_g < _g1 do ignore (let i = let __old_1 = !_g in let __new_2 = HxInt.add __old_1 1 in (
      ignore (_g := __new_2);
      __old_1
    ) in let c = HxString.charCodeAt line i in let tempNumber = ref 0 in (
      ignore (if let __nullable_3 = c in if __nullable_3 == HxRuntime.hx_null then false else Obj.obj __nullable_3 = 10 then let __assign_4 = 10 in (
        tempNumber := __assign_4;
        __assign_4
      ) else if let __nullable_5 = c in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 = 13 then let __assign_6 = 13 in (
        tempNumber := __assign_6;
        __assign_6
      ) else let __assign_7 = 32 in (
        tempNumber := __assign_7;
        __assign_7
      ));
      StringBuf.addChar b (!tempNumber)
    )) done);
    StringBuf.toString b ()
  )
) with
  | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8

let splitLinesPreserveNewlines = fun s -> let out = HxArray.create () in let start = ref 0 in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if let __nullable_29 = c in if __nullable_29 == HxRuntime.hx_null then false else Obj.obj __nullable_29 = 10 then ignore ((
      ignore (HxArray.push out (HxString.substr s (!start) (HxInt.add (HxInt.sub (!i) (!start)) 1)));
      ignore (i := HxInt.add (!i) 1);
      ignore (let __assign_30 = !i in (
        start := __assign_30;
        __assign_30
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    i := HxInt.add (!i) 1
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (if !start < HxString.length s then ignore (HxArray.push out (HxString.substr s (!start) (-1))) else ());
  out
)

let parseDirectiveLine = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let i = ref 0 in (
    ignore (try while true do try ignore (let tempRight = ref false in (
      ignore (let c = let __nullable_int_31 = HxString.charCodeAt line (!i) in if __nullable_int_31 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_31 in let __assign_32 = c = 9 || c = 32 in (
        tempRight := __assign_32;
        __assign_32
      ));
      ignore (if not (!i < HxString.length line && !tempRight) then raise (HxRuntime.Hx_break) else ());
      let __old_33 = !i in let __new_34 = HxInt.add __old_33 1 in (
        ignore (i := __new_34);
        __old_33
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if !i >= HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if not (let __nullable_35 = HxString.charCodeAt line (!i) in if __nullable_35 == HxRuntime.hx_null then false else Obj.obj __nullable_35 = 35) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (let __old_36 = !i in let __new_37 = HxInt.add __old_36 1 in (
      ignore (i := __new_37);
      __old_36
    ));
    ignore (try while true do try ignore (let tempRight1 = ref false in (
      ignore (let c = let __nullable_int_38 = HxString.charCodeAt line (!i) in if __nullable_int_38 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_38 in let __assign_39 = c = 9 || c = 32 in (
        tempRight1 := __assign_39;
        __assign_39
      ));
      ignore (if not (!i < HxString.length line && !tempRight1) then raise (HxRuntime.Hx_break) else ());
      let __old_40 = !i in let __new_41 = HxInt.add __old_40 1 in (
        ignore (i := __new_41);
        __old_40
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    let rest = HxString.substr line (!i) (-1) in (
      ignore (if HxString.indexOf rest "#" 0 <> -1 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_42 = HxAnon.create () in (
        ignore (HxAnon.set __anon_42 "kind" (Obj.repr "opaque"));
        ignore (HxAnon.set __anon_42 "expr" (Obj.repr ""));
        __anon_42
      )))) else ());
      let trimmed = StringTools.trim rest in (
        ignore (if StringTools.startsWith trimmed "if " then raise (HxRuntime.Hx_return (Obj.repr (let __anon_43 = HxAnon.create () in (
          ignore (HxAnon.set __anon_43 "kind" (Obj.repr "if"));
          ignore (HxAnon.set __anon_43 "expr" (Obj.repr (StringTools.trim (HxString.substr trimmed 3 (-1)))));
          __anon_43
        )))) else ());
        ignore (if StringTools.startsWith trimmed "elseif " then raise (HxRuntime.Hx_return (Obj.repr (let __anon_44 = HxAnon.create () in (
          ignore (HxAnon.set __anon_44 "kind" (Obj.repr "elseif"));
          ignore (HxAnon.set __anon_44 "expr" (Obj.repr (StringTools.trim (HxString.substr trimmed 7 (-1)))));
          __anon_44
        )))) else ());
        ignore (if HxString.equals trimmed "else" then raise (HxRuntime.Hx_return (Obj.repr (let __anon_45 = HxAnon.create () in (
          ignore (HxAnon.set __anon_45 "kind" (Obj.repr "else"));
          ignore (HxAnon.set __anon_45 "expr" (Obj.repr ""));
          __anon_45
        )))) else ());
        ignore (if HxString.equals trimmed "end" then raise (HxRuntime.Hx_return (Obj.repr (let __anon_46 = HxAnon.create () in (
          ignore (HxAnon.set __anon_46 "kind" (Obj.repr "end"));
          ignore (HxAnon.set __anon_46 "expr" (Obj.repr ""));
          __anon_46
        )))) else ());
        Obj.magic (HxRuntime.hx_null)
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_47 -> Obj.obj __ret_47

let evalExpr = fun expr defines -> let tempString = ref "" in (
  ignore (if expr == Obj.magic (HxRuntime.hx_null) then let __assign_48 = "" in (
    tempString := __assign_48;
    __assign_48
  ) else let __assign_49 = expr in (
    tempString := __assign_49;
    __assign_49
  ));
  let p = exprparser_create (!tempString) defines in exprparser_parse p ()
)

let filterSource = fun source defines -> try (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr source)) else ());
  let lines = splitLinesPreserveNewlines source in let out = StringBuf.create () in let stack = HxArray.create () in let currentActive = ref true in let _g = ref 0 in (
    ignore (try while !_g < HxArray.length lines do try ignore (let line = HxArray.get lines (!_g) in (
      ignore (let __old_9 = !_g in let __new_10 = HxInt.add __old_9 1 in (
        ignore (_g := __new_10);
        __new_10
      ));
      let directive = parseDirectiveLine line in (
        ignore (if directive == Obj.magic (HxRuntime.hx_null) then ignore (let tempString = ref "" in (
          ignore (if !currentActive then let __assign_11 = line in (
            tempString := __assign_11;
            __assign_11
          ) else let __assign_12 = makeBlankLineLike line in (
            tempString := __assign_12;
            __assign_12
          ));
          ignore (StringBuf.add out (Obj.repr (!tempString)));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (StringBuf.add out (Obj.repr (makeBlankLineLike line)));
        let tempBool = ref false in (
          ignore (if HxArray.length stack = 0 then let __assign_13 = true in (
            tempBool := __assign_13;
            __assign_13
          ) else let __assign_14 = Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "parentActive") && Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "branchActive") in (
            tempBool := __assign_14;
            __assign_14
          ));
          let outerActive = !tempBool in (
            ignore (let _g2 = Obj.obj (HxAnon.get directive "kind") in match _g2 with
              | "else" -> ignore (if HxArray.length stack = 0 then ignore () else ignore (let top = HxArray.get stack (HxInt.sub (HxArray.length stack) 1) in (
                ignore (let __assign_15 = Obj.obj (HxAnon.get top "parentActive") && not (Obj.obj (HxAnon.get top "seenTrue")) in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_15);
                  __assign_15
                ));
                ignore (let __assign_16 = true in (
                  HxAnon.set top "seenTrue" (Obj.repr __assign_16);
                  __assign_16
                ));
                let __assign_17 = top in HxArray.set stack (HxInt.sub (HxArray.length stack) 1) __assign_17
              )))
              | "elseif" -> ignore (if HxArray.length stack = 0 then ignore () else ignore (let top = HxArray.get stack (HxInt.sub (HxArray.length stack) 1) in (
                ignore (if not (Obj.obj (HxAnon.get top "parentActive")) then ignore (let __assign_18 = false in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_18);
                  __assign_18
                )) else ignore (if Obj.obj (HxAnon.get top "seenTrue") then ignore (let __assign_19 = false in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_19);
                  __assign_19
                )) else ignore (let cond = evalExpr (Obj.obj (HxAnon.get directive "expr")) defines in (
                  ignore (let __assign_20 = cond in (
                    HxAnon.set top "branchActive" (Obj.repr __assign_20);
                    __assign_20
                  ));
                  if cond then ignore (let __assign_21 = true in (
                    HxAnon.set top "seenTrue" (Obj.repr __assign_21);
                    __assign_21
                  )) else ()
                ))));
                let __assign_22 = top in HxArray.set stack (HxInt.sub (HxArray.length stack) 1) __assign_22
              )))
              | "end" -> ignore (if HxArray.length stack > 0 then ignore (HxArray.pop stack ()) else ())
              | "if" -> ignore (let cond = outerActive && evalExpr (Obj.obj (HxAnon.get directive "expr")) defines in HxArray.push stack (let __anon_23 = HxAnon.create () in (
                ignore (HxAnon.set __anon_23 "parentActive" (Obj.repr outerActive));
                ignore (HxAnon.set __anon_23 "branchActive" (Obj.repr cond));
                ignore (HxAnon.set __anon_23 "seenTrue" (Obj.repr cond));
                __anon_23
              )))
              | _ -> ignore ());
            ignore (let __assign_24 = true in (
              currentActive := __assign_24;
              __assign_24
            ));
            let _g2 = ref 0 in try while !_g2 < HxArray.length stack do try ignore (let f = HxArray.get stack (!_g2) in (
              ignore (let __old_25 = !_g2 in let __new_26 = HxInt.add __old_25 1 in (
                ignore (_g2 := __new_26);
                __new_26
              ));
              if not (Obj.obj (HxAnon.get f "parentActive")) || not (Obj.obj (HxAnon.get f "branchActive")) then ignore ((
                ignore (let __assign_27 = false in (
                  currentActive := __assign_27;
                  __assign_27
                ));
                raise (HxRuntime.Hx_break)
              )) else ()
            )) with
              | HxRuntime.Hx_continue -> () done with
              | HxRuntime.Hx_break -> ()
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    StringBuf.toString out ()
  )
) with
  | HxRuntime.Hx_return __ret_28 -> Obj.obj __ret_28
# 1 "HxConditionalCompilation.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe enum: _HxConditionalCompilation.Token *)

type token =
| TIdent of string
| TString of string
| TNot
| TAnd
| TOr
| TLParen
| TRParen
| TEq
| TNeq
| TEof

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: _HxConditionalCompilation.ExprLexer *)

let __reflaxe_ocaml__ = ()

type exprlexer_t = { __hx_type : Obj.t; mutable s : string; mutable i : int }

let exprlexer_create = fun s2 -> let self = ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprLexer"; s = ""; i = 0 } : exprlexer_t) in (
  ignore ((
    ignore (let __assign_1 = 0 in (
      self.i <- __assign_1;
      __assign_1
    ));
    let tempRight = ref "" in (
      ignore (if s2 == Obj.magic (HxRuntime.hx_null) then let __assign_2 = "" in (
        tempRight := __assign_2;
        __assign_2
      ) else let __assign_3 = s2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      let __assign_4 = !tempRight in (
        self.s <- __assign_4;
        __assign_4
      )
    )
  ));
  self
)

let exprlexer___empty = fun () -> ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprLexer"; s = ""; i = 0 } : exprlexer_t)

let exprlexer_eof = fun self () -> self.i >= HxString.length (self.s)

let exprlexer_peek = fun self (off : int) -> let j = HxInt.add (self.i) off in let tempResult = ref 0 in (
  ignore (if j >= HxString.length (self.s) then let __assign_5 = -1 in (
    tempResult := __assign_5;
    __assign_5
  ) else let __assign_6 = let __nullable_int_7 = HxString.charCodeAt (self.s) j in if __nullable_int_7 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_7 in (
    tempResult := __assign_6;
    __assign_6
  ));
  !tempResult
)

let exprlexer_bump = fun self () -> let tempResult = ref 0 in (
  ignore (if self.i >= HxString.length (self.s) then let __assign_8 = -1 in (
    tempResult := __assign_8;
    __assign_8
  ) else let __assign_9 = let __nullable_int_13 = HxString.charCodeAt (self.s) (let __obj_10 = self in let __old_11 = __obj_10.i in let __new_12 = HxInt.add __old_11 1 in (
    ignore (__obj_10.i <- __new_12);
    __old_11
  )) in if __nullable_int_13 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_13 in (
    tempResult := __assign_9;
    __assign_9
  ));
  !tempResult
)

let exprlexer_isWs = fun self (c : int) -> (
  ignore self;
  c = 9 || c = 10 || c = 13 || c = 32
)

let exprlexer_isIdentStart = fun self (c : int) -> (
  ignore self;
  c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95
)

let exprlexer_isIdentCont = fun self (c : int) -> (
  ignore self;
  c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 || c >= 48 && c <= 57
)

let exprlexer_skipWs = fun self () -> ignore (try while true do try ignore (let tempNumber = ref 0 in let off = 0 in let j = HxInt.add (self.i) off in (
  ignore (if j >= HxString.length (self.s) then let __assign_14 = -1 in (
    tempNumber := __assign_14;
    __assign_14
  ) else let __assign_15 = let __nullable_int_16 = HxString.charCodeAt (self.s) j in if __nullable_int_16 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_16 in (
    tempNumber := __assign_15;
    __assign_15
  ));
  let c = !tempNumber in let tempRight = c = 9 || c = 10 || c = 13 || c = 32 in (
    ignore (if not (self.i < HxString.length (self.s) && tempRight) then raise (HxRuntime.Hx_break) else ());
    let __obj_17 = self in let __old_18 = __obj_17.i in let __new_19 = HxInt.add __old_18 1 in (
      ignore (__obj_17.i <- __new_19);
      __old_18
    )
  )
)) with
  | HxRuntime.Hx_continue -> () done with
  | HxRuntime.Hx_break -> ())

let exprlexer_readIdent = fun self () -> let start = self.i in (
  ignore (if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_20 = self in let __old_21 = __obj_20.i in let __new_22 = HxInt.add __old_21 1 in (
    ignore (__obj_20.i <- __new_22);
    __old_21
  ))));
  ignore (try while true do try ignore (let tempNumber = ref 0 in let off = 0 in let j = HxInt.add (self.i) off in (
    ignore (if j >= HxString.length (self.s) then let __assign_23 = -1 in (
      tempNumber := __assign_23;
      __assign_23
    ) else let __assign_24 = let __nullable_int_25 = HxString.charCodeAt (self.s) j in if __nullable_int_25 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_25 in (
      tempNumber := __assign_24;
      __assign_24
    ));
    let c = !tempNumber in let tempRight = c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 || c >= 48 && c <= 57 in (
      ignore (if not (self.i < HxString.length (self.s) && tempRight) then raise (HxRuntime.Hx_break) else ());
      if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_26 = self in let __old_27 = __obj_26.i in let __new_28 = HxInt.add __old_27 1 in (
        ignore (__obj_26.i <- __new_28);
        __old_27
      )))
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  HxString.substr (self.s) start (HxInt.sub (self.i) start)
)

let exprlexer_readString = fun self (q : int) -> try (
  ignore (if self.i >= HxString.length (self.s) then -1 else HxRuntime.nullable_int_unwrap (HxString.charCodeAt (self.s) (let __obj_29 = self in let __old_30 = __obj_29.i in let __new_31 = HxInt.add __old_30 1 in (
    ignore (__obj_29.i <- __new_31);
    __old_30
  ))));
  let b = StringBuf.create () in (
    ignore (try while self.i < HxString.length (self.s) do try ignore (let tempNumber = ref 0 in (
      ignore (if self.i >= HxString.length (self.s) then let __assign_32 = -1 in (
        tempNumber := __assign_32;
        __assign_32
      ) else let __assign_33 = let __nullable_int_37 = HxString.charCodeAt (self.s) (let __obj_34 = self in let __old_35 = __obj_34.i in let __new_36 = HxInt.add __old_35 1 in (
        ignore (__obj_34.i <- __new_36);
        __old_35
      )) in if __nullable_int_37 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_37 in (
        tempNumber := __assign_33;
        __assign_33
      ));
      let c = !tempNumber in (
        ignore (if c = q then raise (HxRuntime.Hx_return (Obj.repr (StringBuf.toString b ()))) else ());
        ignore (if c = 92 && self.i < HxString.length (self.s) then ignore (let tempNumber1 = ref 0 in (
          ignore (if self.i >= HxString.length (self.s) then let __assign_38 = -1 in (
            tempNumber1 := __assign_38;
            __assign_38
          ) else let __assign_39 = let __nullable_int_43 = HxString.charCodeAt (self.s) (let __obj_40 = self in let __old_41 = __obj_40.i in let __new_42 = HxInt.add __old_41 1 in (
            ignore (__obj_40.i <- __new_42);
            __old_41
          )) in if __nullable_int_43 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_43 in (
            tempNumber1 := __assign_39;
            __assign_39
          ));
          let esc = !tempNumber1 in (
            ignore (match esc with
              | 34 -> ignore (StringBuf.addChar b 34)
              | 39 -> ignore (StringBuf.addChar b 39)
              | 92 -> ignore (StringBuf.addChar b 92)
              | 110 -> ignore (StringBuf.addChar b 10)
              | 114 -> ignore (StringBuf.addChar b 13)
              | 116 -> ignore (StringBuf.addChar b 9)
              | _ -> ignore (StringBuf.addChar b esc));
            raise (HxRuntime.Hx_continue)
          )
        )) else ());
        StringBuf.addChar b c
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    StringBuf.toString b ()
  )
) with
  | HxRuntime.Hx_return __ret_44 -> Obj.obj __ret_44

let rec exprlexer_next = fun self () -> try (
  ignore (exprlexer_skipWs self ());
  ignore (if self.i >= HxString.length (self.s) then raise (HxRuntime.Hx_return (Obj.repr TEof)) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let tempNumber = ref 0 in (
      ignore (let off = 0 in let j = HxInt.add (self.i) off in if j >= HxString.length (self.s) then let __assign_45 = -1 in (
        tempNumber := __assign_45;
        __assign_45
      ) else let __assign_46 = let __nullable_int_47 = HxString.charCodeAt (self.s) j in if __nullable_int_47 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_47 in (
        tempNumber := __assign_46;
        __assign_46
      ));
      let _g = !tempNumber in match _g with
        | 33 -> let tempLeft = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_53 = -1 in (
            tempLeft := __assign_53;
            __assign_53
          ) else let __assign_54 = let __nullable_int_55 = HxString.charCodeAt (self.s) j in if __nullable_int_55 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_55 in (
            tempLeft := __assign_54;
            __assign_54
          ));
          if !tempLeft = 61 then (
            ignore (let __recv_56 = self in __recv_56.i <- HxInt.add (__recv_56.i) 2);
            let __assign_57 = TNeq in (
              tempResult := __assign_57;
              __assign_57
            )
          ) else (
            ignore (let __obj_58 = self in let __old_59 = __obj_58.i in let __new_60 = HxInt.add __old_59 1 in (
              ignore (__obj_58.i <- __new_60);
              __old_59
            ));
            let __assign_61 = TNot in (
              tempResult := __assign_61;
              __assign_61
            )
          )
        )
        | 38 -> let tempLeft1 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_62 = -1 in (
            tempLeft1 := __assign_62;
            __assign_62
          ) else let __assign_63 = let __nullable_int_64 = HxString.charCodeAt (self.s) j in if __nullable_int_64 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_64 in (
            tempLeft1 := __assign_63;
            __assign_63
          ));
          if !tempLeft1 = 38 then (
            ignore (let __recv_65 = self in __recv_65.i <- HxInt.add (__recv_65.i) 2);
            let __assign_66 = TAnd in (
              tempResult := __assign_66;
              __assign_66
            )
          ) else (
            ignore (let __obj_67 = self in let __old_68 = __obj_67.i in let __new_69 = HxInt.add __old_68 1 in (
              ignore (__obj_67.i <- __new_69);
              __old_68
            ));
            let __assign_70 = TEof in (
              tempResult := __assign_70;
              __assign_70
            )
          )
        )
        | 34 | 39 -> let tempNumber1 = ref 0 in (
          ignore (let off = 0 in let j = HxInt.add (self.i) off in if j >= HxString.length (self.s) then let __assign_71 = -1 in (
            tempNumber1 := __assign_71;
            __assign_71
          ) else let __assign_72 = let __nullable_int_73 = HxString.charCodeAt (self.s) j in if __nullable_int_73 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_73 in (
            tempNumber1 := __assign_72;
            __assign_72
          ));
          let q = !tempNumber1 in let __assign_74 = TString (exprlexer_readString self q) in (
            tempResult := __assign_74;
            __assign_74
          )
        )
        | 40 -> (
          ignore (let __obj_75 = self in let __old_76 = __obj_75.i in let __new_77 = HxInt.add __old_76 1 in (
            ignore (__obj_75.i <- __new_77);
            __old_76
          ));
          let __assign_78 = TLParen in (
            tempResult := __assign_78;
            __assign_78
          )
        )
        | 41 -> (
          ignore (let __obj_79 = self in let __old_80 = __obj_79.i in let __new_81 = HxInt.add __old_80 1 in (
            ignore (__obj_79.i <- __new_81);
            __old_80
          ));
          let __assign_82 = TRParen in (
            tempResult := __assign_82;
            __assign_82
          )
        )
        | 61 -> let tempLeft2 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_83 = -1 in (
            tempLeft2 := __assign_83;
            __assign_83
          ) else let __assign_84 = let __nullable_int_85 = HxString.charCodeAt (self.s) j in if __nullable_int_85 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_85 in (
            tempLeft2 := __assign_84;
            __assign_84
          ));
          if !tempLeft2 = 61 then (
            ignore (let __recv_86 = self in __recv_86.i <- HxInt.add (__recv_86.i) 2);
            let __assign_87 = TEq in (
              tempResult := __assign_87;
              __assign_87
            )
          ) else (
            ignore (let __obj_88 = self in let __old_89 = __obj_88.i in let __new_90 = HxInt.add __old_89 1 in (
              ignore (__obj_88.i <- __new_90);
              __old_89
            ));
            let __assign_91 = TEof in (
              tempResult := __assign_91;
              __assign_91
            )
          )
        )
        | 124 -> let tempLeft3 = ref 0 in (
          ignore (let j = HxInt.add (self.i) 1 in if j >= HxString.length (self.s) then let __assign_92 = -1 in (
            tempLeft3 := __assign_92;
            __assign_92
          ) else let __assign_93 = let __nullable_int_94 = HxString.charCodeAt (self.s) j in if __nullable_int_94 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_94 in (
            tempLeft3 := __assign_93;
            __assign_93
          ));
          if !tempLeft3 = 124 then (
            ignore (let __recv_95 = self in __recv_95.i <- HxInt.add (__recv_95.i) 2);
            let __assign_96 = TOr in (
              tempResult := __assign_96;
              __assign_96
            )
          ) else (
            ignore (let __obj_97 = self in let __old_98 = __obj_97.i in let __new_99 = HxInt.add __old_98 1 in (
              ignore (__obj_97.i <- __new_99);
              __old_98
            ));
            let __assign_100 = TEof in (
              tempResult := __assign_100;
              __assign_100
            )
          )
        )
        | _ -> let c = _g in if c >= 65 && c <= 90 || c >= 97 && c <= 122 || c = 95 then let __assign_48 = TIdent (exprlexer_readIdent self ()) in (
          tempResult := __assign_48;
          __assign_48
        ) else (
          ignore (let __obj_49 = self in let __old_50 = __obj_49.i in let __new_51 = HxInt.add __old_50 1 in (
            ignore (__obj_49.i <- __new_51);
            __old_50
          ));
          let __assign_52 = exprlexer_next self () in (
            tempResult := __assign_52;
            __assign_52
          )
        )
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_101 -> Obj.obj __ret_101

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: _HxConditionalCompilation.ExprParser *)

let __reflaxe_ocaml__ = ()

type exprparser_t = { __hx_type : Obj.t; mutable lex : exprlexer_t; mutable defines : string HxMap.string_map; mutable cur : token }

let exprparser_create = fun expr defines2 -> let self = ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprParser"; lex = Obj.magic (); defines = Obj.magic (); cur = Obj.magic () } : exprparser_t) in (
  ignore ((
    ignore (let __assign_1 = exprlexer_create expr in (
      self.lex <- __assign_1;
      __assign_1
    ));
    let tempRight = ref (Obj.magic ()) in (
      ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_2 = HxMap.create_string () in (
        tempRight := __assign_2;
        __assign_2
      ) else let __assign_3 = defines2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      ignore (let __assign_4 = !tempRight in (
        self.defines <- __assign_4;
        __assign_4
      ));
      let __assign_5 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_5;
        __assign_5
      )
    )
  ));
  self
)

let exprparser___empty = fun () -> ({ __hx_type = HxType.class_ "_HxConditionalCompilation.ExprParser"; lex = Obj.magic (); defines = Obj.magic (); cur = Obj.magic () } : exprparser_t)

let exprparser_bump = fun self () -> ignore (let __assign_6 = exprlexer_next (self.lex) () in (
  self.cur <- __assign_6;
  __assign_6
))

let exprparser_parseStringLit = fun self () -> let tempResult = ref "" in (
  ignore (let _g = self.cur in match _g with
    | TIdent _p0 -> let _g2 = _p0 in let s = _g2 in (
      ignore (let __assign_42 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_42;
        __assign_42
      ));
      let __assign_43 = s in (
        tempResult := __assign_43;
        __assign_43
      )
    )
    | TString _p0 -> let _g2 = _p0 in let s = _g2 in (
      ignore (let __assign_44 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_44;
        __assign_44
      ));
      let __assign_45 = s in (
        tempResult := __assign_45;
        __assign_45
      )
    )
    | _ -> let __assign_41 = "" in (
      tempResult := __assign_41;
      __assign_41
    ));
  !tempResult
)

let exprparser_definedValue = fun self (name : string) -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let tempResult = ref "" in (
    ignore (if HxMap.exists_string (self.defines) name then let __assign_46 = HxMap.get_string (self.defines) name in (
      tempResult := __assign_46;
      __assign_46
    ) else let __assign_47 = "" in (
      tempResult := __assign_47;
      __assign_47
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_48 -> Obj.obj __ret_48

let exprparser_parseIdentTail = fun self (name : string) -> try let tempRight = ref false in (
  ignore (let _g = self.cur in if (match _g with
    | TIdent _ -> 0
    | TString _ -> 1
    | TNot -> 2
    | TAnd -> 3
    | TOr -> 4
    | TLParen -> 5
    | TRParen -> 6
    | TEq -> 7
    | TNeq -> 8
    | TEof -> 9) = 5 then let __assign_25 = true in (
    tempRight := __assign_25;
    __assign_25
  ) else let __assign_26 = false in (
    tempRight := __assign_26;
    __assign_26
  ));
  ignore (if HxString.equals name "defined" && !tempRight then ignore ((
    ignore (let __assign_27 = exprlexer_next (self.lex) () in (
      self.cur <- __assign_27;
      __assign_27
    ));
    let key = ref "" in (
      ignore (let _g = self.cur in match _g with
        | TIdent _p0 -> ignore (let _g2 = _p0 in let n = _g2 in (
          ignore (let __assign_28 = n in (
            key := __assign_28;
            __assign_28
          ));
          let __assign_29 = exprlexer_next (self.lex) () in (
            self.cur <- __assign_29;
            __assign_29
          )
        ))
        | TString _p0 -> ignore (let _g2 = _p0 in let s = _g2 in (
          ignore (let __assign_30 = s in (
            key := __assign_30;
            __assign_30
          ));
          let __assign_31 = exprlexer_next (self.lex) () in (
            self.cur <- __assign_31;
            __assign_31
          )
        ))
        | _ -> ignore ());
      let tempBool = ref false in (
        ignore (let _g = self.cur in if (match _g with
          | TIdent _ -> 0
          | TString _ -> 1
          | TNot -> 2
          | TAnd -> 3
          | TOr -> 4
          | TLParen -> 5
          | TRParen -> 6
          | TEq -> 7
          | TNeq -> 8
          | TEof -> 9) = 6 then let __assign_32 = true in (
          tempBool := __assign_32;
          __assign_32
        ) else let __assign_33 = false in (
          tempBool := __assign_33;
          __assign_33
        ));
        ignore (if !tempBool then ignore (let __assign_34 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_34;
          __assign_34
        )) else ());
        raise (HxRuntime.Hx_return (Obj.repr (HxString.length (!key) > 0 && HxMap.exists_string (self.defines) (!key))))
      )
    )
  )) else ());
  let tempResult = ref false in (
    ignore (let _g = self.cur in match _g with
      | TEq -> (
        ignore (let __assign_36 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_36;
          __assign_36
        ));
        let lit = exprparser_parseStringLit self () in let __assign_37 = HxString.equals (exprparser_definedValue self name) lit in (
          tempResult := __assign_37;
          __assign_37
        )
      )
      | TNeq -> (
        ignore (let __assign_38 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_38;
          __assign_38
        ));
        let lit = exprparser_parseStringLit self () in let __assign_39 = not (HxString.equals (exprparser_definedValue self name) lit) in (
          tempResult := __assign_39;
          __assign_39
        )
      )
      | _ -> let __assign_35 = HxMap.exists_string (self.defines) name in (
        tempResult := __assign_35;
        __assign_35
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_40 -> Obj.obj __ret_40

let rec exprparser_parseOr = fun self () -> try let left = ref (exprparser_parseAnd self ()) in while true do ignore (let _g = self.cur in if (match _g with
  | TIdent _ -> 0
  | TString _ -> 1
  | TNot -> 2
  | TAnd -> 3
  | TOr -> 4
  | TLParen -> 5
  | TRParen -> 6
  | TEq -> 7
  | TNeq -> 8
  | TEof -> 9) = 4 then ignore ((
  ignore (let __assign_7 = exprlexer_next (self.lex) () in (
    self.cur <- __assign_7;
    __assign_7
  ));
  let __assign_8 = !left || exprparser_parseAnd self () in (
    left := __assign_8;
    __assign_8
  )
)) else raise (HxRuntime.Hx_return (Obj.repr (!left)))) done with
  | HxRuntime.Hx_return __ret_9 -> Obj.obj __ret_9
and exprparser_parseAnd = fun self () -> try let left = ref (exprparser_parseUnary self ()) in while true do ignore (let _g = self.cur in if (match _g with
  | TIdent _ -> 0
  | TString _ -> 1
  | TNot -> 2
  | TAnd -> 3
  | TOr -> 4
  | TLParen -> 5
  | TRParen -> 6
  | TEq -> 7
  | TNeq -> 8
  | TEof -> 9) = 3 then ignore ((
  ignore (let __assign_10 = exprlexer_next (self.lex) () in (
    self.cur <- __assign_10;
    __assign_10
  ));
  let __assign_11 = !left && exprparser_parseUnary self () in (
    left := __assign_11;
    __assign_11
  )
)) else raise (HxRuntime.Hx_return (Obj.repr (!left)))) done with
  | HxRuntime.Hx_return __ret_12 -> Obj.obj __ret_12
and exprparser_parseUnary = fun self () -> let tempResult = ref false in (
  ignore (let _g = self.cur in if (match _g with
    | TIdent _ -> 0
    | TString _ -> 1
    | TNot -> 2
    | TAnd -> 3
    | TOr -> 4
    | TLParen -> 5
    | TRParen -> 6
    | TEq -> 7
    | TNeq -> 8
    | TEof -> 9) = 2 then (
    ignore (let __assign_13 = exprlexer_next (self.lex) () in (
      self.cur <- __assign_13;
      __assign_13
    ));
    let __assign_14 = not (exprparser_parseUnary self ()) in (
      tempResult := __assign_14;
      __assign_14
    )
  ) else let __assign_15 = exprparser_parsePrimary self () in (
    tempResult := __assign_15;
    __assign_15
  ));
  !tempResult
)
and exprparser_parsePrimary = fun self () -> let tempResult = ref false in (
  ignore (let _g = self.cur in match _g with
    | TIdent _p0 -> let _g2 = _p0 in let name = _g2 in (
      ignore (let __assign_18 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_18;
        __assign_18
      ));
      let __assign_19 = exprparser_parseIdentTail self name in (
        tempResult := __assign_19;
        __assign_19
      )
    )
    | TLParen -> (
      ignore (let __assign_20 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_20;
        __assign_20
      ));
      let v = exprparser_parseOr self () in let tempBool = ref false in (
        ignore (let _g2 = self.cur in if (match _g2 with
          | TIdent _ -> 0
          | TString _ -> 1
          | TNot -> 2
          | TAnd -> 3
          | TOr -> 4
          | TLParen -> 5
          | TRParen -> 6
          | TEq -> 7
          | TNeq -> 8
          | TEof -> 9) = 6 then let __assign_21 = true in (
          tempBool := __assign_21;
          __assign_21
        ) else let __assign_22 = false in (
          tempBool := __assign_22;
          __assign_22
        ));
        ignore (if !tempBool then ignore (let __assign_23 = exprlexer_next (self.lex) () in (
          self.cur <- __assign_23;
          __assign_23
        )) else ());
        let __assign_24 = v in (
          tempResult := __assign_24;
          __assign_24
        )
      )
    )
    | _ -> (
      ignore (let __assign_16 = exprlexer_next (self.lex) () in (
        self.cur <- __assign_16;
        __assign_16
      ));
      let __assign_17 = false in (
        tempResult := __assign_17;
        __assign_17
      )
    ));
  !tempResult
)

let exprparser_parse = fun self () -> let v = exprparser_parseOr self () in v

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: HxConditionalCompilation *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "HxConditionalCompilation" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "HxConditionalCompilation" } : t)

let isSpace = fun c -> c = 9 || c = 32

let isLineWs = fun c -> c = 9 || c = 10 || c = 13 || c = 32

let makeBlankLineLike = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) || HxString.length line = 0 then raise (HxRuntime.Hx_return (Obj.repr line)) else ());
  let b = StringBuf.create () in let _g = ref 0 in let _g1 = HxString.length line in (
    ignore (while !_g < _g1 do ignore (let i = let __old_1 = !_g in let __new_2 = HxInt.add __old_1 1 in (
      ignore (_g := __new_2);
      __old_1
    ) in let c = HxString.charCodeAt line i in let tempNumber = ref 0 in (
      ignore (if let __nullable_3 = c in if __nullable_3 == HxRuntime.hx_null then false else Obj.obj __nullable_3 = 10 then let __assign_4 = 10 in (
        tempNumber := __assign_4;
        __assign_4
      ) else if let __nullable_5 = c in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 = 13 then let __assign_6 = 13 in (
        tempNumber := __assign_6;
        __assign_6
      ) else let __assign_7 = 32 in (
        tempNumber := __assign_7;
        __assign_7
      ));
      StringBuf.addChar b (!tempNumber)
    )) done);
    StringBuf.toString b ()
  )
) with
  | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8

let skipStringLiteral = fun line start quote max -> try let i = ref (HxInt.add start 1) in (
  ignore (try while !i < HxString.length line && !i < max do try ignore (let c = HxString.charCodeAt line (!i) in (
    ignore (if let __nullable_84 = c in if __nullable_84 == HxRuntime.hx_null then false else Obj.obj __nullable_84 = 92 then ignore ((
      ignore (i := HxInt.add (!i) 2);
      raise (HxRuntime.Hx_continue)
    )) else ());
    ignore (if let __nullable_85 = c in if __nullable_85 == HxRuntime.hx_null then false else Obj.obj __nullable_85 = quote then raise (HxRuntime.Hx_return (Obj.repr (HxInt.add (!i) 1))) else ());
    let __old_86 = !i in let __new_87 = HxInt.add __old_86 1 in (
      ignore (i := __new_87);
      __old_86
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  !i
) with
  | HxRuntime.Hx_return __ret_88 -> Obj.obj __ret_88

let parseInlineCondEnd = fun line start max -> try let first = HxString.charCodeAt line start in (
  ignore (if let __nullable_66 = first in if __nullable_66 == HxRuntime.hx_null then false else Obj.obj __nullable_66 = 40 then ignore (let depth = ref 0 in let i = ref start in (
    ignore (try while !i < HxString.length line && !i < max do try ignore (let c = HxString.charCodeAt line (!i) in (
      ignore (if let __nullable_67 = c in if __nullable_67 == HxRuntime.hx_null then false else Obj.obj __nullable_67 = 40 then ignore (let __old_68 = !depth in let __new_69 = HxInt.add __old_68 1 in (
        ignore (depth := __new_69);
        __old_68
      )) else ignore (if let __nullable_70 = c in if __nullable_70 == HxRuntime.hx_null then false else Obj.obj __nullable_70 = 41 then ignore ((
        ignore (let __old_71 = !depth in let __new_72 = HxInt.add __old_71 (-1) in (
          ignore (depth := __new_72);
          __old_71
        ));
        if !depth = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxInt.add (!i) 1))) else ()
      )) else ignore (if (let __nullable_73 = c in if __nullable_73 == HxRuntime.hx_null then false else Obj.obj __nullable_73 = 34) || (let __nullable_74 = c in if __nullable_74 == HxRuntime.hx_null then false else Obj.obj __nullable_74 = 39) then ignore ((
        ignore (let __assign_75 = skipStringLiteral line (!i) (let __nullable_int_76 = c in if __nullable_int_76 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_76) max in (
          i := __assign_75;
          __assign_75
        ));
        raise (HxRuntime.Hx_continue)
      )) else ())));
      let __old_77 = !i in let __new_78 = HxInt.add __old_77 1 in (
        ignore (i := __new_78);
        __old_77
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    raise (HxRuntime.Hx_return (Obj.repr (-1)))
  )) else ());
  let i = ref start in (
    ignore (try while true do try ignore (let tempBool = ref false in (
      ignore (let c = let __nullable_int_79 = HxString.charCodeAt line (!i) in if __nullable_int_79 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_79 in let __assign_80 = c = 9 || c = 10 || c = 13 || c = 32 in (
        tempBool := __assign_80;
        __assign_80
      ));
      ignore (if not (!i < HxString.length line && !i < max && not (!tempBool)) then raise (HxRuntime.Hx_break) else ());
      let __old_81 = !i in let __new_82 = HxInt.add __old_81 1 in (
        ignore (i := __new_82);
        __old_81
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    !i
  )
) with
  | HxRuntime.Hx_return __ret_83 -> Obj.obj __ret_83

let findTokenOutsideStrings = fun line token from -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) || token == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  ignore (if HxString.length token = 0 then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let tempNumber = ref 0 in (
    ignore (if from < 0 then let __assign_89 = 0 in (
      tempNumber := __assign_89;
      __assign_89
    ) else let __assign_90 = from in (
      tempNumber := __assign_90;
      __assign_90
    ));
    let i = ref (!tempNumber) in let inQuote = ref 0 in (
      ignore (try while !i <= HxInt.sub (HxString.length line) (HxString.length token) do try ignore (let c = HxString.charCodeAt line (!i) in (
        ignore (if !inQuote <> 0 then ignore ((
          ignore (if let __nullable_91 = c in if __nullable_91 == HxRuntime.hx_null then false else Obj.obj __nullable_91 = 92 then ignore ((
            ignore (i := HxInt.add (!i) 2);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (if let __nullable_92 = c in if __nullable_92 == HxRuntime.hx_null then false else Obj.obj __nullable_92 = !inQuote then ignore (let __assign_93 = 0 in (
            inQuote := __assign_93;
            __assign_93
          )) else ());
          ignore (let __old_94 = !i in let __new_95 = HxInt.add __old_94 1 in (
            ignore (i := __new_95);
            __old_94
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if (let __nullable_96 = c in if __nullable_96 == HxRuntime.hx_null then false else Obj.obj __nullable_96 = 34) || (let __nullable_97 = c in if __nullable_97 == HxRuntime.hx_null then false else Obj.obj __nullable_97 = 39) then ignore ((
          ignore (let __assign_98 = let __nullable_int_99 = c in if __nullable_int_99 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_99 in (
            inQuote := __assign_98;
            __assign_98
          ));
          ignore (let __old_100 = !i in let __new_101 = HxInt.add __old_100 1 in (
            ignore (i := __new_101);
            __old_100
          ));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (if (let __nullable_102 = c in if __nullable_102 == HxRuntime.hx_null then false else Obj.obj __nullable_102 = 47) && HxInt.add (!i) 1 < HxString.length line && (let __nullable_103 = HxString.charCodeAt line (HxInt.add (!i) 1) in if __nullable_103 == HxRuntime.hx_null then false else Obj.obj __nullable_103 = 47) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
        ignore (if HxString.equals (HxString.substr line (!i) (HxString.length token)) token then raise (HxRuntime.Hx_return (Obj.repr (!i))) else ());
        let __old_104 = !i in let __new_105 = HxInt.add __old_104 1 in (
          ignore (i := __new_105);
          __old_104
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      -1
    )
  )
) with
  | HxRuntime.Hx_return __ret_106 -> Obj.obj __ret_106

let splitLinesPreserveNewlines = fun s -> let out = HxArray.create () in let start = ref 0 in let i = ref 0 in (
  ignore (try while !i < HxString.length s do try ignore (let c = HxString.charCodeAt s (!i) in (
    ignore (if let __nullable_107 = c in if __nullable_107 == HxRuntime.hx_null then false else Obj.obj __nullable_107 = 10 then ignore ((
      ignore (HxArray.push out (HxString.substr s (!start) (HxInt.add (HxInt.sub (!i) (!start)) 1)));
      ignore (i := HxInt.add (!i) 1);
      ignore (let __assign_108 = !i in (
        start := __assign_108;
        __assign_108
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    i := HxInt.add (!i) 1
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (if !start < HxString.length s then ignore (HxArray.push out (HxString.substr s (!start) (-1))) else ());
  out
)

let parseDirectiveLine = fun line -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let i = ref 0 in (
    ignore (try while true do try ignore (let tempRight = ref false in (
      ignore (let c = let __nullable_int_109 = HxString.charCodeAt line (!i) in if __nullable_int_109 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_109 in let __assign_110 = c = 9 || c = 32 in (
        tempRight := __assign_110;
        __assign_110
      ));
      ignore (if not (!i < HxString.length line && !tempRight) then raise (HxRuntime.Hx_break) else ());
      let __old_111 = !i in let __new_112 = HxInt.add __old_111 1 in (
        ignore (i := __new_112);
        __old_111
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if !i >= HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if not (let __nullable_113 = HxString.charCodeAt line (!i) in if __nullable_113 == HxRuntime.hx_null then false else Obj.obj __nullable_113 = 35) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (let __old_114 = !i in let __new_115 = HxInt.add __old_114 1 in (
      ignore (i := __new_115);
      __old_114
    ));
    ignore (try while true do try ignore (let tempRight1 = ref false in (
      ignore (let c = let __nullable_int_116 = HxString.charCodeAt line (!i) in if __nullable_int_116 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_116 in let __assign_117 = c = 9 || c = 32 in (
        tempRight1 := __assign_117;
        __assign_117
      ));
      ignore (if not (!i < HxString.length line && !tempRight1) then raise (HxRuntime.Hx_break) else ());
      let __old_118 = !i in let __new_119 = HxInt.add __old_118 1 in (
        ignore (i := __new_119);
        __old_118
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    let rest = HxString.substr line (!i) (-1) in (
      ignore (if HxString.indexOf rest "#" 0 <> -1 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_120 = HxAnon.create () in (
        ignore (HxAnon.set __anon_120 "kind" (Obj.repr "opaque"));
        ignore (HxAnon.set __anon_120 "expr" (Obj.repr ""));
        __anon_120
      )))) else ());
      let trimmed = StringTools.trim rest in (
        ignore (if StringTools.startsWith trimmed "if " then raise (HxRuntime.Hx_return (Obj.repr (let __anon_121 = HxAnon.create () in (
          ignore (HxAnon.set __anon_121 "kind" (Obj.repr "if"));
          ignore (HxAnon.set __anon_121 "expr" (Obj.repr (StringTools.trim (HxString.substr trimmed 3 (-1)))));
          __anon_121
        )))) else ());
        ignore (if StringTools.startsWith trimmed "elseif " then raise (HxRuntime.Hx_return (Obj.repr (let __anon_122 = HxAnon.create () in (
          ignore (HxAnon.set __anon_122 "kind" (Obj.repr "elseif"));
          ignore (HxAnon.set __anon_122 "expr" (Obj.repr (StringTools.trim (HxString.substr trimmed 7 (-1)))));
          __anon_122
        )))) else ());
        ignore (if HxString.equals trimmed "else" then raise (HxRuntime.Hx_return (Obj.repr (let __anon_123 = HxAnon.create () in (
          ignore (HxAnon.set __anon_123 "kind" (Obj.repr "else"));
          ignore (HxAnon.set __anon_123 "expr" (Obj.repr ""));
          __anon_123
        )))) else ());
        ignore (if HxString.equals trimmed "end" then raise (HxRuntime.Hx_return (Obj.repr (let __anon_124 = HxAnon.create () in (
          ignore (HxAnon.set __anon_124 "kind" (Obj.repr "end"));
          ignore (HxAnon.set __anon_124 "expr" (Obj.repr ""));
          __anon_124
        )))) else ());
        Obj.magic (HxRuntime.hx_null)
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_125 -> Obj.obj __ret_125

let evalExpr = fun expr defines -> let tempString = ref "" in (
  ignore (if expr == Obj.magic (HxRuntime.hx_null) then let __assign_126 = "" in (
    tempString := __assign_126;
    __assign_126
  ) else let __assign_127 = expr in (
    tempString := __assign_127;
    __assign_127
  ));
  let p = exprparser_create (!tempString) defines in exprparser_parse p ()
)

let filterInlineConditionals = fun line defines -> try (
  ignore (if line == Obj.magic (HxRuntime.hx_null) || HxString.length line = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  ignore (if HxString.indexOf line "#if" 0 = -1 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  ignore (if HxString.indexOf line "#end" 0 = -1 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let idxIf = findTokenOutsideStrings line "#if" 0 in (
    ignore (if idxIf < 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let idxEnd = findTokenOutsideStrings line "#end" (HxInt.add idxIf 3) in (
      ignore (if idxEnd < 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      let idxElse = findTokenOutsideStrings line "#else" (HxInt.add idxIf 3) in let elseInRange = idxElse >= 0 && idxElse < idxEnd in let tempNumber = ref 0 in (
        ignore (if elseInRange then let __assign_29 = idxElse in (
          tempNumber := __assign_29;
          __assign_29
        ) else let __assign_30 = -1 in (
          tempNumber := __assign_30;
          __assign_30
        ));
        let idxElse0 = !tempNumber in let condStart = ref (HxInt.add idxIf 3) in (
          ignore (try while true do try ignore (let tempRight = ref false in (
            ignore (let c = let __nullable_int_31 = HxString.charCodeAt line (!condStart) in if __nullable_int_31 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_31 in let __assign_32 = c = 9 || c = 10 || c = 13 || c = 32 in (
              tempRight := __assign_32;
              __assign_32
            ));
            ignore (if not (!condStart < HxString.length line && !tempRight) then raise (HxRuntime.Hx_break) else ());
            let __old_33 = !condStart in let __new_34 = HxInt.add __old_33 1 in (
              ignore (condStart := __new_34);
              __old_33
            )
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ignore (if !condStart >= HxString.length line then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
          let condEnd = parseInlineCondEnd line (!condStart) idxEnd in (
            ignore (if condEnd <= !condStart then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
            let condText = StringTools.trim (HxString.substr line (!condStart) (HxInt.sub condEnd (!condStart))) in let thenStart = condEnd in let tempNumber1 = ref 0 in (
              ignore (if idxElse0 >= 0 then let __assign_35 = idxElse0 in (
                tempNumber1 := __assign_35;
                __assign_35
              ) else let __assign_36 = idxEnd in (
                tempNumber1 := __assign_36;
                __assign_36
              ));
              let thenEnd = !tempNumber1 in let tempNumber2 = ref 0 in (
                ignore (if idxElse0 >= 0 then let __assign_37 = HxInt.add idxElse0 5 in (
                  tempNumber2 := __assign_37;
                  __assign_37
                ) else let __assign_38 = -1 in (
                  tempNumber2 := __assign_38;
                  __assign_38
                ));
                let elseStart = !tempNumber2 in let elseEnd = idxEnd in let takeThen = evalExpr condText defines in let tempNumber3 = ref 0 in (
                  ignore (if takeThen then let __assign_39 = thenStart in (
                    tempNumber3 := __assign_39;
                    __assign_39
                  ) else let __assign_40 = elseStart in (
                    tempNumber3 := __assign_40;
                    __assign_40
                  ));
                  let keepStart = !tempNumber3 in let tempNumber4 = ref 0 in (
                    ignore (if takeThen then let __assign_41 = thenEnd in (
                      tempNumber4 := __assign_41;
                      __assign_41
                    ) else let __assign_42 = elseEnd in (
                      tempNumber4 := __assign_42;
                      __assign_42
                    ));
                    let keepEnd = !tempNumber4 in (
                      ignore (if keepStart < 0 || keepEnd < keepStart then raise (HxRuntime.Hx_return (Obj.repr (makeBlankLineLike line))) else ());
                      let outCodes = HxArray.create () in (
                        ignore (HxArray.resize outCodes (HxString.length line));
                        ignore (let _g = ref 0 in let _g1 = HxString.length line in while !_g < _g1 do ignore (let i = let __old_43 = !_g in let __new_44 = HxInt.add __old_43 1 in (
                          ignore (_g := __new_44);
                          __old_43
                        ) in let c = HxString.charCodeAt line i in let tempRight1 = ref 0 in (
                          ignore (if (let __nullable_45 = c in if __nullable_45 == HxRuntime.hx_null then false else Obj.obj __nullable_45 = 10) || (let __nullable_46 = c in if __nullable_46 == HxRuntime.hx_null then false else Obj.obj __nullable_46 = 13) then let __assign_47 = let __nullable_int_48 = c in if __nullable_int_48 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_48 in (
                            tempRight1 := __assign_47;
                            __assign_47
                          ) else let __assign_49 = 32 in (
                            tempRight1 := __assign_49;
                            __assign_49
                          ));
                          let __assign_50 = !tempRight1 in HxArray.set outCodes i __assign_50
                        )) done);
                        ignore (let i = ref 0 in while !i < idxIf && !i < HxString.length line do ignore ((
                          ignore (let __assign_51 = let __nullable_int_52 = HxString.charCodeAt line (!i) in if __nullable_int_52 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_52 in HxArray.set outCodes (!i) __assign_51);
                          let __old_53 = !i in let __new_54 = HxInt.add __old_53 1 in (
                            ignore (i := __new_54);
                            __old_53
                          )
                        )) done);
                        ignore (let i = ref keepStart in while !i < keepEnd && !i < HxString.length line do ignore ((
                          ignore (let __assign_55 = let __nullable_int_56 = HxString.charCodeAt line (!i) in if __nullable_int_56 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_56 in HxArray.set outCodes (!i) __assign_55);
                          let __old_57 = !i in let __new_58 = HxInt.add __old_57 1 in (
                            ignore (i := __new_58);
                            __old_57
                          )
                        )) done);
                        ignore (let b = HxString.length line in let i = ref (HxInt.add idxEnd 4) in while !i < b && !i < HxString.length line do ignore ((
                          ignore (let __assign_59 = let __nullable_int_60 = HxString.charCodeAt line (!i) in if __nullable_int_60 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_60 in HxArray.set outCodes (!i) __assign_59);
                          let __old_61 = !i in let __new_62 = HxInt.add __old_61 1 in (
                            ignore (i := __new_62);
                            __old_61
                          )
                        )) done);
                        let b = StringBuf.create () in (
                          ignore (let _g = ref 0 in while !_g < HxArray.length outCodes do ignore (let c = HxArray.get outCodes (!_g) in (
                            ignore (let __old_63 = !_g in let __new_64 = HxInt.add __old_63 1 in (
                              ignore (_g := __new_64);
                              __new_64
                            ));
                            StringBuf.addChar b c
                          )) done);
                          StringBuf.toString b ()
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_65 -> Obj.obj __ret_65

let filterSource = fun source defines -> try (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr source)) else ());
  let lines = splitLinesPreserveNewlines source in let out = StringBuf.create () in let stack = HxArray.create () in let currentActive = ref true in let _g = ref 0 in (
    ignore (try while !_g < HxArray.length lines do try ignore (let line = HxArray.get lines (!_g) in (
      ignore (let __old_9 = !_g in let __new_10 = HxInt.add __old_9 1 in (
        ignore (_g := __new_10);
        __new_10
      ));
      let directive = parseDirectiveLine line in (
        ignore (if directive == Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (if not (!currentActive) then ignore ((
            ignore (StringBuf.add out (Obj.repr (makeBlankLineLike line)));
            raise (HxRuntime.Hx_continue)
          )) else ());
          let inlineFiltered = filterInlineConditionals line defines in let tempMaybeString = ref (Obj.magic ()) in (
            ignore (if inlineFiltered == Obj.magic (HxRuntime.hx_null) then let __assign_11 = line in (
              tempMaybeString := __assign_11;
              __assign_11
            ) else let __assign_12 = inlineFiltered in (
              tempMaybeString := __assign_12;
              __assign_12
            ));
            ignore (StringBuf.add out (Obj.repr (!tempMaybeString)));
            raise (HxRuntime.Hx_continue)
          )
        )) else ());
        ignore (StringBuf.add out (Obj.repr (makeBlankLineLike line)));
        let tempBool = ref false in (
          ignore (if HxArray.length stack = 0 then let __assign_13 = true in (
            tempBool := __assign_13;
            __assign_13
          ) else let __assign_14 = Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "parentActive") && Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "branchActive") in (
            tempBool := __assign_14;
            __assign_14
          ));
          let outerActive = !tempBool in (
            ignore (let _g2 = Obj.obj (HxAnon.get directive "kind") in match _g2 with
              | "else" -> ignore (if HxArray.length stack = 0 then ignore () else ignore (let top = HxArray.get stack (HxInt.sub (HxArray.length stack) 1) in (
                ignore (let __assign_15 = Obj.obj (HxAnon.get top "parentActive") && not (Obj.obj (HxAnon.get top "seenTrue")) in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_15);
                  __assign_15
                ));
                ignore (let __assign_16 = true in (
                  HxAnon.set top "seenTrue" (Obj.repr __assign_16);
                  __assign_16
                ));
                let __assign_17 = top in HxArray.set stack (HxInt.sub (HxArray.length stack) 1) __assign_17
              )))
              | "elseif" -> ignore (if HxArray.length stack = 0 then ignore () else ignore (let top = HxArray.get stack (HxInt.sub (HxArray.length stack) 1) in (
                ignore (if not (Obj.obj (HxAnon.get top "parentActive")) then ignore (let __assign_18 = false in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_18);
                  __assign_18
                )) else ignore (if Obj.obj (HxAnon.get top "seenTrue") then ignore (let __assign_19 = false in (
                  HxAnon.set top "branchActive" (Obj.repr __assign_19);
                  __assign_19
                )) else ignore (let cond = evalExpr (Obj.obj (HxAnon.get directive "expr")) defines in (
                  ignore (let __assign_20 = cond in (
                    HxAnon.set top "branchActive" (Obj.repr __assign_20);
                    __assign_20
                  ));
                  if cond then ignore (let __assign_21 = true in (
                    HxAnon.set top "seenTrue" (Obj.repr __assign_21);
                    __assign_21
                  )) else ()
                ))));
                let __assign_22 = top in HxArray.set stack (HxInt.sub (HxArray.length stack) 1) __assign_22
              )))
              | "end" -> ignore (if HxArray.length stack > 0 then ignore (HxArray.pop stack ()) else ())
              | "if" -> ignore (let cond = outerActive && evalExpr (Obj.obj (HxAnon.get directive "expr")) defines in HxArray.push stack (let __anon_23 = HxAnon.create () in (
                ignore (HxAnon.set __anon_23 "parentActive" (Obj.repr outerActive));
                ignore (HxAnon.set __anon_23 "branchActive" (Obj.repr cond));
                ignore (HxAnon.set __anon_23 "seenTrue" (Obj.repr cond));
                __anon_23
              )))
              | _ -> ignore ());
            ignore (let __assign_24 = true in (
              currentActive := __assign_24;
              __assign_24
            ));
            let _g2 = ref 0 in try while !_g2 < HxArray.length stack do try ignore (let f = HxArray.get stack (!_g2) in (
              ignore (let __old_25 = !_g2 in let __new_26 = HxInt.add __old_25 1 in (
                ignore (_g2 := __new_26);
                __new_26
              ));
              if not (Obj.obj (HxAnon.get f "parentActive")) || not (Obj.obj (HxAnon.get f "branchActive")) then ignore ((
                ignore (let __assign_27 = false in (
                  currentActive := __assign_27;
                  __assign_27
                ));
                raise (HxRuntime.Hx_break)
              )) else ()
            )) with
              | HxRuntime.Hx_continue -> () done with
              | HxRuntime.Hx_break -> ()
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    StringBuf.toString out ()
  )
) with
  | HxRuntime.Hx_return __ret_28 -> Obj.obj __ret_28
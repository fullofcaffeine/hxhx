# 1 "sys_io_Process.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io._Process.OcamlProcessInput *)

let __reflaxe_ocaml__ = ()

type ocamlprocessinput_t = { __hx_type : Obj.t; mutable bigEndian : bool; set_bigEndian : Obj.t -> bool -> bool; readByte : Obj.t -> unit -> int; readBytes : Obj.t -> HxBytes.t -> int -> int -> int; close : Obj.t -> unit -> unit; readAll : Obj.t -> Obj.t -> HxBytes.t; readFullBytes : Obj.t -> HxBytes.t -> int -> int -> unit; read : Obj.t -> int -> HxBytes.t; readUntil : Obj.t -> int -> string; readLine : Obj.t -> unit -> string; readFloat : Obj.t -> unit -> float; readDouble : Obj.t -> unit -> float; readInt8 : Obj.t -> unit -> int; readInt16 : Obj.t -> unit -> int; readUInt16 : Obj.t -> unit -> int; readInt24 : Obj.t -> unit -> int; readUInt24 : Obj.t -> unit -> int; readInt32 : Obj.t -> unit -> int; readString : Obj.t -> int -> Obj.t -> string; mutable handle : int; mutable stream : int }

let ocamlprocessinput___ctor = fun (self : ocamlprocessinput_t) handle2 stream2 -> ignore ((
  ignore (let __assign_1 = handle2 in (
    self.handle <- __assign_1;
    __assign_1
  ));
  let __assign_2 = stream2 in (
    self.stream <- __assign_2;
    __assign_2
  )
))

let ocamlprocessinput_readByte__impl = fun (self : ocamlprocessinput_t) () -> let b = HxProcess.read_byte (self.handle) (self.stream) in (
  ignore (if b < 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ());
  b
)

let ocamlprocessinput_readBytes__impl = fun (self : ocamlprocessinput_t) (buf : HxBytes.t) (pos : int) (len : int) -> try (
  ignore (if len <= 0 then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let i = ref 0 in (
    ignore (try while !i < len do ignore ((
      ignore (HxBytes.set buf (HxInt.add pos (!i)) (self.readByte (Obj.magic self) ()));
      let __old_3 = !i in let __new_4 = HxInt.add __old_3 1 in (
        ignore (i := __new_4);
        __old_3
      )
    )) done with
      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
      | HxRuntime.Hx_return __ret_5 -> raise (HxRuntime.Hx_return __ret_5)
      | HxRuntime.Hx_exception (__exn_v_6, __exn_tags_7) -> if HxRuntime.tags_has __exn_tags_7 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_6 : Haxe_io_Eof.t) in (
        ignore _hx;
        if !i = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ()
      ) else HxRuntime.hx_throw_typed __exn_v_6 __exn_tags_7
      | __exn_8 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_8) : Haxe_io_Eof.t) in (
        ignore _hx;
        if !i = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ()
      ) else raise (__exn_8));
    !i
  )
) with
  | HxRuntime.Hx_return __ret_9 -> Obj.obj __ret_9

let ocamlprocessinput_readLine__impl = fun (self : ocamlprocessinput_t) () -> let s = HxProcess.read_line (self.handle) (self.stream) in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ());
  s
)

let ocamlprocessinput_create = fun handle2 stream2 -> let self = ({ __hx_type = HxType.class_ "sys.io._Process.OcamlProcessInput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Input.set_bigEndian__impl (Obj.magic o) a0); readByte = (fun o () -> ocamlprocessinput_readByte__impl (Obj.magic o) ()); readBytes = (fun o a0 a1 a2 -> ocamlprocessinput_readBytes__impl (Obj.magic o) a0 a1 a2); close = (fun o () -> Haxe_io_Input.close__impl (Obj.magic o) ()); readAll = (fun o a0 -> Haxe_io_Input.readAll__impl (Obj.magic o) a0); readFullBytes = (fun o a0 a1 a2 -> Haxe_io_Input.readFullBytes__impl (Obj.magic o) a0 a1 a2); read = (fun o a0 -> Haxe_io_Input.read__impl (Obj.magic o) a0); readUntil = (fun o a0 -> Haxe_io_Input.readUntil__impl (Obj.magic o) a0); readLine = (fun o () -> ocamlprocessinput_readLine__impl (Obj.magic o) ()); readFloat = (fun o () -> Haxe_io_Input.readFloat__impl (Obj.magic o) ()); readDouble = (fun o () -> Haxe_io_Input.readDouble__impl (Obj.magic o) ()); readInt8 = (fun o () -> Haxe_io_Input.readInt8__impl (Obj.magic o) ()); readInt16 = (fun o () -> Haxe_io_Input.readInt16__impl (Obj.magic o) ()); readUInt16 = (fun o () -> Haxe_io_Input.readUInt16__impl (Obj.magic o) ()); readInt24 = (fun o () -> Haxe_io_Input.readInt24__impl (Obj.magic o) ()); readUInt24 = (fun o () -> Haxe_io_Input.readUInt24__impl (Obj.magic o) ()); readInt32 = (fun o () -> Haxe_io_Input.readInt32__impl (Obj.magic o) ()); readString = (fun o a0 a1 -> Haxe_io_Input.readString__impl (Obj.magic o) a0 a1); handle = 0; stream = 0 } : ocamlprocessinput_t) in (
  ignore ((
    ignore (let __assign_1 = handle2 in (
      self.handle <- __assign_1;
      __assign_1
    ));
    let __assign_2 = stream2 in (
      self.stream <- __assign_2;
      __assign_2
    )
  ));
  self
)

let ocamlprocessinput___empty = fun () -> ({ __hx_type = HxType.class_ "sys.io._Process.OcamlProcessInput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Input.set_bigEndian__impl (Obj.magic o) a0); readByte = (fun o () -> ocamlprocessinput_readByte__impl (Obj.magic o) ()); readBytes = (fun o a0 a1 a2 -> ocamlprocessinput_readBytes__impl (Obj.magic o) a0 a1 a2); close = (fun o () -> Haxe_io_Input.close__impl (Obj.magic o) ()); readAll = (fun o a0 -> Haxe_io_Input.readAll__impl (Obj.magic o) a0); readFullBytes = (fun o a0 a1 a2 -> Haxe_io_Input.readFullBytes__impl (Obj.magic o) a0 a1 a2); read = (fun o a0 -> Haxe_io_Input.read__impl (Obj.magic o) a0); readUntil = (fun o a0 -> Haxe_io_Input.readUntil__impl (Obj.magic o) a0); readLine = (fun o () -> ocamlprocessinput_readLine__impl (Obj.magic o) ()); readFloat = (fun o () -> Haxe_io_Input.readFloat__impl (Obj.magic o) ()); readDouble = (fun o () -> Haxe_io_Input.readDouble__impl (Obj.magic o) ()); readInt8 = (fun o () -> Haxe_io_Input.readInt8__impl (Obj.magic o) ()); readInt16 = (fun o () -> Haxe_io_Input.readInt16__impl (Obj.magic o) ()); readUInt16 = (fun o () -> Haxe_io_Input.readUInt16__impl (Obj.magic o) ()); readInt24 = (fun o () -> Haxe_io_Input.readInt24__impl (Obj.magic o) ()); readUInt24 = (fun o () -> Haxe_io_Input.readUInt24__impl (Obj.magic o) ()); readInt32 = (fun o () -> Haxe_io_Input.readInt32__impl (Obj.magic o) ()); readString = (fun o a0 a1 -> Haxe_io_Input.readString__impl (Obj.magic o) a0 a1); handle = 0; stream = 0 } : ocamlprocessinput_t)

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io._Process.OcamlProcessOutput *)

let __reflaxe_ocaml__ = ()

type ocamlprocessoutput_t = { __hx_type : Obj.t; mutable bigEndian : bool; set_bigEndian : Obj.t -> bool -> bool; writeByte : Obj.t -> int -> unit; writeBytes : Obj.t -> HxBytes.t -> int -> int -> int; flush : Obj.t -> unit -> unit; close : Obj.t -> unit -> unit; write : Obj.t -> HxBytes.t -> unit; writeFullBytes : Obj.t -> HxBytes.t -> int -> int -> unit; prepare : Obj.t -> int -> unit; writeInput : Obj.t -> Haxe_io_Input.t -> Obj.t -> unit; writeString : Obj.t -> string -> Obj.t -> unit; writeFloat : Obj.t -> float -> unit; writeDouble : Obj.t -> float -> unit; writeInt8 : Obj.t -> int -> unit; writeUInt8 : Obj.t -> int -> unit; writeInt16 : Obj.t -> int -> unit; writeUInt16 : Obj.t -> int -> unit; writeInt24 : Obj.t -> int -> unit; writeUInt24 : Obj.t -> int -> unit; writeInt32 : Obj.t -> int -> unit; mutable handle : int }

let ocamlprocessoutput___ctor = fun (self : ocamlprocessoutput_t) handle2 -> ignore (let __assign_1 = handle2 in (
  self.handle <- __assign_1;
  __assign_1
))

let ocamlprocessoutput_writeByte__impl = fun (self : ocamlprocessoutput_t) (c : int) -> ignore (HxProcess.write_byte (self.handle) c)

let ocamlprocessoutput_writeBytes__impl = fun (self : ocamlprocessoutput_t) (buf : HxBytes.t) (pos : int) (len : int) -> try (
  ignore (if len <= 0 then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let _g = ref 0 in let _g1 = len in (
    ignore (while !_g < _g1 do ignore (let i = let __old_2 = !_g in let __new_3 = HxInt.add __old_2 1 in (
      ignore (_g := __new_3);
      __old_2
    ) in self.writeByte (Obj.magic self) (HxBytes.get buf (HxInt.add pos i))) done);
    len
  )
) with
  | HxRuntime.Hx_return __ret_4 -> Obj.obj __ret_4

let ocamlprocessoutput_writeString__impl = fun (self : ocamlprocessoutput_t) (s : string) (encoding : Obj.t) -> ignore (try (
  ignore (if encoding != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if s == Obj.magic (HxRuntime.hx_null) || HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  HxProcess.write_string (self.handle) s
) with
  | HxRuntime.Hx_return __ret_5 -> Obj.obj __ret_5)

let ocamlprocessoutput_flush__impl = fun (self : ocamlprocessoutput_t) () -> ignore (HxProcess.flush_stdin (self.handle))

let ocamlprocessoutput_create = fun handle2 -> let self = ({ __hx_type = HxType.class_ "sys.io._Process.OcamlProcessOutput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Output.set_bigEndian__impl (Obj.magic o) a0); writeByte = (fun o a0 -> ocamlprocessoutput_writeByte__impl (Obj.magic o) a0); writeBytes = (fun o a0 a1 a2 -> ocamlprocessoutput_writeBytes__impl (Obj.magic o) a0 a1 a2); flush = (fun o () -> ocamlprocessoutput_flush__impl (Obj.magic o) ()); close = (fun o () -> Haxe_io_Output.close__impl (Obj.magic o) ()); write = (fun o a0 -> Haxe_io_Output.write__impl (Obj.magic o) a0); writeFullBytes = (fun o a0 a1 a2 -> Haxe_io_Output.writeFullBytes__impl (Obj.magic o) a0 a1 a2); prepare = (fun o a0 -> Haxe_io_Output.prepare__impl (Obj.magic o) a0); writeInput = (fun o a0 a1 -> Haxe_io_Output.writeInput__impl (Obj.magic o) a0 a1); writeString = (fun o a0 a1 -> ocamlprocessoutput_writeString__impl (Obj.magic o) a0 a1); writeFloat = (fun o a0 -> Haxe_io_Output.writeFloat__impl (Obj.magic o) a0); writeDouble = (fun o a0 -> Haxe_io_Output.writeDouble__impl (Obj.magic o) a0); writeInt8 = (fun o a0 -> Haxe_io_Output.writeInt8__impl (Obj.magic o) a0); writeUInt8 = (fun o a0 -> Haxe_io_Output.writeUInt8__impl (Obj.magic o) a0); writeInt16 = (fun o a0 -> Haxe_io_Output.writeInt16__impl (Obj.magic o) a0); writeUInt16 = (fun o a0 -> Haxe_io_Output.writeUInt16__impl (Obj.magic o) a0); writeInt24 = (fun o a0 -> Haxe_io_Output.writeInt24__impl (Obj.magic o) a0); writeUInt24 = (fun o a0 -> Haxe_io_Output.writeUInt24__impl (Obj.magic o) a0); writeInt32 = (fun o a0 -> Haxe_io_Output.writeInt32__impl (Obj.magic o) a0); handle = 0 } : ocamlprocessoutput_t) in (
  ignore (let __assign_1 = handle2 in (
    self.handle <- __assign_1;
    __assign_1
  ));
  self
)

let ocamlprocessoutput___empty = fun () -> ({ __hx_type = HxType.class_ "sys.io._Process.OcamlProcessOutput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Output.set_bigEndian__impl (Obj.magic o) a0); writeByte = (fun o a0 -> ocamlprocessoutput_writeByte__impl (Obj.magic o) a0); writeBytes = (fun o a0 a1 a2 -> ocamlprocessoutput_writeBytes__impl (Obj.magic o) a0 a1 a2); flush = (fun o () -> ocamlprocessoutput_flush__impl (Obj.magic o) ()); close = (fun o () -> Haxe_io_Output.close__impl (Obj.magic o) ()); write = (fun o a0 -> Haxe_io_Output.write__impl (Obj.magic o) a0); writeFullBytes = (fun o a0 a1 a2 -> Haxe_io_Output.writeFullBytes__impl (Obj.magic o) a0 a1 a2); prepare = (fun o a0 -> Haxe_io_Output.prepare__impl (Obj.magic o) a0); writeInput = (fun o a0 a1 -> Haxe_io_Output.writeInput__impl (Obj.magic o) a0 a1); writeString = (fun o a0 a1 -> ocamlprocessoutput_writeString__impl (Obj.magic o) a0 a1); writeFloat = (fun o a0 -> Haxe_io_Output.writeFloat__impl (Obj.magic o) a0); writeDouble = (fun o a0 -> Haxe_io_Output.writeDouble__impl (Obj.magic o) a0); writeInt8 = (fun o a0 -> Haxe_io_Output.writeInt8__impl (Obj.magic o) a0); writeUInt8 = (fun o a0 -> Haxe_io_Output.writeUInt8__impl (Obj.magic o) a0); writeInt16 = (fun o a0 -> Haxe_io_Output.writeInt16__impl (Obj.magic o) a0); writeUInt16 = (fun o a0 -> Haxe_io_Output.writeUInt16__impl (Obj.magic o) a0); writeInt24 = (fun o a0 -> Haxe_io_Output.writeInt24__impl (Obj.magic o) a0); writeUInt24 = (fun o a0 -> Haxe_io_Output.writeUInt24__impl (Obj.magic o) a0); writeInt32 = (fun o a0 -> Haxe_io_Output.writeInt32__impl (Obj.magic o) a0); handle = 0 } : ocamlprocessoutput_t)

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io.Process *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable stdout : Haxe_io_Input.t; mutable stderr : Haxe_io_Input.t; mutable stdin : Haxe_io_Output.t; mutable handle : int; mutable closed : bool; mutable cachedExitCode : Obj.t }

let create = fun cmd args detached -> let self = ({ __hx_type = HxType.class_ "sys.io.Process"; stdout = Obj.magic (); stderr = Obj.magic (); stdin = Obj.magic (); handle = 0; closed = false; cachedExitCode = HxRuntime.hx_null } : t) in (
  ignore ((
    ignore (let __assign_1 = HxRuntime.hx_null in (
      self.cachedExitCode <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = false in (
      self.closed <- __assign_2;
      __assign_2
    ));
    let tempMaybeArray = ref (Obj.magic ()) in (
      ignore (if args == Obj.magic (HxRuntime.hx_null) then let __assign_3 = let __arr_4 = HxArray.create () in __arr_4 in (
        tempMaybeArray := __assign_3;
        __assign_3
      ) else let __assign_5 = args in (
        tempMaybeArray := __assign_5;
        __assign_5
      ));
      ignore (detached != HxRuntime.hx_null);
      ignore (let __assign_6 = HxProcess.spawn cmd (!tempMaybeArray) in (
        self.handle <- __assign_6;
        __assign_6
      ));
      ignore (let __assign_7 = Obj.magic (ocamlprocessinput_create (self.handle) 1) in (
        self.stdout <- __assign_7;
        __assign_7
      ));
      ignore (let __assign_8 = Obj.magic (ocamlprocessinput_create (self.handle) 2) in (
        self.stderr <- __assign_8;
        __assign_8
      ));
      let __assign_9 = Obj.magic (ocamlprocessoutput_create (self.handle)) in (
        self.stdin <- __assign_9;
        __assign_9
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "sys.io.Process"; stdout = Obj.magic (); stderr = Obj.magic (); stdin = Obj.magic (); handle = 0; closed = false; cachedExitCode = HxRuntime.hx_null } : t)

let getPid = fun self () -> (
  ignore self;
  -1
)

let kill = fun self () -> ignore (try (
  ignore (if self.closed then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  HxProcess.kill (self.handle)
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10)

let close = fun self () -> ignore (try (
  ignore (if self.closed then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (let __assign_11 = Obj.repr (HxProcess.close (self.handle)) in (
    self.cachedExitCode <- __assign_11;
    __assign_11
  ));
  let __assign_12 = true in (
    self.closed <- __assign_12;
    __assign_12
  )
) with
  | HxRuntime.Hx_return __ret_13 -> Obj.obj __ret_13)

let exitCode = fun self () -> try (
  ignore (if self.cachedExitCode != HxRuntime.hx_null then raise (HxRuntime.Hx_return (Obj.repr (self.cachedExitCode))) else ());
  ignore (close self ());
  let tempResult = ref 0 in (
    ignore (if self.cachedExitCode == HxRuntime.hx_null then let __assign_14 = 0 in (
      tempResult := __assign_14;
      __assign_14
    ) else let __assign_15 = let __nullable_int_16 = self.cachedExitCode in if __nullable_int_16 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_16 in (
      tempResult := __assign_15;
      __assign_15
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17
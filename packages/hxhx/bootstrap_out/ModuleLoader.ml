# 1 "ModuleLoader.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: TyperIndexBuild *)

let __reflaxe_ocaml__ = ()

type typerindexbuild_t = { __hx_type : Obj.t }

let typerindexbuild_create = fun () -> let self = ({ __hx_type = HxType.class_ "TyperIndexBuild" } : typerindexbuild_t) in (
  ignore ();
  self
)

let typerindexbuild___empty = fun () -> ({ __hx_type = HxType.class_ "TyperIndexBuild" } : typerindexbuild_t)

let typerindexbuild_classFullName = fun pkg cls -> let tempString = ref "" in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) then let __assign_1 = "" in (
    tempString := __assign_1;
    __assign_1
  ) else let __assign_2 = StringTools.trim pkg in (
    tempString := __assign_2;
    __assign_2
  ));
  let tempResult = ref "" in (
    ignore (if HxString.length (!tempString) = 0 then let __assign_3 = cls in (
      tempResult := __assign_3;
      __assign_3
    ) else let __assign_4 = (HxString.toStdString (!tempString) ^ ".") ^ HxString.toStdString cls in (
      tempResult := __assign_4;
      __assign_4
    ));
    !tempResult
  )
)

let typerindexbuild_expectedModuleNameFromFile = fun filePath -> try (
  ignore (if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let name = Haxe_io_Path.withoutDirectory filePath in let dot = HxString.lastIndexOf name "." (HxString.length name) in let tempResult = ref (Obj.magic ()) in (
    ignore (if dot <= 0 then let __assign_5 = name in (
      tempResult := __assign_5;
      __assign_5
    ) else let __assign_6 = HxString.substr name 0 dot in (
      tempResult := __assign_6;
      __assign_6
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_7 -> Obj.obj __ret_7

let typerindexbuild_classFullNameInModule = fun pkg moduleName clsName -> let tempString = ref "" in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) then let __assign_8 = "" in (
    tempString := __assign_8;
    __assign_8
  ) else let __assign_9 = StringTools.trim pkg in (
    tempString := __assign_9;
    __assign_9
  ));
  let tempString1 = ref "" in (
    ignore (if moduleName == Obj.magic (HxRuntime.hx_null) then let __assign_10 = "" in (
      tempString1 := __assign_10;
      __assign_10
    ) else let __assign_11 = StringTools.trim moduleName in (
      tempString1 := __assign_11;
      __assign_11
    ));
    let tempString2 = ref "" in (
      ignore (if HxString.length (!tempString1) = 0 || HxString.equals (!tempString1) "Unknown" then let __assign_12 = "" in (
        tempString2 := __assign_12;
        __assign_12
      ) else let __assign_13 = !tempString1 in (
        tempString2 := __assign_13;
        __assign_13
      ));
      let tempString3 = ref "" in (
        ignore (if clsName == Obj.magic (HxRuntime.hx_null) then let __assign_14 = "" in (
          tempString3 := __assign_14;
          __assign_14
        ) else let __assign_15 = StringTools.trim clsName in (
          tempString3 := __assign_15;
          __assign_15
        ));
        ignore (if HxString.length (!tempString2) > 0 && HxString.length (!tempString3) > 0 && not (HxString.equals (!tempString3) (!tempString2)) then ignore (let tempRight = ref "" in (
          ignore (if HxString.length (!tempString) = 0 then let __assign_16 = !tempString2 in (
            tempRight := __assign_16;
            __assign_16
          ) else let __assign_17 = (HxString.toStdString (!tempString) ^ ".") ^ HxString.toStdString (!tempString2) in (
            tempRight := __assign_17;
            __assign_17
          ));
          let __assign_18 = !tempRight in (
            tempString := __assign_18;
            __assign_18
          )
        )) else ());
        let tempResult = ref "" in (
          ignore (if HxString.length (!tempString) = 0 then let __assign_19 = !tempString3 in (
            tempResult := __assign_19;
            __assign_19
          ) else let __assign_20 = (HxString.toStdString (!tempString) ^ ".") ^ HxString.toStdString (!tempString3) in (
            tempResult := __assign_20;
            __assign_20
          ));
          !tempResult
        )
      )
    )
  )
)

let typerindexbuild_fromResolvedModule = fun m -> try let out = HxArray.create () in (
  ignore (if m == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let pm = ResolvedModule.getParsed m in (
    ignore (if pm == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
    let decl = ParsedModule.getDecl pm () in let pkg = HxModuleDecl.getPackagePath decl in let moduleName = typerindexbuild_expectedModuleNameFromFile (ResolvedModule.getFilePath m) in let _g = ref 0 in let _g1 = HxModuleDecl.getClasses decl in (
      ignore (try while !_g < HxArray.length _g1 do try ignore (let cls = HxArray.get _g1 (!_g) in (
        ignore (let __old_21 = !_g in let __new_22 = HxInt.add __old_21 1 in (
          ignore (_g := __new_22);
          __new_22
        ));
        let clsName = HxClassDecl.getName cls in (
          ignore (if clsName == Obj.magic (HxRuntime.hx_null) || HxString.length clsName = 0 || HxString.equals clsName "Unknown" then raise (HxRuntime.Hx_continue) else ());
          let full = typerindexbuild_classFullNameInModule pkg moduleName clsName in let fields = HxMap.create_string () in (
            ignore (let _g2 = ref 0 in let _g3 = HxClassDecl.getFields cls in while !_g2 < HxArray.length _g3 do ignore (let f = HxArray.get _g3 (!_g2) in (
              ignore (let __old_23 = !_g2 in let __new_24 = HxInt.add __old_23 1 in (
                ignore (_g2 := __new_24);
                __new_24
              ));
              HxMap.set_string fields (HxFieldDecl.getName f) (TyType.fromHintText (HxFieldDecl.getTypeHint f))
            )) done);
            let statics = HxMap.create_string () in let instances = HxMap.create_string () in (
              ignore (let _g2 = ref 0 in let _g3 = HxClassDecl.getFunctions cls in while !_g2 < HxArray.length _g3 do ignore (let fn = HxArray.get _g3 (!_g2) in (
                ignore (let __old_25 = !_g2 in let __new_26 = HxInt.add __old_25 1 in (
                  ignore (_g2 := __new_26);
                  __new_26
                ));
                let fnName = HxFunctionDecl.getName fn in let isStatic = HxFunctionDecl.getIsStatic fn in let args = HxArray.create () in (
                  ignore (let _g4 = ref 0 in let _g5 = HxFunctionDecl.getArgs fn in while !_g4 < HxArray.length _g5 do ignore (let a = HxArray.get _g5 (!_g4) in (
                    ignore (let __old_27 = !_g4 in let __new_28 = HxInt.add __old_27 1 in (
                      ignore (_g4 := __new_28);
                      __new_28
                    ));
                    HxArray.push args (TyType.fromHintText (HxFunctionArg.getTypeHint a))
                  )) done);
                  let retHint = HxFunctionDecl.getReturnTypeHint fn in let tempTyType = ref (Obj.magic ()) in (
                    ignore (if HxString.equals fnName "new" then let __assign_29 = TyType.fromHintText full in (
                      tempTyType := __assign_29;
                      __assign_29
                    ) else let __assign_30 = TyType.fromHintText retHint in (
                      tempTyType := __assign_30;
                      __assign_30
                    ));
                    let ret = !tempTyType in let hx_sig = TyFunSig.create fnName isStatic args ret in if isStatic then ignore (HxMap.set_string statics fnName hx_sig) else ignore (HxMap.set_string instances fnName hx_sig)
                  )
                )
              )) done);
              HxArray.push out (TyClassInfo.create full clsName (ResolvedModule.getModulePath m) fields statics instances)
            )
          )
        )
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_31 -> Obj.obj __ret_31

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ModuleLoader *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; ensureTypeAvailable : Obj.t -> string -> string -> string HxArray.t -> TyClassInfo.t; mutable classPaths : string HxArray.t; mutable defines : string HxMap.string_map; mutable index : TyperIndex.t; mutable dirEntryCache : bool HxMap.string_map HxMap.string_map; mutable visited : bool HxMap.string_map; mutable pending : ResolvedModule.t HxArray.t; markResolvedAlready : Obj.t -> ResolvedModule.t HxArray.t -> unit; drainNewModules : Obj.t -> unit -> ResolvedModule.t HxArray.t; loadModuleByPath : Obj.t -> string -> unit; depsForParsedModule : Obj.t -> string -> HxModuleDecl.t -> string HxArray.t; resolveModuleFile : Obj.t -> string -> string }

let __ctor = fun (self : t) classPaths2 defines2 index2 -> ignore ((
  ignore (LazyTypeLoader.__ctor (Obj.magic self) ());
  let tempRight = ref (Obj.magic ()) in (
    ignore (if classPaths2 == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
      tempRight := __assign_1;
      __assign_1
    ) else let __assign_3 = classPaths2 in (
      tempRight := __assign_3;
      __assign_3
    ));
    ignore (let __assign_4 = !tempRight in (
      self.classPaths <- __assign_4;
      __assign_4
    ));
    let tempRight1 = ref (Obj.magic ()) in (
      ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_5 = HxMap.create_string () in (
        tempRight1 := __assign_5;
        __assign_5
      ) else let __assign_6 = defines2 in (
        tempRight1 := __assign_6;
        __assign_6
      ));
      ignore (let __assign_7 = !tempRight1 in (
        self.defines <- __assign_7;
        __assign_7
      ));
      ignore (let __assign_8 = index2 in (
        self.index <- __assign_8;
        __assign_8
      ));
      ignore (let __assign_9 = HxMap.create_string () in (
        self.dirEntryCache <- __assign_9;
        __assign_9
      ));
      ignore (let __assign_10 = HxMap.create_string () in (
        self.visited <- __assign_10;
        __assign_10
      ));
      let __assign_11 = let __arr_12 = HxArray.create () in __arr_12 in (
        self.pending <- __assign_11;
        __assign_11
      )
    )
  )
))

let markResolvedAlready__impl = fun (self : t) (resolved : ResolvedModule.t HxArray.t) -> ignore (try (
  ignore (if resolved == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let _g = ref 0 in while !_g < HxArray.length resolved do ignore (let m = HxArray.get resolved (!_g) in (
    ignore (let __old_13 = !_g in let __new_14 = HxInt.add __old_13 1 in (
      ignore (_g := __new_14);
      __new_14
    ));
    let mp = ResolvedModule.getModulePath m in if mp != Obj.magic (HxRuntime.hx_null) && HxString.length mp > 0 then ignore (HxMap.set_string (self.visited) mp true) else ()
  )) done
) with
  | HxRuntime.Hx_return __ret_15 -> Obj.obj __ret_15)

let drainNewModules__impl = fun (self : t) () -> try (
  ignore (if HxArray.length (self.pending) = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_16 = HxArray.create () in __arr_16))) else ());
  let out = HxArray.copy (self.pending) in (
    ignore (HxArray.resize (self.pending) 0);
    out
  )
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17

let loadModuleByPath__impl = fun (self : t) (modulePath : string) -> ignore (try let _gthis = self in (
  ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxMap.exists_string (self.visited) modulePath then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxMap.set_string (self.visited) modulePath true);
  let trace = HxString.equals (HxSys.getEnv "HXHX_TRACE_MODULE_LOADER") "1" in let filePath = self.resolveModuleFile (Obj.magic self) modulePath in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (if trace then ignore (print_endline ("loader_load miss module=" ^ HxString.toStdString modulePath)) else ());
      raise (HxRuntime.Hx_return (Obj.repr ()))
    )) else ());
    let tempMaybeString = ref (Obj.magic ()) in (
      ignore (try let __assign_27 = HxFile.getContent filePath in (
        tempMaybeString := __assign_27;
        __assign_27
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_28 -> raise (HxRuntime.Hx_return __ret_28)
        | HxRuntime.Hx_exception (__exn_v_29, __exn_tags_30) -> if true then let _hx = (__exn_v_29 : Obj.t) in (
          ignore _hx;
          let __assign_31 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_31;
            __assign_31
          )
        ) else HxRuntime.hx_throw_typed __exn_v_29 __exn_tags_30
        | __exn_32 -> if true then let _hx = (Obj.repr __exn_32 : Obj.t) in (
          ignore _hx;
          let __assign_33 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_33;
            __assign_33
          )
        ) else raise (__exn_32));
      let source = !tempMaybeString in (
        ignore (if source == Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (if trace then ignore (print_endline ((("loader_load read_failed module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
          raise (HxRuntime.Hx_return (Obj.repr ()))
        )) else ());
        let cloneDefines = fun src -> let out = HxMap.create_string () in (
          ignore (if src != Obj.magic (HxRuntime.hx_null) then ignore (let k = HxIterator.of_array (HxMap.keys_string src) in while (let __iter_34 = k in fun () -> HxIterator.hasNext __iter_34) () do ignore (let k2 = (let __iter_35 = k in fun () -> HxIterator.next __iter_35) () in HxMap.set_string out k2 (HxMap.get_string src k2)) done) else ());
          out
        ) in let tempStringMap = ref (Obj.magic ()) in let tempBool = ref false in (
          ignore (if modulePath != Obj.magic (HxRuntime.hx_null) && StringTools.startsWith modulePath "haxe.macro." then let __assign_36 = true in (
            tempBool := __assign_36;
            __assign_36
          ) else if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_37 = false in (
            tempBool := __assign_37;
            __assign_37
          ) else let __assign_38 = HxString.indexOf filePath "/haxe/macro/" 0 <> -1 || HxString.indexOf filePath "\\haxe\\macro\\" 0 <> -1 in (
            tempBool := __assign_38;
            __assign_38
          ));
          ignore (if !tempBool then let m = cloneDefines (_gthis.defines) in (
            ignore (if not (HxMap.exists_string m "macro") then ignore (HxMap.set_string m "macro" "1") else ());
            ignore (if not (HxMap.exists_string m "eval") then ignore (HxMap.set_string m "eval" "1") else ());
            let __assign_39 = m in (
              tempStringMap := __assign_39;
              __assign_39
            )
          ) else let __assign_40 = self.defines in (
            tempStringMap := __assign_40;
            __assign_40
          ));
          let filtered = HxConditionalCompilation.filterSource source (!tempStringMap) in let tempMaybeParsedModule = ref (Obj.magic ()) in (
            ignore (try let __assign_41 = ParserStage.parse filtered filePath in (
              tempMaybeParsedModule := __assign_41;
              __assign_41
            ) with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_42 -> raise (HxRuntime.Hx_return __ret_42)
              | HxRuntime.Hx_exception (__exn_v_43, __exn_tags_44) -> if true then let _hx = (__exn_v_43 : Obj.t) in (
                ignore _hx;
                let __assign_45 = Obj.magic (HxRuntime.hx_null) in (
                  tempMaybeParsedModule := __assign_45;
                  __assign_45
                )
              ) else HxRuntime.hx_throw_typed __exn_v_43 __exn_tags_44
              | __exn_46 -> if true then let _hx = (Obj.repr __exn_46 : Obj.t) in (
                ignore _hx;
                let __assign_47 = Obj.magic (HxRuntime.hx_null) in (
                  tempMaybeParsedModule := __assign_47;
                  __assign_47
                )
              ) else raise (__exn_46));
            let parsed = !tempMaybeParsedModule in (
              ignore (if parsed == Obj.magic (HxRuntime.hx_null) then ignore ((
                ignore (if trace then ignore (print_endline ((("loader_load parse_failed module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
                raise (HxRuntime.Hx_return (Obj.repr ()))
              )) else ());
              let rm = ResolvedModule.create modulePath filePath parsed in (
                ignore (HxArray.push (self.pending) rm);
                ignore (if trace then ignore (print_endline ((("loader_load ok module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
                ignore (if self.index != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in let _g1 = typerindexbuild_fromResolvedModule rm in while !_g < HxArray.length _g1 do ignore (let info = HxArray.get _g1 (!_g) in (
                  ignore (let __old_48 = !_g in let __new_49 = HxInt.add __old_48 1 in (
                    ignore (_g := __new_49);
                    __new_49
                  ));
                  if info != Obj.magic (HxRuntime.hx_null) then ignore (TyperIndex.addClass (self.index) info) else ()
                )) done) else ());
                let decl = ParsedModule.getDecl parsed () in let _g = ref 0 in let _g1 = self.depsForParsedModule (Obj.magic self) filtered decl in try while !_g < HxArray.length _g1 do try ignore (let dep = HxArray.get _g1 (!_g) in (
                  ignore (let __old_50 = !_g in let __new_51 = HxInt.add __old_50 1 in (
                    ignore (_g := __new_51);
                    __new_51
                  ));
                  ignore (if dep == Obj.magic (HxRuntime.hx_null) || HxString.length dep = 0 then raise (HxRuntime.Hx_continue) else ());
                  ignore (if self.resolveModuleFile (Obj.magic self) dep == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
                  self.loadModuleByPath (Obj.magic self) dep
                )) with
                  | HxRuntime.Hx_continue -> () done with
                  | HxRuntime.Hx_break -> ()
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_52 -> Obj.obj __ret_52)

let resolveModuleFile__impl = fun (self : t) (modulePath : string) -> try let _gthis = self in let parts = HxString.split modulePath "." in (
  ignore (if HxArray.length parts = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let direct = HxString.toStdString (HxArray.join parts "/" (fun x -> x)) ^ ".hx" in (
    ignore (let _g = ref 0 in let _g1 = self.classPaths in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
      ignore (let __old_68 = !_g in let __new_69 = HxInt.add __old_68 1 in (
        ignore (_g := __new_69);
        __new_69
      ));
      let candidate = Haxe_io_Path.join (let __arr_70 = HxArray.create () in (
        ignore (HxArray.push __arr_70 cp);
        ignore (HxArray.push __arr_70 direct);
        __arr_70
      )) in let tempBool = ref false in (
        ignore (if candidate == Obj.magic (HxRuntime.hx_null) || HxString.length candidate = 0 then let __assign_71 = false in (
          tempBool := __assign_71;
          __assign_71
        ) else if not (HxFileSystem.exists candidate) || HxFileSystem.isDirectory candidate then let __assign_72 = false in (
          tempBool := __assign_72;
          __assign_72
        ) else let dir = Haxe_io_Path.directory candidate in if dir == Obj.magic (HxRuntime.hx_null) || HxString.length dir = 0 then let __assign_73 = true in (
          tempBool := __assign_73;
          __assign_73
        ) else let base = Haxe_io_Path.withoutDirectory candidate in let entries = ref (HxMap.get_string (_gthis.dirEntryCache) dir) in (
          ignore (if !entries == Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_74 = HxMap.create_string () in (
              entries := __assign_74;
              __assign_74
            ));
            ignore (try let _g2 = ref 0 in let _g3 = HxFileSystem.readDirectory dir in while !_g2 < HxArray.length _g3 do ignore (let name = HxArray.get _g3 (!_g2) in (
              ignore (let __old_75 = !_g2 in let __new_76 = HxInt.add __old_75 1 in (
                ignore (_g2 := __new_76);
                __new_76
              ));
              if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then ignore (HxMap.set_string (!entries) name true) else ()
            )) done with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_77 -> raise (HxRuntime.Hx_return __ret_77)
              | HxRuntime.Hx_exception (__exn_v_78, __exn_tags_79) -> if true then let _hx = (__exn_v_78 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_78 __exn_tags_79
              | __exn_80 -> if true then let _hx = (Obj.repr __exn_80 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_80));
            HxMap.set_string (_gthis.dirEntryCache) dir (!entries)
          )) else ());
          let __assign_81 = HxMap.exists_string (!entries) base in (
            tempBool := __assign_81;
            __assign_81
          )
        ));
        if !tempBool then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
      )
    )) done);
    ignore (if HxArray.length parts >= 2 then ignore (let fallbackParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let fallback = HxString.toStdString (HxArray.join fallbackParts "/" (fun x -> x)) ^ ".hx" in let _g = ref 0 in let _g1 = self.classPaths in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
      ignore (let __old_82 = !_g in let __new_83 = HxInt.add __old_82 1 in (
        ignore (_g := __new_83);
        __new_83
      ));
      let candidate = Haxe_io_Path.join (let __arr_84 = HxArray.create () in (
        ignore (HxArray.push __arr_84 cp);
        ignore (HxArray.push __arr_84 fallback);
        __arr_84
      )) in let tempBool1 = ref false in (
        ignore (if candidate == Obj.magic (HxRuntime.hx_null) || HxString.length candidate = 0 then let __assign_85 = false in (
          tempBool1 := __assign_85;
          __assign_85
        ) else if not (HxFileSystem.exists candidate) || HxFileSystem.isDirectory candidate then let __assign_86 = false in (
          tempBool1 := __assign_86;
          __assign_86
        ) else let dir = Haxe_io_Path.directory candidate in if dir == Obj.magic (HxRuntime.hx_null) || HxString.length dir = 0 then let __assign_87 = true in (
          tempBool1 := __assign_87;
          __assign_87
        ) else let base = Haxe_io_Path.withoutDirectory candidate in let entries = ref (HxMap.get_string (_gthis.dirEntryCache) dir) in (
          ignore (if !entries == Obj.magic (HxRuntime.hx_null) then ignore ((
            ignore (let __assign_88 = HxMap.create_string () in (
              entries := __assign_88;
              __assign_88
            ));
            ignore (try let _g2 = ref 0 in let _g3 = HxFileSystem.readDirectory dir in while !_g2 < HxArray.length _g3 do ignore (let name = HxArray.get _g3 (!_g2) in (
              ignore (let __old_89 = !_g2 in let __new_90 = HxInt.add __old_89 1 in (
                ignore (_g2 := __new_90);
                __new_90
              ));
              if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then ignore (HxMap.set_string (!entries) name true) else ()
            )) done with
              | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
              | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
              | HxRuntime.Hx_return __ret_91 -> raise (HxRuntime.Hx_return __ret_91)
              | HxRuntime.Hx_exception (__exn_v_92, __exn_tags_93) -> if true then let _hx = (__exn_v_92 : Obj.t) in (
                ignore _hx;
                ()
              ) else HxRuntime.hx_throw_typed __exn_v_92 __exn_tags_93
              | __exn_94 -> if true then let _hx = (Obj.repr __exn_94 : Obj.t) in (
                ignore _hx;
                ()
              ) else raise (__exn_94));
            HxMap.set_string (_gthis.dirEntryCache) dir (!entries)
          )) else ());
          let __assign_95 = HxMap.exists_string (!entries) base in (
            tempBool1 := __assign_95;
            __assign_95
          )
        ));
        if !tempBool1 then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
      )
    )) done) else ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_96 -> Obj.obj __ret_96

let candidateModulePaths = fun typePath packagePath imports -> try let out = HxArray.create () in let tempString = ref "" in (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) then let __assign_97 = "" in (
    tempString := __assign_97;
    __assign_97
  ) else let __assign_98 = StringTools.trim typePath in (
    tempString := __assign_98;
    __assign_98
  ));
  ignore (if HxString.length (!tempString) = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  ignore (if HxString.indexOf (!tempString) "." 0 >= 0 then ignore (HxArray.push out (!tempString)) else ());
  ignore (if imports != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in try while !_g < HxArray.length imports do try ignore (let imp = HxArray.get imports (!_g) in (
    ignore (let __old_99 = !_g in let __new_100 = HxInt.add __old_99 1 in (
      ignore (_g := __new_100);
      __new_100
    ));
    ignore (if imp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
    let s = StringTools.trim imp in (
      ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_continue) else ());
      ignore (if StringTools.endsWith s ".*" then raise (HxRuntime.Hx_continue) else ());
      let parts = HxString.split s "." in let tempString1 = ref "" in (
        ignore (if HxArray.length parts = 0 then let __assign_101 = "" in (
          tempString1 := __assign_101;
          __assign_101
        ) else let __assign_102 = HxArray.get parts (HxInt.sub (HxArray.length parts) 1) in (
          tempString1 := __assign_102;
          __assign_102
        ));
        let last = !tempString1 in if HxString.equals last (!tempString) then ignore (HxArray.push out s) else ()
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ()) else ());
  let tempString2 = ref "" in (
    ignore (if packagePath == Obj.magic (HxRuntime.hx_null) then let __assign_103 = "" in (
      tempString2 := __assign_103;
      __assign_103
    ) else let __assign_104 = StringTools.trim packagePath in (
      tempString2 := __assign_104;
      __assign_104
    ));
    ignore (if HxString.length (!tempString2) > 0 && HxString.indexOf (!tempString) "." 0 = -1 then ignore (let cur = ref (!tempString2) in try while true do try ignore ((
      ignore (HxArray.push out ((HxString.toStdString (!cur) ^ ".") ^ HxString.toStdString (!tempString)));
      let lastDot = HxString.lastIndexOf (!cur) "." (HxString.length (!cur)) in (
        ignore (if lastDot < 0 then raise (HxRuntime.Hx_break) else ());
        let __assign_105 = HxString.substr (!cur) 0 lastDot in (
          cur := __assign_105;
          __assign_105
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()) else ());
    ignore (if HxString.length (!tempString2) = 0 && HxString.indexOf (!tempString) "." 0 = -1 then ignore (HxArray.push out (!tempString)) else ());
    let seen = HxMap.create_string () in let uniq = HxArray.create () in (
      ignore (let _g = ref 0 in try while !_g < HxArray.length out do try ignore (let m = HxArray.get out (!_g) in (
        ignore (let __old_106 = !_g in let __new_107 = HxInt.add __old_106 1 in (
          ignore (_g := __new_107);
          __new_107
        ));
        ignore (if m == Obj.magic (HxRuntime.hx_null) || HxString.length m = 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if HxMap.exists_string seen m then raise (HxRuntime.Hx_continue) else ());
        ignore (HxMap.set_string seen m true);
        HxArray.push uniq m
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      uniq
    )
  )
) with
  | HxRuntime.Hx_return __ret_108 -> Obj.obj __ret_108

let ensureTypeAvailable__impl = fun (self : t) (typePath : string) (packagePath : string) (imports : string HxArray.t) -> try (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let raw = StringTools.trim typePath in (
    ignore (if HxString.length raw = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let trace = HxString.equals (HxSys.getEnv "HXHX_TRACE_MODULE_LOADER") "1" in let tempString = ref "" in (
      ignore (if packagePath == Obj.magic (HxRuntime.hx_null) then let __assign_18 = "" in (
        tempString := __assign_18;
        __assign_18
      ) else let __assign_19 = packagePath in (
        tempString := __assign_19;
        __assign_19
      ));
      let tempMaybeTyClassInfo = ref (Obj.magic ()) in (
        ignore (if self.index == Obj.magic (HxRuntime.hx_null) then let __assign_20 = Obj.magic (HxRuntime.hx_null) in (
          tempMaybeTyClassInfo := __assign_20;
          __assign_20
        ) else let __assign_21 = TyperIndex.resolveTypePath (self.index) raw (!tempString) imports in (
          tempMaybeTyClassInfo := __assign_21;
          __assign_21
        ));
        let hit0 = !tempMaybeTyClassInfo in (
          ignore (if hit0 != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit0)) else ());
          let candidates = candidateModulePaths raw (!tempString) imports in (
            ignore (if trace then ignore (print_endline ((((("loader_resolve type=" ^ HxString.toStdString raw) ^ " pkg=") ^ HxString.toStdString (!tempString)) ^ " candidates=") ^ HxString.toStdString (HxArray.join candidates "," (fun x -> x)))) else ());
            let _g = ref 0 in (
              ignore (try while !_g < HxArray.length candidates do try ignore (let mp = HxArray.get candidates (!_g) in (
                ignore (let __old_22 = !_g in let __new_23 = HxInt.add __old_22 1 in (
                  ignore (_g := __new_23);
                  __new_23
                ));
                ignore (if mp == Obj.magic (HxRuntime.hx_null) || HxString.length mp = 0 then raise (HxRuntime.Hx_continue) else ());
                ignore (self.loadModuleByPath (Obj.magic self) mp);
                let tempMaybeTyClassInfo1 = ref (Obj.magic ()) in (
                  ignore (if self.index == Obj.magic (HxRuntime.hx_null) then let __assign_24 = Obj.magic (HxRuntime.hx_null) in (
                    tempMaybeTyClassInfo1 := __assign_24;
                    __assign_24
                  ) else let __assign_25 = TyperIndex.resolveTypePath (self.index) raw (!tempString) imports in (
                    tempMaybeTyClassInfo1 := __assign_25;
                    __assign_25
                  ));
                  let hit = !tempMaybeTyClassInfo1 in if hit != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit)) else ()
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              Obj.magic (HxRuntime.hx_null)
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_26 -> Obj.obj __ret_26

let normalizeImport = fun raw -> try (
  ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let s = ref (StringTools.trim raw) in (
    ignore (if HxString.length (!s) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if StringTools.startsWith (!s) "using " then ignore (let __assign_109 = StringTools.trim (HxString.substr (!s) (HxString.length "using ") (-1)) in (
      s := __assign_109;
      __assign_109
    )) else ());
    let asIdx = HxString.indexOf (!s) " as " 0 in (
      ignore (if asIdx >= 0 then ignore (let __assign_110 = StringTools.trim (HxString.substr (!s) 0 asIdx) in (
        s := __assign_110;
        __assign_110
      )) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (if HxString.length (!s) = 0 then let __assign_111 = Obj.magic (HxRuntime.hx_null) in (
          tempResult := __assign_111;
          __assign_111
        ) else let __assign_112 = !s in (
          tempResult := __assign_112;
          __assign_112
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_113 -> Obj.obj __ret_113

let implicitQualifiedTypeDeps = fun source -> try (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_114 = HxArray.create () in __arr_114))) else ());
  let candidates = HxMap.create_string () in let _g = ref 0 in let _g1 = HxString.split source "\n" in (
    ignore (try while !_g < HxArray.length _g1 do try ignore (let line = HxArray.get _g1 (!_g) in (
      ignore (let __old_115 = !_g in let __new_116 = HxInt.add __old_115 1 in (
        ignore (_g := __new_116);
        __new_116
      ));
      let trimmed = StringTools.trim line in (
        ignore (if StringTools.startsWith trimmed "@:" then raise (HxRuntime.Hx_continue) else ());
        let re = EReg.create "\\b(([A-Za-z_][A-Za-z0-9_]*\\.)+[A-Z][A-Za-z0-9_]*)\\b" "g" in let pos = ref 0 in while EReg.matchSub re line (!pos) (-1) do ignore (let dep = EReg.matched re 1 in (
          ignore (if dep != Obj.magic (HxRuntime.hx_null) && HxString.length dep > 0 then ignore (HxMap.set_string candidates dep true) else ());
          let mp = EReg.matchedPos re () in let __assign_117 = HxInt.add (Obj.obj (HxAnon.get mp "pos")) (Obj.obj (HxAnon.get mp "len")) in (
            pos := __assign_117;
            __assign_117
          )
        )) done
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    let out = HxArray.create () in (
      ignore (let dep = HxIterator.of_array (HxMap.keys_string candidates) in while (let __iter_118 = dep in fun () -> HxIterator.hasNext __iter_118) () do ignore (let dep2 = (let __iter_119 = dep in fun () -> HxIterator.next __iter_119) () in HxArray.push out dep2) done);
      ignore (HxArray.sort out (fun a b -> let tempResult = ref 0 in (
        ignore (if a < b then let __assign_120 = -1 in (
          tempResult := __assign_120;
          __assign_120
        ) else if a > b then let __assign_121 = 1 in (
          tempResult := __assign_121;
          __assign_121
        ) else let __assign_122 = 0 in (
          tempResult := __assign_122;
          __assign_122
        ));
        !tempResult
      )));
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_123 -> Obj.obj __ret_123

let depsForParsedModule__impl = fun (self : t) (filteredSource : string) (decl : HxModuleDecl.t) -> let out = HxArray.create () in let seen = HxMap.create_string () in let modulePkg = HxModuleDecl.getPackagePath decl in (
  ignore (let _g = ref 0 in let _g1 = HxModuleDecl.getImports decl in try while !_g < HxArray.length _g1 do try ignore (let rawImport = HxArray.get _g1 (!_g) in (
    ignore (let __old_53 = !_g in let __new_54 = HxInt.add __old_53 1 in (
      ignore (_g := __new_54);
      __new_54
    ));
    let imp = normalizeImport rawImport in (
      ignore (if imp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
      let tempMaybeString = ref (Obj.magic ()) in (
        ignore (let existsDirect = self.resolveModuleFile (Obj.magic self) imp != Obj.magic (HxRuntime.hx_null) in if existsDirect then let __assign_55 = imp in (
          tempMaybeString := __assign_55;
          __assign_55
        ) else let dot = HxString.indexOf imp "." 0 in let tempMaybeString1 = ref (Obj.magic ()) in (
          ignore (if dot = -1 then let __assign_56 = imp in (
            tempMaybeString1 := __assign_56;
            __assign_56
          ) else let __assign_57 = HxString.substr imp 0 dot in (
            tempMaybeString1 := __assign_57;
            __assign_57
          ));
          let head = !tempMaybeString1 in let tempMaybeNumber = ref (HxRuntime.hx_null) in (
            ignore (if HxString.length head = 0 then let __assign_58 = Obj.repr 0 in (
              tempMaybeNumber := __assign_58;
              __assign_58
            ) else let __assign_59 = HxString.charCodeAt head 0 in (
              tempMaybeNumber := __assign_59;
              __assign_59
            ));
            let head0 = !tempMaybeNumber in let headIsUpper = (let __nullable_60 = head0 in let __nullable_61 = 65 in if __nullable_60 == HxRuntime.hx_null then false else Obj.obj __nullable_60 >= __nullable_61) && (let __nullable_62 = head0 in let __nullable_63 = 90 in if __nullable_62 == HxRuntime.hx_null then false else Obj.obj __nullable_62 <= __nullable_63) in if headIsUpper && modulePkg != Obj.magic (HxRuntime.hx_null) && HxString.length modulePkg > 0 && not (StringTools.startsWith imp (HxString.toStdString modulePkg ^ ".")) then let __assign_64 = (HxString.toStdString modulePkg ^ ".") ^ HxString.toStdString imp in (
              tempMaybeString := __assign_64;
              __assign_64
            ) else let __assign_65 = imp in (
              tempMaybeString := __assign_65;
              __assign_65
            )
          )
        ));
        let resolvedImp = !tempMaybeString in (
          ignore (if StringTools.endsWith resolvedImp ".*" then ignore (let base = HxString.substr resolvedImp 0 (HxInt.sub (HxString.length resolvedImp) 2) in (
            ignore (if self.resolveModuleFile (Obj.magic self) base != Obj.magic (HxRuntime.hx_null) then ignore (if base == Obj.magic (HxRuntime.hx_null) || HxString.length base = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxMap.exists_string seen base then ignore (Obj.magic (HxRuntime.hx_null)) else ignore ((
              ignore (HxMap.set_string seen base true);
              HxArray.push out base
            )))) else ());
            raise (HxRuntime.Hx_continue)
          )) else ());
          if resolvedImp == Obj.magic (HxRuntime.hx_null) || HxString.length resolvedImp = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxMap.exists_string seen resolvedImp then ignore (Obj.magic (HxRuntime.hx_null)) else ignore ((
            ignore (HxMap.set_string seen resolvedImp true);
            HxArray.push out resolvedImp
          )))
        )
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  ignore (let _g = ref 0 in let _g1 = implicitQualifiedTypeDeps filteredSource in while !_g < HxArray.length _g1 do ignore (let dep = HxArray.get _g1 (!_g) in (
    ignore (let __old_66 = !_g in let __new_67 = HxInt.add __old_66 1 in (
      ignore (_g := __new_67);
      __new_67
    ));
    if dep == Obj.magic (HxRuntime.hx_null) || HxString.length dep = 0 then ignore (Obj.magic (HxRuntime.hx_null)) else ignore (if HxMap.exists_string seen dep then ignore (Obj.magic (HxRuntime.hx_null)) else ignore ((
      ignore (HxMap.set_string seen dep true);
      HxArray.push out dep
    )))
  )) done);
  out
)

let create = fun classPaths2 defines2 index2 -> let self = ({ __hx_type = HxType.class_ "ModuleLoader"; ensureTypeAvailable = (fun o a0 a1 a2 -> ensureTypeAvailable__impl (Obj.magic o) a0 a1 a2); classPaths = Obj.magic (); defines = Obj.magic (); index = Obj.magic (); dirEntryCache = Obj.magic (); visited = Obj.magic (); pending = Obj.magic (); markResolvedAlready = (fun o a0 -> markResolvedAlready__impl (Obj.magic o) a0); drainNewModules = (fun o () -> drainNewModules__impl (Obj.magic o) ()); loadModuleByPath = (fun o a0 -> loadModuleByPath__impl (Obj.magic o) a0); depsForParsedModule = (fun o a0 a1 -> depsForParsedModule__impl (Obj.magic o) a0 a1); resolveModuleFile = (fun o a0 -> resolveModuleFile__impl (Obj.magic o) a0) } : t) in (
  ignore ((
    ignore (LazyTypeLoader.__ctor (Obj.magic self) ());
    let tempRight = ref (Obj.magic ()) in (
      ignore (if classPaths2 == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
        tempRight := __assign_1;
        __assign_1
      ) else let __assign_3 = classPaths2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      ignore (let __assign_4 = !tempRight in (
        self.classPaths <- __assign_4;
        __assign_4
      ));
      let tempRight1 = ref (Obj.magic ()) in (
        ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_5 = HxMap.create_string () in (
          tempRight1 := __assign_5;
          __assign_5
        ) else let __assign_6 = defines2 in (
          tempRight1 := __assign_6;
          __assign_6
        ));
        ignore (let __assign_7 = !tempRight1 in (
          self.defines <- __assign_7;
          __assign_7
        ));
        ignore (let __assign_8 = index2 in (
          self.index <- __assign_8;
          __assign_8
        ));
        ignore (let __assign_9 = HxMap.create_string () in (
          self.dirEntryCache <- __assign_9;
          __assign_9
        ));
        ignore (let __assign_10 = HxMap.create_string () in (
          self.visited <- __assign_10;
          __assign_10
        ));
        let __assign_11 = let __arr_12 = HxArray.create () in __arr_12 in (
          self.pending <- __assign_11;
          __assign_11
        )
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ModuleLoader"; ensureTypeAvailable = (fun o a0 a1 a2 -> ensureTypeAvailable__impl (Obj.magic o) a0 a1 a2); classPaths = Obj.magic (); defines = Obj.magic (); index = Obj.magic (); dirEntryCache = Obj.magic (); visited = Obj.magic (); pending = Obj.magic (); markResolvedAlready = (fun o a0 -> markResolvedAlready__impl (Obj.magic o) a0); drainNewModules = (fun o () -> drainNewModules__impl (Obj.magic o) ()); loadModuleByPath = (fun o a0 -> loadModuleByPath__impl (Obj.magic o) a0); depsForParsedModule = (fun o a0 a1 -> depsForParsedModule__impl (Obj.magic o) a0 a1); resolveModuleFile = (fun o a0 -> resolveModuleFile__impl (Obj.magic o) a0) } : t)
# 1 "ModuleLoader.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: TyperIndexBuild *)

let __reflaxe_ocaml__ = ()

type typerindexbuild_t = { __hx_type : Obj.t }

let typerindexbuild_create = fun () -> let self = ({ __hx_type = HxType.class_ "TyperIndexBuild" } : typerindexbuild_t) in (
  ignore ();
  self
)

let typerindexbuild___empty = fun () -> ({ __hx_type = HxType.class_ "TyperIndexBuild" } : typerindexbuild_t)

let typerindexbuild_classFullName = fun pkg cls -> let tempString = ref "" in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) then let __assign_1 = "" in (
    tempString := __assign_1;
    __assign_1
  ) else let __assign_2 = StringTools.trim pkg in (
    tempString := __assign_2;
    __assign_2
  ));
  let tempResult = ref "" in (
    ignore (if HxString.length (!tempString) = 0 then let __assign_3 = cls in (
      tempResult := __assign_3;
      __assign_3
    ) else let __assign_4 = (HxString.toStdString (!tempString) ^ ".") ^ HxString.toStdString cls in (
      tempResult := __assign_4;
      __assign_4
    ));
    !tempResult
  )
)

let typerindexbuild_fromResolvedModule = fun m -> try (
  ignore (if m == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let pm = ResolvedModule.getParsed m in (
    ignore (if pm == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let decl = ParsedModule.getDecl pm () in let pkg = HxModuleDecl.getPackagePath decl in let cls = HxModuleDecl.getMainClass decl in let clsName = HxClassDecl.getName cls in let full = typerindexbuild_classFullName pkg clsName in let fields = HxMap.create_string () in (
      ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFields cls in while !_g < HxArray.length _g1 do ignore (let f = HxArray.get _g1 (!_g) in (
        ignore (let __old_5 = !_g in let __new_6 = HxInt.add __old_5 1 in (
          ignore (_g := __new_6);
          __new_6
        ));
        HxMap.set_string fields (HxFieldDecl.getName f) (TyType.fromHintText (HxFieldDecl.getTypeHint f))
      )) done);
      let statics = HxMap.create_string () in let instances = HxMap.create_string () in (
        ignore (let _g = ref 0 in let _g1 = HxClassDecl.getFunctions cls in while !_g < HxArray.length _g1 do ignore (let fn = HxArray.get _g1 (!_g) in (
          ignore (let __old_7 = !_g in let __new_8 = HxInt.add __old_7 1 in (
            ignore (_g := __new_8);
            __new_8
          ));
          let fnName = HxFunctionDecl.getName fn in let isStatic = HxFunctionDecl.getIsStatic fn in let args = HxArray.create () in (
            ignore (let _g2 = ref 0 in let _g3 = HxFunctionDecl.getArgs fn in while !_g2 < HxArray.length _g3 do ignore (let a = HxArray.get _g3 (!_g2) in (
              ignore (let __old_9 = !_g2 in let __new_10 = HxInt.add __old_9 1 in (
                ignore (_g2 := __new_10);
                __new_10
              ));
              HxArray.push args (TyType.fromHintText (HxFunctionArg.getTypeHint a))
            )) done);
            let retHint = HxFunctionDecl.getReturnTypeHint fn in let tempTyType = ref (Obj.magic ()) in (
              ignore (if HxString.equals fnName "new" then let __assign_11 = TyType.fromHintText full in (
                tempTyType := __assign_11;
                __assign_11
              ) else let __assign_12 = TyType.fromHintText retHint in (
                tempTyType := __assign_12;
                __assign_12
              ));
              let ret = !tempTyType in let hx_sig = TyFunSig.create fnName isStatic args ret in if isStatic then ignore (HxMap.set_string statics fnName hx_sig) else ignore (HxMap.set_string instances fnName hx_sig)
            )
          )
        )) done);
        TyClassInfo.create full clsName (ResolvedModule.getModulePath m) fields statics instances
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_13 -> Obj.obj __ret_13

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ModuleLoader *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; ensureTypeAvailable : Obj.t -> string -> string -> string HxArray.t -> TyClassInfo.t; mutable classPaths : string HxArray.t; mutable defines : string HxMap.string_map; mutable index : TyperIndex.t; mutable visited : bool HxMap.string_map; mutable pending : ResolvedModule.t HxArray.t; markResolvedAlready : Obj.t -> ResolvedModule.t HxArray.t -> unit; drainNewModules : Obj.t -> unit -> ResolvedModule.t HxArray.t; loadModuleByPath : Obj.t -> string -> unit; resolveModuleFile : Obj.t -> string -> string }

let __ctor = fun (self : t) classPaths2 defines2 index2 -> ignore ((
  ignore (LazyTypeLoader.__ctor (Obj.magic self) ());
  let tempRight = ref (Obj.magic ()) in (
    ignore (if classPaths2 == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
      tempRight := __assign_1;
      __assign_1
    ) else let __assign_3 = classPaths2 in (
      tempRight := __assign_3;
      __assign_3
    ));
    ignore (let __assign_4 = !tempRight in (
      self.classPaths <- __assign_4;
      __assign_4
    ));
    let tempRight1 = ref (Obj.magic ()) in (
      ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_5 = HxMap.create_string () in (
        tempRight1 := __assign_5;
        __assign_5
      ) else let __assign_6 = defines2 in (
        tempRight1 := __assign_6;
        __assign_6
      ));
      ignore (let __assign_7 = !tempRight1 in (
        self.defines <- __assign_7;
        __assign_7
      ));
      ignore (let __assign_8 = index2 in (
        self.index <- __assign_8;
        __assign_8
      ));
      ignore (let __assign_9 = HxMap.create_string () in (
        self.visited <- __assign_9;
        __assign_9
      ));
      let __assign_10 = let __arr_11 = HxArray.create () in __arr_11 in (
        self.pending <- __assign_10;
        __assign_10
      )
    )
  )
))

let markResolvedAlready__impl = fun (self : t) (resolved : ResolvedModule.t HxArray.t) -> ignore (try (
  ignore (if resolved == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let _g = ref 0 in while !_g < HxArray.length resolved do ignore (let m = HxArray.get resolved (!_g) in (
    ignore (let __old_12 = !_g in let __new_13 = HxInt.add __old_12 1 in (
      ignore (_g := __new_13);
      __new_13
    ));
    let mp = ResolvedModule.getModulePath m in if mp != Obj.magic (HxRuntime.hx_null) && HxString.length mp > 0 then ignore (HxMap.set_string (self.visited) mp true) else ()
  )) done
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14)

let drainNewModules__impl = fun (self : t) () -> try (
  ignore (if HxArray.length (self.pending) = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_15 = HxArray.create () in __arr_15))) else ());
  let out = HxArray.copy (self.pending) in (
    ignore (HxArray.resize (self.pending) 0);
    out
  )
) with
  | HxRuntime.Hx_return __ret_16 -> Obj.obj __ret_16

let loadModuleByPath__impl = fun (self : t) (modulePath : string) -> ignore (try (
  ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (if HxMap.exists_string (self.visited) modulePath then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  ignore (HxMap.set_string (self.visited) modulePath true);
  let trace = HxString.equals (HxSys.getEnv "HXHX_TRACE_MODULE_LOADER") "1" in let filePath = self.resolveModuleFile (Obj.magic self) modulePath in (
    ignore (if filePath == Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (if trace then ignore (print_endline ("loader_load miss module=" ^ HxString.toStdString modulePath)) else ());
      raise (HxRuntime.Hx_return (Obj.repr ()))
    )) else ());
    let tempMaybeString = ref (Obj.magic ()) in (
      ignore (try let __assign_26 = HxFile.getContent filePath in (
        tempMaybeString := __assign_26;
        __assign_26
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_27 -> raise (HxRuntime.Hx_return __ret_27)
        | HxRuntime.Hx_exception (__exn_v_28, __exn_tags_29) -> if true then let _hx = (__exn_v_28 : Obj.t) in (
          ignore _hx;
          let __assign_30 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_30;
            __assign_30
          )
        ) else HxRuntime.hx_throw_typed __exn_v_28 __exn_tags_29
        | __exn_31 -> if true then let _hx = (Obj.repr __exn_31 : Obj.t) in (
          ignore _hx;
          let __assign_32 = Obj.magic (HxRuntime.hx_null) in (
            tempMaybeString := __assign_32;
            __assign_32
          )
        ) else raise (__exn_31));
      let source = !tempMaybeString in (
        ignore (if source == Obj.magic (HxRuntime.hx_null) then ignore ((
          ignore (if trace then ignore (print_endline ((("loader_load read_failed module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
          raise (HxRuntime.Hx_return (Obj.repr ()))
        )) else ());
        let filtered = HxConditionalCompilation.filterSource source (self.defines) in let tempMaybeParsedModule = ref (Obj.magic ()) in (
          ignore (try let __assign_33 = ParserStage.parse filtered filePath in (
            tempMaybeParsedModule := __assign_33;
            __assign_33
          ) with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_34 -> raise (HxRuntime.Hx_return __ret_34)
            | HxRuntime.Hx_exception (__exn_v_35, __exn_tags_36) -> if true then let _hx = (__exn_v_35 : Obj.t) in (
              ignore _hx;
              let __assign_37 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeParsedModule := __assign_37;
                __assign_37
              )
            ) else HxRuntime.hx_throw_typed __exn_v_35 __exn_tags_36
            | __exn_38 -> if true then let _hx = (Obj.repr __exn_38 : Obj.t) in (
              ignore _hx;
              let __assign_39 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeParsedModule := __assign_39;
                __assign_39
              )
            ) else raise (__exn_38));
          let parsed = !tempMaybeParsedModule in (
            ignore (if parsed == Obj.magic (HxRuntime.hx_null) then ignore ((
              ignore (if trace then ignore (print_endline ((("loader_load parse_failed module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
              raise (HxRuntime.Hx_return (Obj.repr ()))
            )) else ());
            let rm = ResolvedModule.create modulePath filePath parsed in (
              ignore (HxArray.push (self.pending) rm);
              ignore (if trace then ignore (print_endline ((("loader_load ok module=" ^ HxString.toStdString modulePath) ^ " file=") ^ HxString.toStdString filePath)) else ());
              if self.index != Obj.magic (HxRuntime.hx_null) then ignore (let info = typerindexbuild_fromResolvedModule rm in if info != Obj.magic (HxRuntime.hx_null) then ignore (TyperIndex.addClass (self.index) info) else ()) else ()
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_40 -> Obj.obj __ret_40)

let resolveModuleFile__impl = fun (self : t) (modulePath : string) -> try let parts = HxString.split modulePath "." in (
  ignore (if HxArray.length parts = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let direct = HxString.toStdString (HxArray.join parts "/" (fun x -> x)) ^ ".hx" in (
    ignore (let _g = ref 0 in let _g1 = self.classPaths in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
      ignore (let __old_41 = !_g in let __new_42 = HxInt.add __old_41 1 in (
        ignore (_g := __new_42);
        __new_42
      ));
      let candidate = Haxe_io_Path.join (let __arr_43 = HxArray.create () in (
        ignore (HxArray.push __arr_43 cp);
        ignore (HxArray.push __arr_43 direct);
        __arr_43
      )) in if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done);
    ignore (if HxArray.length parts >= 2 then ignore (let fallbackParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let fallback = HxString.toStdString (HxArray.join fallbackParts "/" (fun x -> x)) ^ ".hx" in let _g = ref 0 in let _g1 = self.classPaths in while !_g < HxArray.length _g1 do ignore (let cp = HxArray.get _g1 (!_g) in (
      ignore (let __old_44 = !_g in let __new_45 = HxInt.add __old_44 1 in (
        ignore (_g := __new_45);
        __new_45
      ));
      let candidate = Haxe_io_Path.join (let __arr_46 = HxArray.create () in (
        ignore (HxArray.push __arr_46 cp);
        ignore (HxArray.push __arr_46 fallback);
        __arr_46
      )) in if HxFileSystem.exists candidate && not (HxFileSystem.isDirectory candidate) then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done) else ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_47 -> Obj.obj __ret_47

let candidateModulePaths = fun typePath packagePath imports -> try let out = HxArray.create () in let tempString = ref "" in (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) then let __assign_48 = "" in (
    tempString := __assign_48;
    __assign_48
  ) else let __assign_49 = StringTools.trim typePath in (
    tempString := __assign_49;
    __assign_49
  ));
  ignore (if HxString.length (!tempString) = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  ignore (if HxString.indexOf (!tempString) "." 0 >= 0 then ignore (HxArray.push out (!tempString)) else ());
  ignore (if imports != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in try while !_g < HxArray.length imports do try ignore (let imp = HxArray.get imports (!_g) in (
    ignore (let __old_50 = !_g in let __new_51 = HxInt.add __old_50 1 in (
      ignore (_g := __new_51);
      __new_51
    ));
    ignore (if imp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
    let s = StringTools.trim imp in (
      ignore (if HxString.length s = 0 then raise (HxRuntime.Hx_continue) else ());
      ignore (if StringTools.endsWith s ".*" then raise (HxRuntime.Hx_continue) else ());
      let parts = HxString.split s "." in let tempString1 = ref "" in (
        ignore (if HxArray.length parts = 0 then let __assign_52 = "" in (
          tempString1 := __assign_52;
          __assign_52
        ) else let __assign_53 = HxArray.get parts (HxInt.sub (HxArray.length parts) 1) in (
          tempString1 := __assign_53;
          __assign_53
        ));
        let last = !tempString1 in if HxString.equals last (!tempString) then ignore (HxArray.push out s) else ()
      )
    )
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ()) else ());
  let tempString2 = ref "" in (
    ignore (if packagePath == Obj.magic (HxRuntime.hx_null) then let __assign_54 = "" in (
      tempString2 := __assign_54;
      __assign_54
    ) else let __assign_55 = StringTools.trim packagePath in (
      tempString2 := __assign_55;
      __assign_55
    ));
    ignore (if HxString.length (!tempString2) > 0 && HxString.indexOf (!tempString) "." 0 = -1 then ignore (let cur = ref (!tempString2) in try while true do try ignore ((
      ignore (HxArray.push out ((HxString.toStdString (!cur) ^ ".") ^ HxString.toStdString (!tempString)));
      let lastDot = HxString.lastIndexOf (!cur) "." (HxString.length (!cur)) in (
        ignore (if lastDot < 0 then raise (HxRuntime.Hx_break) else ());
        let __assign_56 = HxString.substr (!cur) 0 lastDot in (
          cur := __assign_56;
          __assign_56
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()) else ());
    let seen = HxMap.create_string () in let uniq = HxArray.create () in (
      ignore (let _g = ref 0 in try while !_g < HxArray.length out do try ignore (let m = HxArray.get out (!_g) in (
        ignore (let __old_57 = !_g in let __new_58 = HxInt.add __old_57 1 in (
          ignore (_g := __new_58);
          __new_58
        ));
        ignore (if m == Obj.magic (HxRuntime.hx_null) || HxString.length m = 0 then raise (HxRuntime.Hx_continue) else ());
        ignore (if HxMap.exists_string seen m then raise (HxRuntime.Hx_continue) else ());
        ignore (HxMap.set_string seen m true);
        HxArray.push uniq m
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      uniq
    )
  )
) with
  | HxRuntime.Hx_return __ret_59 -> Obj.obj __ret_59

let ensureTypeAvailable__impl = fun (self : t) (typePath : string) (packagePath : string) (imports : string HxArray.t) -> try (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let raw = StringTools.trim typePath in (
    ignore (if HxString.length raw = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let trace = HxString.equals (HxSys.getEnv "HXHX_TRACE_MODULE_LOADER") "1" in let tempString = ref "" in (
      ignore (if packagePath == Obj.magic (HxRuntime.hx_null) then let __assign_17 = "" in (
        tempString := __assign_17;
        __assign_17
      ) else let __assign_18 = packagePath in (
        tempString := __assign_18;
        __assign_18
      ));
      let tempMaybeTyClassInfo = ref (Obj.magic ()) in (
        ignore (if self.index == Obj.magic (HxRuntime.hx_null) then let __assign_19 = Obj.magic (HxRuntime.hx_null) in (
          tempMaybeTyClassInfo := __assign_19;
          __assign_19
        ) else let __assign_20 = TyperIndex.resolveTypePath (self.index) raw (!tempString) imports in (
          tempMaybeTyClassInfo := __assign_20;
          __assign_20
        ));
        let hit0 = !tempMaybeTyClassInfo in (
          ignore (if hit0 != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit0)) else ());
          let candidates = candidateModulePaths raw (!tempString) imports in (
            ignore (if trace then ignore (print_endline ((((("loader_resolve type=" ^ HxString.toStdString raw) ^ " pkg=") ^ HxString.toStdString (!tempString)) ^ " candidates=") ^ HxString.toStdString (HxArray.join candidates "," (fun x -> x)))) else ());
            let _g = ref 0 in (
              ignore (try while !_g < HxArray.length candidates do try ignore (let mp = HxArray.get candidates (!_g) in (
                ignore (let __old_21 = !_g in let __new_22 = HxInt.add __old_21 1 in (
                  ignore (_g := __new_22);
                  __new_22
                ));
                ignore (if mp == Obj.magic (HxRuntime.hx_null) || HxString.length mp = 0 then raise (HxRuntime.Hx_continue) else ());
                ignore (self.loadModuleByPath (Obj.magic self) mp);
                let tempMaybeTyClassInfo1 = ref (Obj.magic ()) in (
                  ignore (if self.index == Obj.magic (HxRuntime.hx_null) then let __assign_23 = Obj.magic (HxRuntime.hx_null) in (
                    tempMaybeTyClassInfo1 := __assign_23;
                    __assign_23
                  ) else let __assign_24 = TyperIndex.resolveTypePath (self.index) raw (!tempString) imports in (
                    tempMaybeTyClassInfo1 := __assign_24;
                    __assign_24
                  ));
                  let hit = !tempMaybeTyClassInfo1 in if hit != Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr hit)) else ()
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              Obj.magic (HxRuntime.hx_null)
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_25 -> Obj.obj __ret_25

let create = fun classPaths2 defines2 index2 -> let self = ({ __hx_type = HxType.class_ "ModuleLoader"; ensureTypeAvailable = (fun o a0 a1 a2 -> ensureTypeAvailable__impl (Obj.magic o) a0 a1 a2); classPaths = Obj.magic (); defines = Obj.magic (); index = Obj.magic (); visited = Obj.magic (); pending = Obj.magic (); markResolvedAlready = (fun o a0 -> markResolvedAlready__impl (Obj.magic o) a0); drainNewModules = (fun o () -> drainNewModules__impl (Obj.magic o) ()); loadModuleByPath = (fun o a0 -> loadModuleByPath__impl (Obj.magic o) a0); resolveModuleFile = (fun o a0 -> resolveModuleFile__impl (Obj.magic o) a0) } : t) in (
  ignore ((
    ignore (LazyTypeLoader.__ctor (Obj.magic self) ());
    let tempRight = ref (Obj.magic ()) in (
      ignore (if classPaths2 == Obj.magic (HxRuntime.hx_null) then let __assign_1 = let __arr_2 = HxArray.create () in __arr_2 in (
        tempRight := __assign_1;
        __assign_1
      ) else let __assign_3 = classPaths2 in (
        tempRight := __assign_3;
        __assign_3
      ));
      ignore (let __assign_4 = !tempRight in (
        self.classPaths <- __assign_4;
        __assign_4
      ));
      let tempRight1 = ref (Obj.magic ()) in (
        ignore (if defines2 == Obj.magic (HxRuntime.hx_null) then let __assign_5 = HxMap.create_string () in (
          tempRight1 := __assign_5;
          __assign_5
        ) else let __assign_6 = defines2 in (
          tempRight1 := __assign_6;
          __assign_6
        ));
        ignore (let __assign_7 = !tempRight1 in (
          self.defines <- __assign_7;
          __assign_7
        ));
        ignore (let __assign_8 = index2 in (
          self.index <- __assign_8;
          __assign_8
        ));
        ignore (let __assign_9 = HxMap.create_string () in (
          self.visited <- __assign_9;
          __assign_9
        ));
        let __assign_10 = let __arr_11 = HxArray.create () in __arr_11 in (
          self.pending <- __assign_10;
          __assign_10
        )
      )
    )
  ));
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ModuleLoader"; ensureTypeAvailable = (fun o a0 a1 a2 -> ensureTypeAvailable__impl (Obj.magic o) a0 a1 a2); classPaths = Obj.magic (); defines = Obj.magic (); index = Obj.magic (); visited = Obj.magic (); pending = Obj.magic (); markResolvedAlready = (fun o a0 -> markResolvedAlready__impl (Obj.magic o) a0); drainNewModules = (fun o () -> drainNewModules__impl (Obj.magic o) ()); loadModuleByPath = (fun o a0 -> loadModuleByPath__impl (Obj.magic o) a0); resolveModuleFile = (fun o a0 -> resolveModuleFile__impl (Obj.magic o) a0) } : t)
# 1 "ResolverStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ResolverStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ResolverStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ResolverStage" } : t)

let resolveImplicitSamePackageTypesEnabled = fun () -> try let v = HxSys.getEnv "HXHX_RESOLVE_IMPLICIT_PACKAGE_TYPES" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim v) = 0 then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
  let s = HxString.toLowerCase (StringTools.trim v) () in (
    ignore (if HxString.equals s "0" || HxString.equals s "false" || HxString.equals s "no" then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
    HxString.equals s "1" || HxString.equals s "true" || HxString.equals s "yes"
  )
) with
  | HxRuntime.Hx_return __ret_1 -> Obj.obj __ret_1

let implicitSamePackageDeps = fun source modulePath decl -> try let pkg = HxModuleDecl.getPackagePath decl in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) || HxString.length pkg = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_2 = HxArray.create () in __arr_2))) else ());
  let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if modulePath == Obj.magic (HxRuntime.hx_null) then let __assign_3 = "" in (
      tempMaybeString := __assign_3;
      __assign_3
    ) else let __assign_4 = HxArray.pop (HxString.split modulePath ".") () in (
      tempMaybeString := __assign_4;
      __assign_4
    ));
    let candidates = HxMap.create_string () in let addMatches = fun re -> let pos = ref 0 in while EReg.matchSub re source (!pos) (Obj.magic (HxRuntime.hx_null)) do ignore (let name = EReg.matched re 1 in (
      ignore (if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then ignore (HxMap.set_string candidates name true) else ());
      let mp = EReg.matchedPos re () in let __assign_5 = HxInt.add (Obj.obj (HxAnon.get mp "pos")) (Obj.obj (HxAnon.get mp "len")) in (
        pos := __assign_5;
        __assign_5
      )
    )) done in (
      ignore (addMatches (EReg.create "\\bnew\\s+([A-Z][A-Za-z0-9_]*)\\b" "g"));
      ignore (addMatches (EReg.create "\\b([A-Z][A-Za-z0-9_]*)\\s*\\." "g"));
      let names = HxArray.create () in (
        ignore (let name = HxIterator.of_array (HxMap.keys_string candidates) in while (let __iter_6 = name in fun () -> HxIterator.hasNext __iter_6) () do ignore (let name2 = (let __iter_7 = name in fun () -> HxIterator.next __iter_7) () in HxArray.push names name2) done);
        ignore (HxArray.sort names (fun a b -> let tempResult = ref 0 in (
          ignore (if a < b then let __assign_8 = -1 in (
            tempResult := __assign_8;
            __assign_8
          ) else if a > b then let __assign_9 = 1 in (
            tempResult := __assign_9;
            __assign_9
          ) else let __assign_10 = 0 in (
            tempResult := __assign_10;
            __assign_10
          ));
          !tempResult
        )));
        let out = HxArray.create () in let _g = ref 0 in (
          ignore (try while !_g < HxArray.length names do try ignore (let name = HxArray.get names (!_g) in (
            ignore (let __old_11 = !_g in let __new_12 = HxInt.add __old_11 1 in (
              ignore (_g := __new_12);
              __new_12
            ));
            ignore (if HxString.equals name (!tempMaybeString) then raise (HxRuntime.Hx_continue) else ());
            HxArray.push out ((HxString.toStdString pkg ^ ".") ^ HxString.toStdString name)
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          out
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_13 -> Obj.obj __ret_13

let normalizeImport = fun raw -> try (
  ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let s = ref (StringTools.trim raw) in (
    ignore (if HxString.length (!s) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if StringTools.startsWith (!s) "using " then ignore (let __assign_53 = StringTools.trim (HxString.substr (!s) (HxString.length "using ") (-1)) in (
      s := __assign_53;
      __assign_53
    )) else ());
    let asIdx = HxString.indexOf (!s) " as " 0 in (
      ignore (if asIdx >= 0 then ignore (let __assign_54 = StringTools.trim (HxString.substr (!s) 0 asIdx) in (
        s := __assign_54;
        __assign_54
      )) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (if HxString.length (!s) = 0 then let __assign_55 = Obj.magic (HxRuntime.hx_null) in (
          tempResult := __assign_55;
          __assign_55
        ) else let __assign_56 = !s in (
          tempResult := __assign_56;
          __assign_56
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_57 -> Obj.obj __ret_57

let resolveModuleFile = fun classPaths modulePath -> try let parts = HxString.split modulePath "." in (
  ignore (if HxArray.length parts = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let direct = HxString.toStdString (HxArray.join parts "/" (fun x -> x)) ^ ".hx" in (
    ignore (let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_58 = !_g in let __new_59 = HxInt.add __old_58 1 in (
        ignore (_g := __new_59);
        __new_59
      ));
      let candidate = Haxe_io_Path.join (let __arr_60 = HxArray.create () in (
        ignore (HxArray.push __arr_60 cp);
        ignore (HxArray.push __arr_60 direct);
        __arr_60
      )) in if HxFileSystem.exists candidate then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done);
    ignore (if HxArray.length parts >= 2 then ignore (let fallbackParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let fallback = HxString.toStdString (HxArray.join fallbackParts "/" (fun x -> x)) ^ ".hx" in let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_61 = !_g in let __new_62 = HxInt.add __old_61 1 in (
        ignore (_g := __new_62);
        __new_62
      ));
      let candidate = Haxe_io_Path.join (let __arr_63 = HxArray.create () in (
        ignore (HxArray.push __arr_63 cp);
        ignore (HxArray.push __arr_63 fallback);
        __arr_63
      )) in if HxFileSystem.exists candidate then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done) else ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_64 -> Obj.obj __ret_64

let parseProjectRoots = fun classPaths roots defines -> let out = HxArray.create () in let visited = HxMap.create_string () in let tempMaybeStringMap = ref (Obj.magic ()) in (
  ignore (if defines == Obj.magic (HxRuntime.hx_null) then let __assign_15 = HxMap.create_string () in (
    tempMaybeStringMap := __assign_15;
    __assign_15
  ) else let __assign_16 = defines in (
    tempMaybeStringMap := __assign_16;
    __assign_16
  ));
  let cloneDefines = fun src -> let out2 = HxMap.create_string () in (
    ignore (if src != Obj.magic (HxRuntime.hx_null) then ignore (let k = HxIterator.of_array (HxMap.keys_string src) in while (let __iter_17 = k in fun () -> HxIterator.hasNext __iter_17) () do ignore (let k2 = (let __iter_18 = k in fun () -> HxIterator.next __iter_18) () in HxMap.set_string out2 k2 (HxMap.get_string src k2)) done) else ());
    out2
  ) in let stack = HxArray.create () in (
    ignore (if roots != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in try while !_g < HxArray.length roots do try ignore (let r = HxArray.get roots (!_g) in (
      ignore (let __old_19 = !_g in let __new_20 = HxInt.add __old_19 1 in (
        ignore (_g := __new_20);
        __new_20
      ));
      ignore (if r == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
      let m = StringTools.trim r in (
        ignore (if HxString.length m = 0 then raise (HxRuntime.Hx_continue) else ());
        HxArray.push stack m
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()) else ());
    ignore (try while HxArray.length stack > 0 do try ignore (let modulePath = HxArray.pop stack () in (
      ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_continue) else ());
      ignore (if HxMap.exists_string visited modulePath then raise (HxRuntime.Hx_continue) else ());
      ignore (HxMap.set_string visited modulePath true);
      let filePath = resolveModuleFile classPaths modulePath in (
        ignore (if filePath == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("import_missing " ^ HxString.toStdString modulePath)) ["Dynamic"; "String"]) else ());
        let tempMaybeString = ref (Obj.magic ()) in (
          ignore (try let __assign_21 = HxFile.getContent filePath in (
            tempMaybeString := __assign_21;
            __assign_21
          ) with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_22 -> raise (HxRuntime.Hx_return __ret_22)
            | HxRuntime.Hx_exception (__exn_v_23, __exn_tags_24) -> if true then let _hx = (__exn_v_23 : Obj.t) in (
              ignore _hx;
              let __assign_25 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_25;
                __assign_25
              )
            ) else HxRuntime.hx_throw_typed __exn_v_23 __exn_tags_24
            | __exn_26 -> if true then let _hx = (Obj.repr __exn_26 : Obj.t) in (
              ignore _hx;
              let __assign_27 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_27;
                __assign_27
              )
            ) else raise (__exn_26));
          let source = !tempMaybeString in (
            ignore (if source == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("import_unreadable " ^ HxString.toStdString filePath)) ["Dynamic"; "String"]) else ());
            let tempMaybeStringMap1 = ref (Obj.magic ()) in let tempBool = ref false in (
              ignore (if modulePath != Obj.magic (HxRuntime.hx_null) && StringTools.startsWith modulePath "haxe.macro." then let __assign_28 = true in (
                tempBool := __assign_28;
                __assign_28
              ) else if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_29 = false in (
                tempBool := __assign_29;
                __assign_29
              ) else let __assign_30 = HxString.indexOf filePath "/haxe/macro/" 0 <> -1 || HxString.indexOf filePath "\\haxe\\macro\\" 0 <> -1 in (
                tempBool := __assign_30;
                __assign_30
              ));
              ignore (if !tempBool then let m = cloneDefines (!tempMaybeStringMap) in (
                ignore (if not (HxMap.exists_string m "macro") then ignore (HxMap.set_string m "macro" "1") else ());
                ignore (if not (HxMap.exists_string m "eval") then ignore (HxMap.set_string m "eval" "1") else ());
                let __assign_31 = m in (
                  tempMaybeStringMap1 := __assign_31;
                  __assign_31
                )
              ) else let __assign_32 = !tempMaybeStringMap in (
                tempMaybeStringMap1 := __assign_32;
                __assign_32
              ));
              let effectiveDefines = !tempMaybeStringMap1 in let filteredSource = HxConditionalCompilation.filterSource source effectiveDefines in let tempParsedModule = ref (Obj.magic ()) in (
                ignore (try let __assign_33 = ParserStage.parse filteredSource filePath in (
                  tempParsedModule := __assign_33;
                  __assign_33
                ) with
                  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                  | HxRuntime.Hx_return __ret_34 -> raise (HxRuntime.Hx_return __ret_34)
                  | HxRuntime.Hx_exception (__exn_v_35, __exn_tags_36) -> if true then let e = (__exn_v_35 : Obj.t) in (
                    ignore e;
                    HxType.hx_throw_typed_rtti (Obj.repr ((("parse_failed " ^ HxString.toStdString filePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e))) ["Dynamic"; "String"]
                  ) else HxRuntime.hx_throw_typed __exn_v_35 __exn_tags_36
                  | __exn_37 -> if true then let e = (Obj.repr __exn_37 : Obj.t) in (
                    ignore e;
                    HxType.hx_throw_typed_rtti (Obj.repr ((("parse_failed " ^ HxString.toStdString filePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e))) ["Dynamic"; "String"]
                  ) else raise (__exn_37));
                let parsed = !tempParsedModule in (
                  ignore (HxArray.push out (ResolvedModule.create modulePath filePath parsed));
                  let decl = ParsedModule.getDecl parsed () in let modulePkg = HxModuleDecl.getPackagePath decl in let deps = HxArray.create () in (
                    ignore (let _g = ref 0 in let _g1 = HxModuleDecl.getImports decl in try while !_g < HxArray.length _g1 do try ignore (let rawImport = HxArray.get _g1 (!_g) in (
                      ignore (let __old_38 = !_g in let __new_39 = HxInt.add __old_38 1 in (
                        ignore (_g := __new_39);
                        __new_39
                      ));
                      let imp = normalizeImport rawImport in (
                        ignore (if imp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
                        let tempMaybeString1 = ref (Obj.magic ()) in (
                          ignore (let existsDirect = resolveModuleFile classPaths imp != Obj.magic (HxRuntime.hx_null) in if existsDirect then let __assign_40 = imp in (
                            tempMaybeString1 := __assign_40;
                            __assign_40
                          ) else let dot = HxString.indexOf imp "." 0 in let tempMaybeString2 = ref (Obj.magic ()) in (
                            ignore (if dot = -1 then let __assign_41 = imp in (
                              tempMaybeString2 := __assign_41;
                              __assign_41
                            ) else let __assign_42 = HxString.substr imp 0 dot in (
                              tempMaybeString2 := __assign_42;
                              __assign_42
                            ));
                            let head = !tempMaybeString2 in let tempMaybeNumber = ref (HxRuntime.hx_null) in (
                              ignore (if HxString.length head = 0 then let __assign_43 = Obj.repr 0 in (
                                tempMaybeNumber := __assign_43;
                                __assign_43
                              ) else let __assign_44 = HxString.charCodeAt head 0 in (
                                tempMaybeNumber := __assign_44;
                                __assign_44
                              ));
                              let head0 = !tempMaybeNumber in let headIsUpper = (let __nullable_45 = head0 in let __nullable_46 = 65 in if __nullable_45 == HxRuntime.hx_null then false else Obj.obj __nullable_45 >= __nullable_46) && (let __nullable_47 = head0 in let __nullable_48 = 90 in if __nullable_47 == HxRuntime.hx_null then false else Obj.obj __nullable_47 <= __nullable_48) in if headIsUpper && modulePkg != Obj.magic (HxRuntime.hx_null) && HxString.length modulePkg > 0 && not (StringTools.startsWith imp (HxString.toStdString modulePkg ^ ".")) then let __assign_49 = (HxString.toStdString modulePkg ^ ".") ^ HxString.toStdString imp in (
                                tempMaybeString1 := __assign_49;
                                __assign_49
                              ) else let __assign_50 = imp in (
                                tempMaybeString1 := __assign_50;
                                __assign_50
                              )
                            )
                          ));
                          let resolvedImp = !tempMaybeString1 in (
                            ignore (if StringTools.endsWith resolvedImp ".*" then ignore (let base = HxString.substr resolvedImp 0 (HxInt.sub (HxString.length resolvedImp) 2) in (
                              ignore (if resolveModuleFile classPaths base != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push deps base) else ());
                              raise (HxRuntime.Hx_continue)
                            )) else ());
                            HxArray.push deps resolvedImp
                          )
                        )
                      )
                    )) with
                      | HxRuntime.Hx_continue -> () done with
                      | HxRuntime.Hx_break -> ());
                    ignore (if resolveImplicitSamePackageTypesEnabled () then ignore (let _g = ref 0 in let _g1 = implicitSamePackageDeps filteredSource modulePath decl in while !_g < HxArray.length _g1 do ignore (let dep = HxArray.get _g1 (!_g) in (
                      ignore (let __old_51 = !_g in let __new_52 = HxInt.add __old_51 1 in (
                        ignore (_g := __new_52);
                        __new_52
                      ));
                      if resolveModuleFile classPaths dep != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push deps dep) else ()
                    )) done) else ());
                    let i = ref (HxInt.sub (HxArray.length deps) 1) in while !i >= 0 do ignore (let dep = HxArray.get deps (!i) in (
                      ignore (if dep != Obj.magic (HxRuntime.hx_null) && HxString.length dep > 0 && not (HxMap.exists_string visited dep) then ignore (HxArray.push stack dep) else ());
                      i := HxInt.sub (!i) 1
                    )) done
                  )
                )
              )
            )
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    out
  )
)

let parseProject = fun classPaths mainModule -> parseProjectRoots classPaths (let __arr_14 = HxArray.create () in (
  ignore (HxArray.push __arr_14 mainModule);
  __arr_14
)) (Obj.magic (HxRuntime.hx_null))
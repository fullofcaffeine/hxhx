# 1 "ResolverStage.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: ResolverStage *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "ResolverStage" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "ResolverStage" } : t)

let traceResolverDepsEnabled = fun () -> try let v = HxSys.getEnv "HXHX_TRACE_RESOLVER_DEPS" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  let s = HxString.toLowerCase (StringTools.trim v) () in HxString.equals s "1" || HxString.equals s "true" || HxString.equals s "yes"
) with
  | HxRuntime.Hx_return __ret_1 -> Obj.obj __ret_1

let resolveImplicitSamePackageTypesEnabled = fun () -> try let v = HxSys.getEnv "HXHX_RESOLVE_IMPLICIT_PACKAGE_TYPES" in (
  ignore (if v == Obj.magic (HxRuntime.hx_null) || HxString.length (StringTools.trim v) = 0 then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
  let s = HxString.toLowerCase (StringTools.trim v) () in (
    ignore (if HxString.equals s "0" || HxString.equals s "false" || HxString.equals s "no" then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
    HxString.equals s "1" || HxString.equals s "true" || HxString.equals s "yes"
  )
) with
  | HxRuntime.Hx_return __ret_2 -> Obj.obj __ret_2

let implicitSamePackageDeps = fun source modulePath decl -> try let pkg = HxModuleDecl.getPackagePath decl in (
  ignore (if pkg == Obj.magic (HxRuntime.hx_null) || HxString.length pkg = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_3 = HxArray.create () in __arr_3))) else ());
  let tempMaybeString = ref (Obj.magic ()) in (
    ignore (if modulePath == Obj.magic (HxRuntime.hx_null) then let __assign_4 = "" in (
      tempMaybeString := __assign_4;
      __assign_4
    ) else let __assign_5 = HxArray.pop (HxString.split modulePath ".") () in (
      tempMaybeString := __assign_5;
      __assign_5
    ));
    let candidates = HxMap.create_string () in let addMatches = fun re -> let pos = ref 0 in while EReg.matchSub re source (!pos) (Obj.magic (HxRuntime.hx_null)) do ignore (let name = EReg.matched re 1 in (
      ignore (if name != Obj.magic (HxRuntime.hx_null) && HxString.length name > 0 then ignore (HxMap.set_string candidates name true) else ());
      let mp = EReg.matchedPos re () in let __assign_6 = HxInt.add (Obj.obj (HxAnon.get mp "pos")) (Obj.obj (HxAnon.get mp "len")) in (
        pos := __assign_6;
        __assign_6
      )
    )) done in (
      ignore (addMatches (EReg.create "\\bnew\\s+([A-Z][A-Za-z0-9_]*)\\b" "g"));
      ignore (addMatches (EReg.create "\\b([A-Z][A-Za-z0-9_]*)\\s*\\." "g"));
      let names = HxArray.create () in (
        ignore (let name = HxIterator.of_array (HxMap.keys_string candidates) in while (let __iter_7 = name in fun () -> HxIterator.hasNext __iter_7) () do ignore (let name2 = (let __iter_8 = name in fun () -> HxIterator.next __iter_8) () in HxArray.push names name2) done);
        ignore (HxArray.sort names (fun a b -> let tempResult = ref 0 in (
          ignore (if a < b then let __assign_9 = -1 in (
            tempResult := __assign_9;
            __assign_9
          ) else if a > b then let __assign_10 = 1 in (
            tempResult := __assign_10;
            __assign_10
          ) else let __assign_11 = 0 in (
            tempResult := __assign_11;
            __assign_11
          ));
          !tempResult
        )));
        let out = HxArray.create () in let _g = ref 0 in (
          ignore (try while !_g < HxArray.length names do try ignore (let name = HxArray.get names (!_g) in (
            ignore (let __old_12 = !_g in let __new_13 = HxInt.add __old_12 1 in (
              ignore (_g := __new_13);
              __new_13
            ));
            ignore (if HxString.equals name (!tempMaybeString) then raise (HxRuntime.Hx_continue) else ());
            HxArray.push out ((HxString.toStdString pkg ^ ".") ^ HxString.toStdString name)
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          out
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

let implicitQualifiedTypeDeps = fun source -> try (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __arr_15 = HxArray.create () in __arr_15))) else ());
  let candidates = HxMap.create_string () in let _g = ref 0 in let _g1 = HxString.split source "\n" in (
    ignore (try while !_g < HxArray.length _g1 do try ignore (let line = HxArray.get _g1 (!_g) in (
      ignore (let __old_16 = !_g in let __new_17 = HxInt.add __old_16 1 in (
        ignore (_g := __new_17);
        __new_17
      ));
      let trimmed = StringTools.trim line in (
        ignore (if StringTools.startsWith trimmed "@:" then raise (HxRuntime.Hx_continue) else ());
        let re = EReg.create "\\b(([A-Za-z_][A-Za-z0-9_]*\\.)+[A-Z][A-Za-z0-9_]*)\\b" "g" in let pos = ref 0 in while EReg.matchSub re line (!pos) (Obj.magic (HxRuntime.hx_null)) do ignore (let dep = EReg.matched re 1 in (
          ignore (if dep != Obj.magic (HxRuntime.hx_null) && HxString.length dep > 0 then ignore (HxMap.set_string candidates dep true) else ());
          let mp = EReg.matchedPos re () in let __assign_18 = HxInt.add (Obj.obj (HxAnon.get mp "pos")) (Obj.obj (HxAnon.get mp "len")) in (
            pos := __assign_18;
            __assign_18
          )
        )) done
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    let out = HxArray.create () in (
      ignore (let dep = HxIterator.of_array (HxMap.keys_string candidates) in while (let __iter_19 = dep in fun () -> HxIterator.hasNext __iter_19) () do ignore (let dep2 = (let __iter_20 = dep in fun () -> HxIterator.next __iter_20) () in HxArray.push out dep2) done);
      ignore (HxArray.sort out (fun a b -> let tempResult = ref 0 in (
        ignore (if a < b then let __assign_21 = -1 in (
          tempResult := __assign_21;
          __assign_21
        ) else if a > b then let __assign_22 = 1 in (
          tempResult := __assign_22;
          __assign_22
        ) else let __assign_23 = 0 in (
          tempResult := __assign_23;
          __assign_23
        ));
        !tempResult
      )));
      out
    )
  )
) with
  | HxRuntime.Hx_return __ret_24 -> Obj.obj __ret_24

let normalizeImport = fun raw -> try (
  ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let s = ref (StringTools.trim raw) in (
    ignore (if HxString.length (!s) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    ignore (if StringTools.startsWith (!s) "using " then ignore (let __assign_70 = StringTools.trim (HxString.substr (!s) (HxString.length "using ") (-1)) in (
      s := __assign_70;
      __assign_70
    )) else ());
    let asIdx = HxString.indexOf (!s) " as " 0 in (
      ignore (if asIdx >= 0 then ignore (let __assign_71 = StringTools.trim (HxString.substr (!s) 0 asIdx) in (
        s := __assign_71;
        __assign_71
      )) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (if HxString.length (!s) = 0 then let __assign_72 = Obj.magic (HxRuntime.hx_null) in (
          tempResult := __assign_72;
          __assign_72
        ) else let __assign_73 = !s in (
          tempResult := __assign_73;
          __assign_73
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_74 -> Obj.obj __ret_74

let resolveModuleFile = fun classPaths modulePath -> try let fileExistsExactCase = fun path -> try (
  ignore (if path == Obj.magic (HxRuntime.hx_null) || HxString.length path = 0 then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  ignore (if not (HxFileSystem.exists path) || HxFileSystem.isDirectory path then raise (HxRuntime.Hx_return (Obj.repr false)) else ());
  let dir = Haxe_io_Path.directory path in (
    ignore (if dir == Obj.magic (HxRuntime.hx_null) || HxString.length dir = 0 then raise (HxRuntime.Hx_return (Obj.repr true)) else ());
    let base = Haxe_io_Path.withoutDirectory path in (
      ignore (try let _g = ref 0 in let _g1 = HxFileSystem.readDirectory dir in while !_g < HxArray.length _g1 do ignore (let name = HxArray.get _g1 (!_g) in (
        ignore (let __old_75 = !_g in let __new_76 = HxInt.add __old_75 1 in (
          ignore (_g := __new_76);
          __new_76
        ));
        if HxString.equals name base then raise (HxRuntime.Hx_return (Obj.repr true)) else ()
      )) done with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_77 -> raise (HxRuntime.Hx_return __ret_77)
        | HxRuntime.Hx_exception (__exn_v_78, __exn_tags_79) -> if true then let _hx = (__exn_v_78 : Obj.t) in (
          ignore _hx;
          ()
        ) else HxRuntime.hx_throw_typed __exn_v_78 __exn_tags_79
        | __exn_80 -> if true then let _hx = (Obj.repr __exn_80 : Obj.t) in (
          ignore _hx;
          ()
        ) else raise (__exn_80));
      false
    )
  )
) with
  | HxRuntime.Hx_return __ret_81 -> Obj.obj __ret_81 in let parts = HxString.split modulePath "." in (
  ignore (if HxArray.length parts = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let direct = HxString.toStdString (HxArray.join parts "/" (fun x -> x)) ^ ".hx" in (
    ignore (let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_82 = !_g in let __new_83 = HxInt.add __old_82 1 in (
        ignore (_g := __new_83);
        __new_83
      ));
      let candidate = Haxe_io_Path.join (let __arr_84 = HxArray.create () in (
        ignore (HxArray.push __arr_84 cp);
        ignore (HxArray.push __arr_84 direct);
        __arr_84
      )) in if fileExistsExactCase candidate then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done);
    ignore (if HxArray.length parts >= 2 then ignore (let fallbackParts = HxArray.slice parts 0 (HxInt.sub (HxArray.length parts) 1) in let fallback = HxString.toStdString (HxArray.join fallbackParts "/" (fun x -> x)) ^ ".hx" in let _g = ref 0 in while !_g < HxArray.length classPaths do ignore (let cp = HxArray.get classPaths (!_g) in (
      ignore (let __old_85 = !_g in let __new_86 = HxInt.add __old_85 1 in (
        ignore (_g := __new_86);
        __new_86
      ));
      let candidate = Haxe_io_Path.join (let __arr_87 = HxArray.create () in (
        ignore (HxArray.push __arr_87 cp);
        ignore (HxArray.push __arr_87 fallback);
        __arr_87
      )) in if fileExistsExactCase candidate then raise (HxRuntime.Hx_return (Obj.repr candidate)) else ()
    )) done) else ());
    Obj.magic (HxRuntime.hx_null)
  )
) with
  | HxRuntime.Hx_return __ret_88 -> Obj.obj __ret_88

let parseProjectRoots = fun classPaths roots defines -> let out = HxArray.create () in let visited = HxMap.create_string () in let tempMaybeStringMap = ref (Obj.magic ()) in (
  ignore (if defines == Obj.magic (HxRuntime.hx_null) then let __assign_26 = HxMap.create_string () in (
    tempMaybeStringMap := __assign_26;
    __assign_26
  ) else let __assign_27 = defines in (
    tempMaybeStringMap := __assign_27;
    __assign_27
  ));
  let cloneDefines = fun src -> let out2 = HxMap.create_string () in (
    ignore (if src != Obj.magic (HxRuntime.hx_null) then ignore (let k = HxIterator.of_array (HxMap.keys_string src) in while (let __iter_28 = k in fun () -> HxIterator.hasNext __iter_28) () do ignore (let k2 = (let __iter_29 = k in fun () -> HxIterator.next __iter_29) () in HxMap.set_string out2 k2 (HxMap.get_string src k2)) done) else ());
    out2
  ) in let stack = HxArray.create () in (
    ignore (if roots != Obj.magic (HxRuntime.hx_null) then ignore (let _g = ref 0 in try while !_g < HxArray.length roots do try ignore (let r = HxArray.get roots (!_g) in (
      ignore (let __old_30 = !_g in let __new_31 = HxInt.add __old_30 1 in (
        ignore (_g := __new_31);
        __new_31
      ));
      ignore (if r == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
      let m = StringTools.trim r in (
        ignore (if HxString.length m = 0 then raise (HxRuntime.Hx_continue) else ());
        HxArray.push stack m
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ()) else ());
    ignore (try while HxArray.length stack > 0 do try ignore (let modulePath = HxArray.pop stack () in (
      ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_continue) else ());
      ignore (if HxMap.exists_string visited modulePath then raise (HxRuntime.Hx_continue) else ());
      ignore (HxMap.set_string visited modulePath true);
      let filePath = resolveModuleFile classPaths modulePath in (
        ignore (if filePath == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("import_missing " ^ HxString.toStdString modulePath)) ["Dynamic"; "String"]) else ());
        let tempMaybeString = ref (Obj.magic ()) in (
          ignore (try let __assign_32 = HxFile.getContent filePath in (
            tempMaybeString := __assign_32;
            __assign_32
          ) with
            | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
            | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
            | HxRuntime.Hx_return __ret_33 -> raise (HxRuntime.Hx_return __ret_33)
            | HxRuntime.Hx_exception (__exn_v_34, __exn_tags_35) -> if true then let _hx = (__exn_v_34 : Obj.t) in (
              ignore _hx;
              let __assign_36 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_36;
                __assign_36
              )
            ) else HxRuntime.hx_throw_typed __exn_v_34 __exn_tags_35
            | __exn_37 -> if true then let _hx = (Obj.repr __exn_37 : Obj.t) in (
              ignore _hx;
              let __assign_38 = Obj.magic (HxRuntime.hx_null) in (
                tempMaybeString := __assign_38;
                __assign_38
              )
            ) else raise (__exn_37));
          let source = !tempMaybeString in (
            ignore (if source == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr ("import_unreadable " ^ HxString.toStdString filePath)) ["Dynamic"; "String"]) else ());
            let tempMaybeStringMap1 = ref (Obj.magic ()) in let tempBool = ref false in (
              ignore (if modulePath != Obj.magic (HxRuntime.hx_null) && StringTools.startsWith modulePath "haxe.macro." then let __assign_39 = true in (
                tempBool := __assign_39;
                __assign_39
              ) else if filePath == Obj.magic (HxRuntime.hx_null) || HxString.length filePath = 0 then let __assign_40 = false in (
                tempBool := __assign_40;
                __assign_40
              ) else let __assign_41 = HxString.indexOf filePath "/haxe/macro/" 0 <> -1 || HxString.indexOf filePath "\\haxe\\macro\\" 0 <> -1 in (
                tempBool := __assign_41;
                __assign_41
              ));
              ignore (if !tempBool then let m = cloneDefines (!tempMaybeStringMap) in (
                ignore (if not (HxMap.exists_string m "macro") then ignore (HxMap.set_string m "macro" "1") else ());
                ignore (if not (HxMap.exists_string m "eval") then ignore (HxMap.set_string m "eval" "1") else ());
                let __assign_42 = m in (
                  tempMaybeStringMap1 := __assign_42;
                  __assign_42
                )
              ) else let __assign_43 = !tempMaybeStringMap in (
                tempMaybeStringMap1 := __assign_43;
                __assign_43
              ));
              let effectiveDefines = !tempMaybeStringMap1 in let filteredSource = HxConditionalCompilation.filterSource source effectiveDefines in let tempParsedModule = ref (Obj.magic ()) in (
                ignore (try let __assign_44 = ParserStage.parse filteredSource filePath in (
                  tempParsedModule := __assign_44;
                  __assign_44
                ) with
                  | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
                  | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
                  | HxRuntime.Hx_return __ret_45 -> raise (HxRuntime.Hx_return __ret_45)
                  | HxRuntime.Hx_exception (__exn_v_46, __exn_tags_47) -> if true then let e = (__exn_v_46 : Obj.t) in (
                    ignore e;
                    HxType.hx_throw_typed_rtti (Obj.repr ((("parse_failed " ^ HxString.toStdString filePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e))) ["Dynamic"; "String"]
                  ) else HxRuntime.hx_throw_typed __exn_v_46 __exn_tags_47
                  | __exn_48 -> if true then let e = (Obj.repr __exn_48 : Obj.t) in (
                    ignore e;
                    HxType.hx_throw_typed_rtti (Obj.repr ((("parse_failed " ^ HxString.toStdString filePath) ^ ": ") ^ HxString.toStdString (HxRuntime.dynamic_toStdString e))) ["Dynamic"; "String"]
                  ) else raise (__exn_48));
                let parsed = !tempParsedModule in (
                  ignore (HxArray.push out (ResolvedModule.create modulePath filePath parsed));
                  let decl = ParsedModule.getDecl parsed () in let modulePkg = HxModuleDecl.getPackagePath decl in let deps = HxArray.create () in (
                    ignore (let _g = ref 0 in let _g1 = HxModuleDecl.getImports decl in try while !_g < HxArray.length _g1 do try ignore (let rawImport = HxArray.get _g1 (!_g) in (
                      ignore (let __old_49 = !_g in let __new_50 = HxInt.add __old_49 1 in (
                        ignore (_g := __new_50);
                        __new_50
                      ));
                      let imp = normalizeImport rawImport in (
                        ignore (if imp == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
                        let tempMaybeString1 = ref (Obj.magic ()) in (
                          ignore (let existsDirect = resolveModuleFile classPaths imp != Obj.magic (HxRuntime.hx_null) in if existsDirect then let __assign_51 = imp in (
                            tempMaybeString1 := __assign_51;
                            __assign_51
                          ) else let dot = HxString.indexOf imp "." 0 in let tempMaybeString2 = ref (Obj.magic ()) in (
                            ignore (if dot = -1 then let __assign_52 = imp in (
                              tempMaybeString2 := __assign_52;
                              __assign_52
                            ) else let __assign_53 = HxString.substr imp 0 dot in (
                              tempMaybeString2 := __assign_53;
                              __assign_53
                            ));
                            let head = !tempMaybeString2 in let tempMaybeNumber = ref (HxRuntime.hx_null) in (
                              ignore (if HxString.length head = 0 then let __assign_54 = Obj.repr 0 in (
                                tempMaybeNumber := __assign_54;
                                __assign_54
                              ) else let __assign_55 = HxString.charCodeAt head 0 in (
                                tempMaybeNumber := __assign_55;
                                __assign_55
                              ));
                              let head0 = !tempMaybeNumber in let headIsUpper = (let __nullable_56 = head0 in let __nullable_57 = 65 in if __nullable_56 == HxRuntime.hx_null then false else Obj.obj __nullable_56 >= __nullable_57) && (let __nullable_58 = head0 in let __nullable_59 = 90 in if __nullable_58 == HxRuntime.hx_null then false else Obj.obj __nullable_58 <= __nullable_59) in if headIsUpper && modulePkg != Obj.magic (HxRuntime.hx_null) && HxString.length modulePkg > 0 && not (StringTools.startsWith imp (HxString.toStdString modulePkg ^ ".")) then let __assign_60 = (HxString.toStdString modulePkg ^ ".") ^ HxString.toStdString imp in (
                                tempMaybeString1 := __assign_60;
                                __assign_60
                              ) else let __assign_61 = imp in (
                                tempMaybeString1 := __assign_61;
                                __assign_61
                              )
                            )
                          ));
                          let resolvedImp = !tempMaybeString1 in (
                            ignore (if StringTools.endsWith resolvedImp ".*" then ignore (let base = HxString.substr resolvedImp 0 (HxInt.sub (HxString.length resolvedImp) 2) in (
                              ignore (if resolveModuleFile classPaths base != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push deps base) else ());
                              raise (HxRuntime.Hx_continue)
                            )) else ());
                            HxArray.push deps resolvedImp
                          )
                        )
                      )
                    )) with
                      | HxRuntime.Hx_continue -> () done with
                      | HxRuntime.Hx_break -> ());
                    let traceDeps = traceResolverDepsEnabled () in (
                      ignore (if resolveImplicitSamePackageTypesEnabled () then ignore (let _g = ref 0 in let _g1 = implicitSamePackageDeps filteredSource modulePath decl in while !_g < HxArray.length _g1 do ignore (let dep = HxArray.get _g1 (!_g) in (
                        ignore (let __old_62 = !_g in let __new_63 = HxInt.add __old_62 1 in (
                          ignore (_g := __new_63);
                          __new_63
                        ));
                        let exists = resolveModuleFile classPaths dep != Obj.magic (HxRuntime.hx_null) in (
                          ignore (if traceDeps then ignore (let tempString = ref "" in (
                            ignore (if exists then let __assign_64 = "1" in (
                              tempString := __assign_64;
                              __assign_64
                            ) else let __assign_65 = "0" in (
                              tempString := __assign_65;
                              __assign_65
                            ));
                            print_endline ((((("resolver_samepkg_dep module=" ^ HxString.toStdString modulePath) ^ " dep=") ^ HxString.toStdString dep) ^ " exists=") ^ HxString.toStdString (!tempString))
                          )) else ());
                          if exists then ignore (HxArray.push deps dep) else ()
                        )
                      )) done) else ());
                      ignore (let _g = ref 0 in let _g1 = implicitQualifiedTypeDeps filteredSource in while !_g < HxArray.length _g1 do ignore (let dep = HxArray.get _g1 (!_g) in (
                        ignore (let __old_66 = !_g in let __new_67 = HxInt.add __old_66 1 in (
                          ignore (_g := __new_67);
                          __new_67
                        ));
                        let exists = resolveModuleFile classPaths dep != Obj.magic (HxRuntime.hx_null) in (
                          ignore (if traceDeps then ignore (let tempString1 = ref "" in (
                            ignore (if exists then let __assign_68 = "1" in (
                              tempString1 := __assign_68;
                              __assign_68
                            ) else let __assign_69 = "0" in (
                              tempString1 := __assign_69;
                              __assign_69
                            ));
                            print_endline ((((("resolver_qualified_dep module=" ^ HxString.toStdString modulePath) ^ " dep=") ^ HxString.toStdString dep) ^ " exists=") ^ HxString.toStdString (!tempString1))
                          )) else ());
                          if exists then ignore (HxArray.push deps dep) else ()
                        )
                      )) done);
                      let i = ref (HxInt.sub (HxArray.length deps) 1) in while !i >= 0 do ignore (let dep = HxArray.get deps (!i) in (
                        ignore (if dep != Obj.magic (HxRuntime.hx_null) && HxString.length dep > 0 && not (HxMap.exists_string visited dep) then ignore (HxArray.push stack dep) else ());
                        i := HxInt.sub (!i) 1
                      )) done
                    )
                  )
                )
              )
            )
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    out
  )
)

let parseProject = fun classPaths mainModule -> parseProjectRoots classPaths (let __arr_25 = HxArray.create () in (
  ignore (HxArray.push __arr_25 mainModule);
  __arr_25
)) (Obj.magic (HxRuntime.hx_null))
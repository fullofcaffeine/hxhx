# 1 "hxhx_DisplayResponseSynthesizer.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhx.DisplayResponseSynthesizer *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhx.DisplayResponseSynthesizer" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhx.DisplayResponseSynthesizer" } : t)

let parseStrictInt = fun text -> try (
  ignore (if text == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let trimmed = StringTools.trim text in (
    ignore (if HxString.length trimmed = 0 then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
    let start = ref 0 in (
      ignore (if let __nullable_1 = HxString.charCodeAt trimmed 0 in if __nullable_1 == HxRuntime.hx_null then false else Obj.obj __nullable_1 = 45 then ignore ((
        ignore (if HxString.length trimmed = 1 then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
        let __assign_2 = 1 in (
          start := __assign_2;
          __assign_2
        )
      )) else ());
      let _g = ref (!start) in let _g1 = HxString.length trimmed in (
        ignore (while !_g < _g1 do ignore (let index = let __old_3 = !_g in let __new_4 = HxInt.add __old_3 1 in (
          ignore (_g := __new_4);
          __old_3
        ) in let code = HxString.charCodeAt trimmed index in if (let __nullable_5 = code in let __nullable_6 = 48 in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 < __nullable_6) || (let __nullable_7 = code in let __nullable_8 = 57 in if __nullable_7 == HxRuntime.hx_null then false else Obj.obj __nullable_7 > __nullable_8) then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ()) done);
        let parsed = Std.parseInt trimmed in let tempResult = ref 0 in (
          ignore (if parsed == HxRuntime.hx_null then let __assign_9 = -1 in (
            tempResult := __assign_9;
            __assign_9
          ) else let __assign_10 = let __nullable_int_11 = parsed in if __nullable_int_11 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_11 in (
            tempResult := __assign_10;
            __assign_10
          ));
          !tempResult
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_12 -> Obj.obj __ret_12

let parseDisplayRequestQuery = fun displayRequest -> try (
  ignore (if displayRequest == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (let __anon_13 = HxAnon.create () in (
    ignore (HxAnon.set __anon_13 "sourcePath" (Obj.repr ""));
    ignore (HxAnon.set __anon_13 "cursorOffset" (Obj.repr (-1)));
    ignore (HxAnon.set __anon_13 "mode" (Obj.repr ""));
    __anon_13
  )))) else ());
  let trimmed = StringTools.trim displayRequest in (
    ignore (if HxString.length trimmed = 0 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_14 = HxAnon.create () in (
      ignore (HxAnon.set __anon_14 "sourcePath" (Obj.repr ""));
      ignore (HxAnon.set __anon_14 "cursorOffset" (Obj.repr (-1)));
      ignore (HxAnon.set __anon_14 "mode" (Obj.repr ""));
      __anon_14
    )))) else ());
    let at = HxString.indexOf trimmed "@" 0 in (
      ignore (if at = -1 then raise (HxRuntime.Hx_return (Obj.repr (let __anon_15 = HxAnon.create () in (
        ignore (HxAnon.set __anon_15 "sourcePath" (Obj.repr trimmed));
        ignore (HxAnon.set __anon_15 "cursorOffset" (Obj.repr (-1)));
        ignore (HxAnon.set __anon_15 "mode" (Obj.repr ""));
        __anon_15
      )))) else ());
      let sourcePath = HxString.substr trimmed 0 at in let tail = HxString.substr trimmed (HxInt.add at 1) (-1) in let secondAt = HxString.indexOf tail "@" 0 in let cursorOffset = ref (-1) in let mode = ref "" in (
        ignore (if secondAt = -1 then ignore (let cursor = parseStrictInt tail in if cursor >= 0 then ignore (let __assign_16 = cursor in (
          cursorOffset := __assign_16;
          __assign_16
        )) else ignore (let __assign_17 = tail in (
          mode := __assign_17;
          __assign_17
        ))) else ignore (let cursorText = HxString.substr tail 0 secondAt in let cursor = parseStrictInt cursorText in if cursor >= 0 then ignore ((
          ignore (let __assign_18 = cursor in (
            cursorOffset := __assign_18;
            __assign_18
          ));
          let __assign_19 = HxString.substr tail (HxInt.add secondAt 1) (-1) in (
            mode := __assign_19;
            __assign_19
          )
        )) else ignore (let __assign_20 = tail in (
          mode := __assign_20;
          __assign_20
        ))));
        let __anon_21 = HxAnon.create () in (
          ignore (HxAnon.set __anon_21 "sourcePath" (Obj.repr sourcePath));
          ignore (HxAnon.set __anon_21 "cursorOffset" (Obj.repr (!cursorOffset)));
          ignore (HxAnon.set __anon_21 "mode" (Obj.repr (!mode)));
          __anon_21
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_22 -> Obj.obj __ret_22

let readDisplaySource = fun displayRequest stdinBytes -> try let query = parseDisplayRequestQuery displayRequest in (
  ignore (if stdinBytes != Obj.magic (HxRuntime.hx_null) && HxBytes.length stdinBytes > 0 then raise (HxRuntime.Hx_return (Obj.repr (HxBytes.getString stdinBytes 0 (HxBytes.length stdinBytes) ()))) else ());
  ignore (if Obj.obj (HxAnon.get query "sourcePath") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get query "sourcePath")) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  ignore (if not (HxFileSystem.exists (Obj.obj (HxAnon.get query "sourcePath"))) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  ignore (if HxFileSystem.isDirectory (Obj.obj (HxAnon.get query "sourcePath")) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let tempResult = ref "" in (
    ignore (try let path = Obj.obj (HxAnon.get query "sourcePath") in let __assign_23 = HxFile.getContent path in (
      tempResult := __assign_23;
      __assign_23
    ) with
      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
      | HxRuntime.Hx_return __ret_24 -> raise (HxRuntime.Hx_return __ret_24)
      | HxRuntime.Hx_exception (__exn_v_25, __exn_tags_26) -> if HxRuntime.tags_has __exn_tags_26 "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" __exn_v_25) : Haxe_io_Error.error) in (
        ignore _hx;
        let __assign_28 = "" in (
          tempResult := __assign_28;
          __assign_28
        )
      ) else if HxRuntime.tags_has __exn_tags_26 "String" then let _hx = (Obj.obj __exn_v_25 : string) in (
        ignore _hx;
        let __assign_27 = "" in (
          tempResult := __assign_27;
          __assign_27
        )
      ) else HxRuntime.hx_throw_typed __exn_v_25 __exn_tags_26
      | __exn_29 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Error" then let _hx = (Obj.obj (HxEnum.unbox_or_obj "haxe.io.Error" (Obj.repr __exn_29)) : Haxe_io_Error.error) in (
        ignore _hx;
        let __assign_31 = "" in (
          tempResult := __assign_31;
          __assign_31
        )
      ) else if HxRuntime.tags_has ["OcamlExn"] "String" then let _hx = (Obj.obj (Obj.repr __exn_29) : string) in (
        ignore _hx;
        let __assign_30 = "" in (
          tempResult := __assign_30;
          __assign_30
        )
      ) else raise (__exn_29));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_32 -> Obj.obj __ret_32

let isIdentStart = fun code -> code >= 65 && code <= 90 || code >= 97 && code <= 122 || code = 95

let isIdentContinue = fun code -> code >= 65 && code <= 90 || code >= 97 && code <= 122 || code = 95 || code >= 48 && code <= 57

let tokenizeDisplaySource = fun source -> try let out = HxArray.create () in (
  ignore (if source == Obj.magic (HxRuntime.hx_null) || HxString.length source = 0 then raise (HxRuntime.Hx_return (Obj.repr out)) else ());
  let index = ref 0 in (
    ignore (try while !index < HxString.length source do try ignore (let code = HxString.charCodeAt source (!index) in (
      ignore (if (let __nullable_33 = code in if __nullable_33 == HxRuntime.hx_null then false else Obj.obj __nullable_33 = 32) || (let __nullable_34 = code in if __nullable_34 == HxRuntime.hx_null then false else Obj.obj __nullable_34 = 9) || (let __nullable_35 = code in if __nullable_35 == HxRuntime.hx_null then false else Obj.obj __nullable_35 = 13) || (let __nullable_36 = code in if __nullable_36 == HxRuntime.hx_null then false else Obj.obj __nullable_36 = 10) then ignore ((
        ignore (index := HxInt.add (!index) 1);
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if (let __nullable_37 = code in if __nullable_37 == HxRuntime.hx_null then false else Obj.obj __nullable_37 = 47) && HxInt.add (!index) 1 < HxString.length source && (let __nullable_38 = HxString.charCodeAt source (HxInt.add (!index) 1) in if __nullable_38 == HxRuntime.hx_null then false else Obj.obj __nullable_38 = 47) then ignore ((
        ignore (index := HxInt.add (!index) 2);
        ignore (while !index < HxString.length source && not (let __nullable_39 = HxString.charCodeAt source (!index) in if __nullable_39 == HxRuntime.hx_null then false else Obj.obj __nullable_39 = 10) do ignore (index := HxInt.add (!index) 1) done);
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if (let __nullable_40 = code in if __nullable_40 == HxRuntime.hx_null then false else Obj.obj __nullable_40 = 47) && HxInt.add (!index) 1 < HxString.length source && (let __nullable_41 = HxString.charCodeAt source (HxInt.add (!index) 1) in if __nullable_41 == HxRuntime.hx_null then false else Obj.obj __nullable_41 = 42) then ignore ((
        ignore (index := HxInt.add (!index) 2);
        ignore (try while HxInt.add (!index) 1 < HxString.length source do try ignore ((
          ignore (if (let __nullable_42 = HxString.charCodeAt source (!index) in if __nullable_42 == HxRuntime.hx_null then false else Obj.obj __nullable_42 = 42) && (let __nullable_43 = HxString.charCodeAt source (HxInt.add (!index) 1) in if __nullable_43 == HxRuntime.hx_null then false else Obj.obj __nullable_43 = 47) then ignore ((
            ignore (index := HxInt.add (!index) 2);
            raise (HxRuntime.Hx_break)
          )) else ());
          index := HxInt.add (!index) 1
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        raise (HxRuntime.Hx_continue)
      )) else ());
      ignore (if (let __nullable_44 = code in if __nullable_44 == HxRuntime.hx_null then false else Obj.obj __nullable_44 = 34) || (let __nullable_45 = code in if __nullable_45 == HxRuntime.hx_null then false else Obj.obj __nullable_45 = 39) then ignore (let quote = code in let start = !index in (
        ignore (index := HxInt.add (!index) 1);
        ignore (try while !index < HxString.length source do try ignore (let current = HxString.charCodeAt source (!index) in (
          ignore (if let __nullable_46 = current in if __nullable_46 == HxRuntime.hx_null then false else Obj.obj __nullable_46 = 92 then ignore ((
            ignore (index := HxInt.add (!index) 2);
            raise (HxRuntime.Hx_continue)
          )) else ());
          ignore (index := HxInt.add (!index) 1);
          if let __nullable_47 = current in let __nullable_48 = quote in if __nullable_47 == HxRuntime.hx_null then __nullable_47 == HxRuntime.hx_null && __nullable_48 == HxRuntime.hx_null else not (__nullable_48 == HxRuntime.hx_null) && Obj.obj __nullable_47 = Obj.obj __nullable_48 then raise (HxRuntime.Hx_break) else ()
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        ignore (HxArray.push out (let __anon_49 = HxAnon.create () in (
          ignore (HxAnon.set __anon_49 "text" (Obj.repr (HxString.substr source start (HxInt.sub (!index) start))));
          ignore (HxAnon.set __anon_49 "start" (Obj.repr start));
          ignore (HxAnon.set __anon_49 "end" (Obj.repr (!index)));
          ignore (HxAnon.set __anon_49 "isIdent" (Obj.repr false));
          __anon_49
        )));
        raise (HxRuntime.Hx_continue)
      )) else ());
      let tempBool = ref false in (
        ignore (let code2 = let __nullable_int_50 = code in if __nullable_int_50 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_50 in let __assign_51 = code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122 || code2 = 95 in (
          tempBool := __assign_51;
          __assign_51
        ));
        ignore (if !tempBool then ignore (let start = !index in (
          ignore (index := HxInt.add (!index) 1);
          ignore (try while true do try ignore (let tempRight = ref false in (
            ignore (let code2 = let __nullable_int_52 = HxString.charCodeAt source (!index) in if __nullable_int_52 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_52 in let __assign_53 = code2 >= 65 && code2 <= 90 || code2 >= 97 && code2 <= 122 || code2 = 95 || code2 >= 48 && code2 <= 57 in (
              tempRight := __assign_53;
              __assign_53
            ));
            ignore (if not (!index < HxString.length source && !tempRight) then raise (HxRuntime.Hx_break) else ());
            index := HxInt.add (!index) 1
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          ignore (HxArray.push out (let __anon_54 = HxAnon.create () in (
            ignore (HxAnon.set __anon_54 "text" (Obj.repr (HxString.substr source start (HxInt.sub (!index) start))));
            ignore (HxAnon.set __anon_54 "start" (Obj.repr start));
            ignore (HxAnon.set __anon_54 "end" (Obj.repr (!index)));
            ignore (HxAnon.set __anon_54 "isIdent" (Obj.repr true));
            __anon_54
          )));
          raise (HxRuntime.Hx_continue)
        )) else ());
        ignore (HxArray.push out (let __anon_55 = HxAnon.create () in (
          ignore (HxAnon.set __anon_55 "text" (Obj.repr (HxString.fromCharCode (let __nullable_int_56 = code in if __nullable_int_56 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_56))));
          ignore (HxAnon.set __anon_55 "start" (Obj.repr (!index)));
          ignore (HxAnon.set __anon_55 "end" (Obj.repr (HxInt.add (!index) 1)));
          ignore (HxAnon.set __anon_55 "isIdent" (Obj.repr false));
          __anon_55
        )));
        index := HxInt.add (!index) 1
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    out
  )
) with
  | HxRuntime.Hx_return __ret_57 -> Obj.obj __ret_57

let findMatchingCloseToken = fun tokens openIndex openSymbol closeSymbol -> try (
  ignore (if tokens == Obj.magic (HxRuntime.hx_null) || openIndex < 0 || openIndex >= HxArray.length tokens then raise (HxRuntime.Hx_return (Obj.repr (-1))) else ());
  let depth = ref 0 in let _g = ref openIndex in let _g1 = HxArray.length tokens in (
    ignore (while !_g < _g1 do ignore (let tokenIndex = let __old_58 = !_g in let __new_59 = HxInt.add __old_58 1 in (
      ignore (_g := __new_59);
      __old_58
    ) in let token = HxArray.get tokens tokenIndex in if HxString.equals (Obj.obj (HxAnon.get token "text")) openSymbol then ignore (depth := HxInt.add (!depth) 1) else ignore (if HxString.equals (Obj.obj (HxAnon.get token "text")) closeSymbol then ignore ((
      ignore (depth := HxInt.sub (!depth) 1);
      if !depth = 0 then raise (HxRuntime.Hx_return (Obj.repr tokenIndex)) else ()
    )) else ())) done);
    -1
  )
) with
  | HxRuntime.Hx_return __ret_60 -> Obj.obj __ret_60

let countArgumentIndexBeforeToken = fun tokens openParenIndex boundaryIndex -> let depthParen = ref 0 in let depthBrace = ref 0 in let depthBracket = ref 0 in let depthAngle = ref 0 in let argumentIndex = ref 0 in let _g = ref (HxInt.add openParenIndex 1) in let _g1 = boundaryIndex in (
  ignore (while !_g < _g1 do ignore (let tokenIndex = let __old_61 = !_g in let __new_62 = HxInt.add __old_61 1 in (
    ignore (_g := __new_62);
    __old_61
  ) in let token = HxArray.get tokens tokenIndex in let text = Obj.obj (HxAnon.get token "text") in match text with
    | "(" -> ignore (depthParen := HxInt.add (!depthParen) 1)
    | ")" -> ignore (if !depthParen > 0 then ignore (depthParen := HxInt.sub (!depthParen) 1) else ())
    | "," -> ignore (if !depthParen = 0 && !depthBrace = 0 && !depthBracket = 0 && !depthAngle = 0 then ignore (argumentIndex := HxInt.add (!argumentIndex) 1) else ())
    | "<" -> ignore (depthAngle := HxInt.add (!depthAngle) 1)
    | ">" -> ignore (if !depthAngle > 0 then ignore (depthAngle := HxInt.sub (!depthAngle) 1) else ())
    | "[" -> ignore (depthBracket := HxInt.add (!depthBracket) 1)
    | "]" -> ignore (if !depthBracket > 0 then ignore (depthBracket := HxInt.sub (!depthBracket) 1) else ())
    | "{" -> ignore (depthBrace := HxInt.add (!depthBrace) 1)
    | "}" -> ignore (if !depthBrace > 0 then ignore (depthBrace := HxInt.sub (!depthBrace) 1) else ())
    | _ -> ignore ()) done);
  !argumentIndex
)

let findCallNameBeforeParen = fun tokens openParenIndex -> try let tokenIndex = ref (HxInt.sub openParenIndex 1) in (
  ignore (while !tokenIndex >= 0 do ignore (let token = HxArray.get tokens (!tokenIndex) in (
    ignore (if Obj.obj (HxAnon.get token "isIdent") then raise (HxRuntime.Hx_return (Obj.repr (Obj.obj (HxAnon.get token "text")))) else ());
    ignore (if HxString.equals (Obj.obj (HxAnon.get token "text")) ")" || HxString.equals (Obj.obj (HxAnon.get token "text")) "}" || HxString.equals (Obj.obj (HxAnon.get token "text")) "]" then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    tokenIndex := HxInt.sub (!tokenIndex) 1
  )) done);
  ""
) with
  | HxRuntime.Hx_return __ret_63 -> Obj.obj __ret_63

let extractArgTypeHintFromSegment = fun source tokens segmentStart segmentEnd -> try (
  ignore (if segmentStart >= segmentEnd then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let depthParenOuter = ref 0 in let depthBraceOuter = ref 0 in let depthBracketOuter = ref 0 in let depthAngleOuter = ref 0 in let colonIndex = ref (-1) in (
    ignore (let _g = ref segmentStart in let _g1 = segmentEnd in try while !_g < _g1 do try ignore (let tokenIndex = let __old_64 = !_g in let __new_65 = HxInt.add __old_64 1 in (
      ignore (_g := __new_65);
      __old_64
    ) in let token = HxArray.get tokens tokenIndex in (
      ignore (let _g2 = Obj.obj (HxAnon.get token "text") in match _g2 with
        | "(" -> ignore (depthParenOuter := HxInt.add (!depthParenOuter) 1)
        | ")" -> ignore (if !depthParenOuter > 0 then ignore (depthParenOuter := HxInt.sub (!depthParenOuter) 1) else ())
        | ":" -> ignore (if !depthParenOuter = 0 && !depthBraceOuter = 0 && !depthBracketOuter = 0 && !depthAngleOuter = 0 then ignore ((
          ignore (let __assign_66 = tokenIndex in (
            colonIndex := __assign_66;
            __assign_66
          ));
          raise (HxRuntime.Hx_break)
        )) else ())
        | "<" -> ignore (depthAngleOuter := HxInt.add (!depthAngleOuter) 1)
        | ">" -> ignore (if !depthAngleOuter > 0 then ignore (depthAngleOuter := HxInt.sub (!depthAngleOuter) 1) else ())
        | "[" -> ignore (depthBracketOuter := HxInt.add (!depthBracketOuter) 1)
        | "]" -> ignore (if !depthBracketOuter > 0 then ignore (depthBracketOuter := HxInt.sub (!depthBracketOuter) 1) else ())
        | "{" -> ignore (depthBraceOuter := HxInt.add (!depthBraceOuter) 1)
        | "}" -> ignore (if !depthBraceOuter > 0 then ignore (depthBraceOuter := HxInt.sub (!depthBraceOuter) 1) else ())
        | _ -> ignore ());
      if !colonIndex >= 0 then raise (HxRuntime.Hx_break) else ()
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ignore (if !colonIndex < 0 || HxInt.add (!colonIndex) 1 >= segmentEnd then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let typeStartIndex = HxInt.add (!colonIndex) 1 in let depthParenInner = ref 0 in let depthBraceInner = ref 0 in let depthBracketInner = ref 0 in let depthAngleInner = ref 0 in let typeEndIndex = ref segmentEnd in (
      ignore (let _g = ref typeStartIndex in let _g1 = segmentEnd in try while !_g < _g1 do try ignore (let tokenIndex = let __old_67 = !_g in let __new_68 = HxInt.add __old_67 1 in (
        ignore (_g := __new_68);
        __old_67
      ) in let token = HxArray.get tokens tokenIndex in (
        ignore (let _g2 = Obj.obj (HxAnon.get token "text") in match _g2 with
          | "(" -> ignore (depthParenInner := HxInt.add (!depthParenInner) 1)
          | ")" -> ignore (if !depthParenInner > 0 then ignore (depthParenInner := HxInt.sub (!depthParenInner) 1) else ())
          | "<" -> ignore (depthAngleInner := HxInt.add (!depthAngleInner) 1)
          | "=" -> ignore (if !depthParenInner = 0 && !depthBraceInner = 0 && !depthBracketInner = 0 && !depthAngleInner = 0 then ignore ((
            ignore (let __assign_69 = tokenIndex in (
              typeEndIndex := __assign_69;
              __assign_69
            ));
            raise (HxRuntime.Hx_break)
          )) else ())
          | ">" -> ignore (if !depthAngleInner > 0 then ignore (depthAngleInner := HxInt.sub (!depthAngleInner) 1) else ())
          | "[" -> ignore (depthBracketInner := HxInt.add (!depthBracketInner) 1)
          | "]" -> ignore (if !depthBracketInner > 0 then ignore (depthBracketInner := HxInt.sub (!depthBracketInner) 1) else ())
          | "{" -> ignore (depthBraceInner := HxInt.add (!depthBraceInner) 1)
          | "}" -> ignore (if !depthBraceInner > 0 then ignore (depthBraceInner := HxInt.sub (!depthBraceInner) 1) else ())
          | _ -> ignore ());
        if !typeEndIndex <> segmentEnd then raise (HxRuntime.Hx_break) else ()
      )) with
        | HxRuntime.Hx_continue -> () done with
        | HxRuntime.Hx_break -> ());
      ignore (if typeStartIndex >= !typeEndIndex then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
      let startPos = Obj.obj (HxAnon.get (HxArray.get tokens typeStartIndex) "start") in let endPos = Obj.obj (HxAnon.get (HxArray.get tokens (HxInt.sub (!typeEndIndex) 1)) "end") in (
        ignore (if startPos < 0 || endPos <= startPos || endPos > HxString.length source then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
        StringTools.trim (HxString.substr source startPos (HxInt.sub endPos startPos))
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_70 -> Obj.obj __ret_70

let findFunctionArgTypeHint = fun source tokens functionName argumentIndex -> try (
  ignore (if functionName == Obj.magic (HxRuntime.hx_null) || HxString.length functionName = 0 || argumentIndex < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let _g = ref 0 in let _g1 = HxArray.length tokens in (
    ignore (try while !_g < _g1 do try ignore (let tokenIndex = let __old_71 = !_g in let __new_72 = HxInt.add __old_71 1 in (
      ignore (_g := __new_72);
      __old_71
    ) in (
      ignore (if not (Obj.obj (HxAnon.get (HxArray.get tokens tokenIndex) "isIdent")) || not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens tokenIndex) "text")) "function") then raise (HxRuntime.Hx_continue) else ());
      let nameIndex = ref (HxInt.add tokenIndex 1) in (
        ignore (while !nameIndex < HxArray.length tokens && not (Obj.obj (HxAnon.get (HxArray.get tokens (!nameIndex)) "isIdent")) do ignore (nameIndex := HxInt.add (!nameIndex) 1) done);
        ignore (if !nameIndex >= HxArray.length tokens then raise (HxRuntime.Hx_continue) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens (!nameIndex)) "text")) functionName) then raise (HxRuntime.Hx_continue) else ());
        let openParenIndex = ref (HxInt.add (!nameIndex) 1) in (
          ignore (while !openParenIndex < HxArray.length tokens && not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens (!openParenIndex)) "text")) "(") do ignore (openParenIndex := HxInt.add (!openParenIndex) 1) done);
          ignore (if !openParenIndex >= HxArray.length tokens then raise (HxRuntime.Hx_continue) else ());
          let closeParenIndex = findMatchingCloseToken tokens (!openParenIndex) "(" ")" in (
            ignore (if closeParenIndex < 0 then raise (HxRuntime.Hx_continue) else ());
            let depthParen = ref 0 in let depthBrace = ref 0 in let depthBracket = ref 0 in let depthAngle = ref 0 in let currentArgument = ref 0 in let segmentStart = ref (HxInt.add (!openParenIndex) 1) in let foundSegmentStart = ref (-1) in let foundSegmentEnd = ref (-1) in let _g2 = ref (HxInt.add (!openParenIndex) 1) in let _g3 = HxInt.add closeParenIndex 1 in (
              ignore (try while !_g2 < _g3 do try ignore (let segmentIndex = let __old_73 = !_g2 in let __new_74 = HxInt.add __old_73 1 in (
                ignore (_g2 := __new_74);
                __old_73
              ) in let boundary = segmentIndex = closeParenIndex in let tempMaybeStruct = ref (Obj.magic ()) in (
                ignore (if boundary then let __assign_75 = HxRuntime.hx_null in (
                  tempMaybeStruct := __assign_75;
                  __assign_75
                ) else let __assign_76 = HxArray.get tokens segmentIndex in (
                  tempMaybeStruct := __assign_76;
                  __assign_76
                ));
                let token = !tempMaybeStruct in let atTopLevelComma = not (boundary) && HxString.equals (Obj.obj (HxAnon.get token "text")) "," && !depthParen = 0 && !depthBrace = 0 && !depthBracket = 0 && !depthAngle = 0 in (
                  ignore (if boundary || atTopLevelComma then ignore ((
                    ignore (if !currentArgument = argumentIndex then ignore ((
                      ignore (let __assign_77 = !segmentStart in (
                        foundSegmentStart := __assign_77;
                        __assign_77
                      ));
                      ignore (let __assign_78 = segmentIndex in (
                        foundSegmentEnd := __assign_78;
                        __assign_78
                      ));
                      raise (HxRuntime.Hx_break)
                    )) else ());
                    ignore (currentArgument := HxInt.add (!currentArgument) 1);
                    ignore (let __assign_79 = HxInt.add segmentIndex 1 in (
                      segmentStart := __assign_79;
                      __assign_79
                    ));
                    raise (HxRuntime.Hx_continue)
                  )) else ());
                  let _g4 = Obj.obj (HxAnon.get token "text") in match _g4 with
                    | "(" -> ignore (depthParen := HxInt.add (!depthParen) 1)
                    | ")" -> ignore (if !depthParen > 0 then ignore (depthParen := HxInt.sub (!depthParen) 1) else ())
                    | "<" -> ignore (depthAngle := HxInt.add (!depthAngle) 1)
                    | ">" -> ignore (if !depthAngle > 0 then ignore (depthAngle := HxInt.sub (!depthAngle) 1) else ())
                    | "[" -> ignore (depthBracket := HxInt.add (!depthBracket) 1)
                    | "]" -> ignore (if !depthBracket > 0 then ignore (depthBracket := HxInt.sub (!depthBracket) 1) else ())
                    | "{" -> ignore (depthBrace := HxInt.add (!depthBrace) 1)
                    | "}" -> ignore (if !depthBrace > 0 then ignore (depthBrace := HxInt.sub (!depthBrace) 1) else ())
                    | _ -> ignore ()
                )
              )) with
                | HxRuntime.Hx_continue -> () done with
                | HxRuntime.Hx_break -> ());
              if !foundSegmentStart >= 0 && !foundSegmentEnd > !foundSegmentStart then raise (HxRuntime.Hx_return (Obj.repr (extractArgTypeHintFromSegment source tokens (!foundSegmentStart) (!foundSegmentEnd)))) else ()
            )
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ""
  )
) with
  | HxRuntime.Hx_return __ret_80 -> Obj.obj __ret_80

let compactWhitespace = fun text -> try (
  ignore (if text == Obj.magic (HxRuntime.hx_null) || HxString.length text = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let out = StringBuf.create () in let _g = ref 0 in let _g1 = HxString.length text in (
    ignore (try while !_g < _g1 do try ignore (let index = let __old_81 = !_g in let __new_82 = HxInt.add __old_81 1 in (
      ignore (_g := __new_82);
      __old_81
    ) in let code = HxString.charCodeAt text index in (
      ignore (if (let __nullable_83 = code in if __nullable_83 == HxRuntime.hx_null then false else Obj.obj __nullable_83 = 32) || (let __nullable_84 = code in if __nullable_84 == HxRuntime.hx_null then false else Obj.obj __nullable_84 = 9) || (let __nullable_85 = code in if __nullable_85 == HxRuntime.hx_null then false else Obj.obj __nullable_85 = 13) || (let __nullable_86 = code in if __nullable_86 == HxRuntime.hx_null then false else Obj.obj __nullable_86 = 10) then raise (HxRuntime.Hx_continue) else ());
      StringBuf.addChar out (let __nullable_int_87 = code in if __nullable_int_87 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_87)
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    StringBuf.toString out ()
  )
) with
  | HxRuntime.Hx_return __ret_88 -> Obj.obj __ret_88

let extractExprOfInner = fun typeHint -> try let compact = compactWhitespace typeHint in (
  ignore (if HxString.length compact = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let marker = "ExprOf<" in let markerIndex = HxString.indexOf compact marker 0 in (
    ignore (if markerIndex < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let innerStart = HxInt.add markerIndex (HxString.length marker) in let depth = ref 1 in let _g = ref innerStart in let _g1 = HxString.length compact in (
      ignore (while !_g < _g1 do ignore (let index = let __old_89 = !_g in let __new_90 = HxInt.add __old_89 1 in (
        ignore (_g := __new_90);
        __old_89
      ) in let code = HxString.charCodeAt compact index in if let __nullable_91 = code in if __nullable_91 == HxRuntime.hx_null then false else Obj.obj __nullable_91 = 60 then ignore (depth := HxInt.add (!depth) 1) else ignore (if let __nullable_92 = code in if __nullable_92 == HxRuntime.hx_null then false else Obj.obj __nullable_92 = 62 then ignore ((
        ignore (depth := HxInt.sub (!depth) 1);
        if !depth = 0 then raise (HxRuntime.Hx_return (Obj.repr (HxString.substr compact innerStart (HxInt.sub index innerStart)))) else ()
      )) else ())) done);
      ""
    )
  )
) with
  | HxRuntime.Hx_return __ret_93 -> Obj.obj __ret_93

let parseStructFieldNames = fun structBody -> try let fields = HxArray.create () in let seen = HxMap.create_string () in let tokens = tokenizeDisplaySource structBody in (
  ignore (if HxArray.length tokens = 0 then raise (HxRuntime.Hx_return (Obj.repr fields)) else ());
  let depthParen = ref 0 in let depthBrace = ref 0 in let depthBracket = ref 0 in let depthAngle = ref 0 in let tokenIndex = ref 0 in (
    ignore (while !tokenIndex < HxArray.length tokens do ignore (let token = HxArray.get tokens (!tokenIndex) in let atTopLevel = !depthParen = 0 && !depthBrace = 0 && !depthBracket = 0 && !depthAngle = 0 in (
      ignore (if atTopLevel then ignore (let nameIndex = ref (!tokenIndex) in (
        ignore (if HxString.equals (Obj.obj (HxAnon.get token "text")) "?" then ignore (nameIndex := HxInt.add (!nameIndex) 1) else ());
        if !nameIndex < HxArray.length tokens && Obj.obj (HxAnon.get (HxArray.get tokens (!nameIndex)) "isIdent") then ignore (let nameToken = HxArray.get tokens (!nameIndex) in let colonIndex = HxInt.add (!nameIndex) 1 in let tempBool = ref false in (
          ignore (let key = Obj.obj (HxAnon.get nameToken "text") in let __assign_94 = HxMap.exists_string seen key in (
            tempBool := __assign_94;
            __assign_94
          ));
          if colonIndex < HxArray.length tokens && HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens colonIndex) "text")) ":" && not (!tempBool) then ignore ((
            ignore (let key = Obj.obj (HxAnon.get nameToken "text") in HxMap.set_string seen key true);
            HxArray.push fields (Obj.obj (HxAnon.get nameToken "text"))
          )) else ()
        )) else ()
      )) else ());
      ignore (let _g = Obj.obj (HxAnon.get token "text") in match _g with
        | "(" -> ignore (depthParen := HxInt.add (!depthParen) 1)
        | ")" -> ignore (if !depthParen > 0 then ignore (depthParen := HxInt.sub (!depthParen) 1) else ())
        | "<" -> ignore (depthAngle := HxInt.add (!depthAngle) 1)
        | ">" -> ignore (if !depthAngle > 0 then ignore (depthAngle := HxInt.sub (!depthAngle) 1) else ())
        | "[" -> ignore (depthBracket := HxInt.add (!depthBracket) 1)
        | "]" -> ignore (if !depthBracket > 0 then ignore (depthBracket := HxInt.sub (!depthBracket) 1) else ())
        | "{" -> ignore (depthBrace := HxInt.add (!depthBrace) 1)
        | "}" -> ignore (if !depthBrace > 0 then ignore (depthBrace := HxInt.sub (!depthBrace) 1) else ())
        | _ -> ignore ());
      tokenIndex := HxInt.add (!tokenIndex) 1
    )) done);
    fields
  )
) with
  | HxRuntime.Hx_return __ret_95 -> Obj.obj __ret_95

let stripTypePath = fun typePath -> try (
  ignore (if typePath == Obj.magic (HxRuntime.hx_null) || HxString.length typePath = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let compact = compactWhitespace typePath in let dotIndex = HxString.lastIndexOf compact "." (HxString.length compact) in let tempResult = ref "" in (
    ignore (if dotIndex < 0 then let __assign_96 = compact in (
      tempResult := __assign_96;
      __assign_96
    ) else let __assign_97 = HxString.substr compact (HxInt.add dotIndex 1) (-1) in (
      tempResult := __assign_97;
      __assign_97
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_98 -> Obj.obj __ret_98

let findTypedefStructBody = fun source tokens typeName -> try let simpleName = stripTypePath typeName in (
  ignore (if HxString.length simpleName = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let _g = ref 0 in let _g1 = HxArray.length tokens in (
    ignore (try while !_g < _g1 do try ignore (let tokenIndex = let __old_99 = !_g in let __new_100 = HxInt.add __old_99 1 in (
      ignore (_g := __new_100);
      __old_99
    ) in let token = HxArray.get tokens tokenIndex in (
      ignore (if not (Obj.obj (HxAnon.get token "isIdent")) || not (HxString.equals (Obj.obj (HxAnon.get token "text")) "typedef") then raise (HxRuntime.Hx_continue) else ());
      let nameIndex = ref (HxInt.add tokenIndex 1) in (
        ignore (while !nameIndex < HxArray.length tokens && not (Obj.obj (HxAnon.get (HxArray.get tokens (!nameIndex)) "isIdent")) do ignore (nameIndex := HxInt.add (!nameIndex) 1) done);
        ignore (if !nameIndex >= HxArray.length tokens then raise (HxRuntime.Hx_continue) else ());
        ignore (if not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens (!nameIndex)) "text")) simpleName) then raise (HxRuntime.Hx_continue) else ());
        let equalsIndex = ref (HxInt.add (!nameIndex) 1) in (
          ignore (while !equalsIndex < HxArray.length tokens && not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens (!equalsIndex)) "text")) "=") do ignore (equalsIndex := HxInt.add (!equalsIndex) 1) done);
          ignore (if !equalsIndex >= HxArray.length tokens then raise (HxRuntime.Hx_continue) else ());
          let braceIndex = ref (HxInt.add (!equalsIndex) 1) in (
            ignore (while !braceIndex < HxArray.length tokens && not (HxString.equals (Obj.obj (HxAnon.get (HxArray.get tokens (!braceIndex)) "text")) "{") do ignore (braceIndex := HxInt.add (!braceIndex) 1) done);
            ignore (if !braceIndex >= HxArray.length tokens then raise (HxRuntime.Hx_continue) else ());
            let closeBraceIndex = findMatchingCloseToken tokens (!braceIndex) "{" "}" in (
              ignore (if closeBraceIndex < 0 then raise (HxRuntime.Hx_continue) else ());
              let startPos = Obj.obj (HxAnon.get (HxArray.get tokens (!braceIndex)) "end") in let endPos = Obj.obj (HxAnon.get (HxArray.get tokens closeBraceIndex) "start") in (
                ignore (if endPos <= startPos || endPos > HxString.length source then raise (HxRuntime.Hx_continue) else ());
                raise (HxRuntime.Hx_return (Obj.repr (HxString.substr source startPos (HxInt.sub endPos startPos))))
              )
            )
          )
        )
      )
    )) with
      | HxRuntime.Hx_continue -> () done with
      | HxRuntime.Hx_break -> ());
    ""
  )
) with
  | HxRuntime.Hx_return __ret_101 -> Obj.obj __ret_101

let xmlEscape = fun text -> try (
  ignore (if text == Obj.magic (HxRuntime.hx_null) || HxString.length text = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let out = StringTools.replace text "&" "&amp;" in let out = StringTools.replace out "<" "&lt;" in let out = StringTools.replace out ">" "&gt;" in let out = StringTools.replace out "\"" "&quot;" in out
) with
  | HxRuntime.Hx_return __ret_102 -> Obj.obj __ret_102

let formatCompletionList = fun fields -> try (
  ignore (if fields == Obj.magic (HxRuntime.hx_null) || HxArray.length fields = 0 then raise (HxRuntime.Hx_return (Obj.repr "<list></list>")) else ());
  let out = StringBuf.create () in (
    ignore (StringBuf.add out (Obj.repr "<list>"));
    let _g = ref 0 in (
      ignore (while !_g < HxArray.length fields do ignore (let field = HxArray.get fields (!_g) in (
        ignore (let __old_103 = !_g in let __new_104 = HxInt.add __old_103 1 in (
          ignore (_g := __new_104);
          __new_104
        ));
        StringBuf.add out (Obj.repr (("<i n=\"" ^ HxString.toStdString (xmlEscape field)) ^ "\"/>"))
      )) done);
      ignore (StringBuf.add out (Obj.repr "</list>"));
      StringBuf.toString out ()
    )
  )
) with
  | HxRuntime.Hx_return __ret_105 -> Obj.obj __ret_105

let synthesizeExprOfStructCompletion = fun displayRequest displaySource -> try let query = parseDisplayRequestQuery displayRequest in (
  ignore (if Obj.obj (HxAnon.get query "cursorOffset") < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  let tempString = ref "" in (
    ignore (if Obj.obj (HxAnon.get query "mode") == Obj.magic (HxRuntime.hx_null) then let __assign_106 = "" in (
      tempString := __assign_106;
      __assign_106
    ) else let __assign_107 = Obj.obj (HxAnon.get query "mode") in (
      tempString := __assign_107;
      __assign_107
    ));
    ignore (if HxString.length (!tempString) > 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
    let tempString1 = ref "" in (
      ignore (if displaySource == Obj.magic (HxRuntime.hx_null) then let __assign_108 = "" in (
        tempString1 := __assign_108;
        __assign_108
      ) else let __assign_109 = displaySource in (
        tempString1 := __assign_109;
        __assign_109
      ));
      ignore (if HxString.length (!tempString1) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
      let tokens = tokenizeDisplaySource (!tempString1) in (
        ignore (if HxArray.length tokens = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
        let stack = HxArray.create () in (
          ignore (let _g = ref 0 in let _g1 = HxArray.length tokens in try while !_g < _g1 do try ignore (let tokenIndex = let __old_110 = !_g in let __new_111 = HxInt.add __old_110 1 in (
            ignore (_g := __new_111);
            __old_110
          ) in let token = HxArray.get tokens tokenIndex in (
            ignore (if Obj.obj (HxAnon.get token "start") >= Obj.obj (HxAnon.get query "cursorOffset") then raise (HxRuntime.Hx_break) else ());
            let _g2 = Obj.obj (HxAnon.get token "text") in match _g2 with
              | ")" -> ignore (if HxArray.length stack > 0 && HxString.equals (Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "symbol")) "(" then ignore (HxArray.pop stack ()) else ())
              | "(" | "[" | "{" -> ignore (HxArray.push stack (let __anon_112 = HxAnon.create () in (
                ignore (HxAnon.set __anon_112 "symbol" (Obj.repr (Obj.obj (HxAnon.get token "text"))));
                ignore (HxAnon.set __anon_112 "tokenIndex" (Obj.repr tokenIndex));
                __anon_112
              )))
              | "]" -> ignore (if HxArray.length stack > 0 && HxString.equals (Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "symbol")) "[" then ignore (HxArray.pop stack ()) else ())
              | "}" -> ignore (if HxArray.length stack > 0 && HxString.equals (Obj.obj (HxAnon.get (HxArray.get stack (HxInt.sub (HxArray.length stack) 1)) "symbol")) "{" then ignore (HxArray.pop stack ()) else ())
              | _ -> ignore ()
          )) with
            | HxRuntime.Hx_continue -> () done with
            | HxRuntime.Hx_break -> ());
          let braceTokenIndex = ref (-1) in let parenTokenIndex = ref (-1) in (
            ignore (let _g = ref 0 in let _g1 = HxArray.length stack in try while !_g < _g1 do try ignore (let stackIndex = let __old_113 = !_g in let __new_114 = HxInt.add __old_113 1 in (
              ignore (_g := __new_114);
              __old_113
            ) in let frame = HxArray.get stack (HxInt.sub (HxInt.sub (HxArray.length stack) 1) stackIndex) in (
              ignore (if !braceTokenIndex < 0 && HxString.equals (Obj.obj (HxAnon.get frame "symbol")) "{" then ignore ((
                ignore (let __assign_115 = Obj.obj (HxAnon.get frame "tokenIndex") in (
                  braceTokenIndex := __assign_115;
                  __assign_115
                ));
                raise (HxRuntime.Hx_continue)
              )) else ());
              if !braceTokenIndex >= 0 && HxString.equals (Obj.obj (HxAnon.get frame "symbol")) "(" && Obj.obj (HxAnon.get frame "tokenIndex") < !braceTokenIndex then ignore ((
                ignore (let __assign_116 = Obj.obj (HxAnon.get frame "tokenIndex") in (
                  parenTokenIndex := __assign_116;
                  __assign_116
                ));
                raise (HxRuntime.Hx_break)
              )) else ()
            )) with
              | HxRuntime.Hx_continue -> () done with
              | HxRuntime.Hx_break -> ());
            ignore (if !braceTokenIndex < 0 || !parenTokenIndex < 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
            let functionName = findCallNameBeforeParen tokens (!parenTokenIndex) in (
              ignore (if HxString.length functionName = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
              let argumentIndex = countArgumentIndexBeforeToken tokens (!parenTokenIndex) (!braceTokenIndex) in let argTypeHint = findFunctionArgTypeHint (!tempString1) tokens functionName argumentIndex in (
                ignore (if HxString.length argTypeHint = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
                let exprOfInner = extractExprOfInner argTypeHint in (
                  ignore (if HxString.length exprOfInner = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
                  let structBody = ref "" in (
                    ignore (if StringTools.startsWith exprOfInner "{" && StringTools.endsWith exprOfInner "}" then ignore (let __assign_117 = HxString.substr exprOfInner 1 (HxInt.sub (HxString.length exprOfInner) 2) in (
                      structBody := __assign_117;
                      __assign_117
                    )) else ignore (let __assign_118 = findTypedefStructBody (!tempString1) tokens exprOfInner in (
                      structBody := __assign_118;
                      __assign_118
                    )));
                    ignore (if HxString.length (!structBody) = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
                    let fields = parseStructFieldNames (!structBody) in (
                      ignore (if HxArray.length fields = 0 then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
                      formatCompletionList fields
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_119 -> Obj.obj __ret_119

let synthesize = fun displayRequest displaySource -> try let exprOfCompletion = synthesizeExprOfStructCompletion displayRequest displaySource in (
  ignore (if HxString.length exprOfCompletion > 0 then raise (HxRuntime.Hx_return (Obj.repr exprOfCompletion)) else ());
  let tempString = ref "" in (
    ignore (if displayRequest == Obj.magic (HxRuntime.hx_null) then let __assign_120 = "" in (
      tempString := __assign_120;
      __assign_120
    ) else let __assign_121 = displayRequest in (
      tempString := __assign_121;
      __assign_121
    ));
    ignore (if StringTools.endsWith (!tempString) "@diagnostics" then raise (HxRuntime.Hx_return (Obj.repr "[{\"diagnostics\":[]}]")) else ());
    ignore (if StringTools.endsWith (!tempString) "@module-symbols" then raise (HxRuntime.Hx_return (Obj.repr "[{\"symbols\":[]}]")) else ());
    ignore (if StringTools.endsWith (!tempString) "@signature" then raise (HxRuntime.Hx_return (Obj.repr "{\"signatures\":[],\"activeSignature\":0,\"activeParameter\":0}")) else ());
    ignore (if StringTools.endsWith (!tempString) "@toplevel" then raise (HxRuntime.Hx_return (Obj.repr "<il></il>")) else ());
    ignore (if StringTools.endsWith (!tempString) "@type" then raise (HxRuntime.Hx_return (Obj.repr "<type>Dynamic</type>")) else ());
    ignore (if StringTools.endsWith (!tempString) "@position" then raise (HxRuntime.Hx_return (Obj.repr "<list></list>")) else ());
    ignore (if StringTools.endsWith (!tempString) "@usage" then raise (HxRuntime.Hx_return (Obj.repr "<list></list>")) else ());
    "<list></list>"
  )
) with
  | HxRuntime.Hx_return __ret_122 -> Obj.obj __ret_122
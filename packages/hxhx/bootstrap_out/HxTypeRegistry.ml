# 1 "HxTypeRegistry.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Type registry used by `Type.resolveClass/resolveEnum`, `Type.get*Fields`, `Type.createInstance`, and typed catches. *)

let init () : unit =
  ignore (HxType.class_ "CompilerDriver");
  ignore (HxType.class_ "EmitterStage");
  ignore (HxType.class_ "FrontendFixture");
  ignore (HxType.class_ "HxClassDecl");
  ignore (HxType.class_ "HxConditionalCompilation");
  ignore (HxType.class_ "HxDefineMap");
  ignore (HxType.class_ "HxFieldDecl");
  ignore (HxType.class_ "HxFunctionArg");
  ignore (HxType.class_ "HxFunctionDecl");
  ignore (HxType.class_ "HxLexer");
  ignore (HxType.class_ "HxModuleDecl");
  ignore (HxType.class_ "HxParseError");
  ignore (HxType.class_ "HxParser");
  ignore (HxType.class_ "HxPos");
  ignore (HxType.class_ "HxToken");
  ignore (HxType.class_ "LazyTypeLoader");
  ignore (HxType.class_ "MacroExpandedModule");
  ignore (HxType.class_ "MacroExpandedProgram");
  ignore (HxType.class_ "MacroStage");
  ignore (HxType.class_ "ModuleLoader");
  ignore (HxType.class_ "ParsedModule");
  ignore (HxType.class_ "ParserStage");
  ignore (HxType.class_ "ResolvedModule");
  ignore (HxType.class_ "ResolverStage");
  ignore (HxType.class_ "StringBuf");
  ignore (HxType.class_ "TyClassEnv");
  ignore (HxType.class_ "TyClassInfo");
  ignore (HxType.class_ "TyFunSig");
  ignore (HxType.class_ "TyFunctionEnv");
  ignore (HxType.class_ "TyModuleEnv");
  ignore (HxType.class_ "TySymbol");
  ignore (HxType.class_ "TyType");
  ignore (HxType.class_ "TypedModule");
  ignore (HxType.class_ "TyperContext");
  ignore (HxType.class_ "TyperError");
  ignore (HxType.class_ "TyperIndex");
  ignore (HxType.class_ "TyperIndexBuild");
  ignore (HxType.class_ "TyperStage");
  ignore (HxType.class_ "_EmitterStage._EmitterStageDebug");
  ignore (HxType.class_ "_HxConditionalCompilation.ExprLexer");
  ignore (HxType.class_ "_HxConditionalCompilation.ExprParser");
  ignore (HxType.class_ "haxe.Exception");
  ignore (HxType.class_ "haxe.NativeStackTrace");
  ignore (HxType.class_ "haxe.io.BytesBuffer");
  ignore (HxType.class_ "haxe.io.FPHelper");
  ignore (HxType.class_ "haxe.io.Input");
  ignore (HxType.class_ "haxe.io.Output");
  ignore (HxType.class_ "hxhx.ExprMacroExpander");
  ignore (HxType.class_ "hxhx.Hxml");
  ignore (HxType.class_ "hxhx.Main");
  ignore (HxType.class_ "hxhx.Stage1Args");
  ignore (HxType.class_ "hxhx.Stage1Compiler");
  ignore (HxType.class_ "hxhx.Stage1Resolver");
  ignore (HxType.class_ "hxhx.Stage3Compiler");
  ignore (HxType.class_ "hxhx.TargetPresets");
  ignore (HxType.class_ "hxhx._TargetPresets.ArgScan");
  ignore (HxType.class_ "hxhx.macro.MacroHostClient");
  ignore (HxType.class_ "hxhx.macro.MacroHostSession");
  ignore (HxType.class_ "hxhx.macro.MacroProtocol");
  ignore (HxType.class_ "hxhx.macro.MacroState");
  ignore (HxType.class_ "hxhx.macro._MacroHostClient.MacroClient");
  ignore (HxType.class_ "ocaml._Buffer.Buffer_Impl_");
  ignore (HxType.class_ "sys.io.File");
  ignore (HxType.class_ "sys.io.FileInput");
  ignore (HxType.class_ "sys.io.FileOutput");
  ignore (HxType.class_ "sys.io.Process");
  ignore (HxType.class_ "sys.io.Stdio");
  ignore (HxType.class_ "sys.io._Process.OcamlProcessInput");
  ignore (HxType.class_ "sys.io._Process.OcamlProcessOutput");
  ignore (HxType.class_ "sys.io._Stdio.OcamlStdioInput");
  ignore (HxType.class_ "sys.io._Stdio.OcamlStdioOutput");
  ignore (HxType.enum_ "HxDefaultValue");
  ignore (HxType.enum_ "HxExpr");
  ignore (HxType.enum_ "HxKeyword");
  ignore (HxType.enum_ "HxStmt");
  ignore (HxType.enum_ "HxSwitchPattern");
  ignore (HxType.enum_ "HxTokenKind");
  ignore (HxType.enum_ "HxVisibility");
  ignore (HxType.enum_ "_HxConditionalCompilation.Token");
  HxType.register_enum_ctors "HxDefaultValue" [ "NoDefault"; "Default" ];
  HxType.register_enum_ctors "HxExpr" [ "ENull"; "EBool"; "EString"; "EInt"; "EFloat"; "EEnumValue"; "EThis"; "ESuper"; "EIdent"; "EField"; "ECall"; "ELambda"; "ETryCatchRaw"; "ESwitchRaw"; "ESwitch"; "ENew"; "EUnop"; "EBinop"; "ETernary"; "EAnon"; "EArrayComprehension"; "EArrayDecl"; "EArrayAccess"; "ERange"; "ECast"; "EUntyped"; "EUnsupported" ];
  HxType.register_enum_ctors "HxKeyword" [ "KPackage"; "KImport"; "KUsing"; "KAs"; "KClass"; "KPublic"; "KPrivate"; "KStatic"; "KInline"; "KFunction"; "KReturn"; "KIf"; "KElse"; "KSwitch"; "KCase"; "KDefault"; "KTry"; "KCatch"; "KThrow"; "KWhile"; "KDo"; "KFor"; "KIn"; "KBreak"; "KContinue"; "KUntyped"; "KCast"; "KVar"; "KFinal"; "KNew"; "KThis"; "KSuper"; "KTrue"; "KFalse"; "KNull" ];
  HxType.register_enum_ctors "HxStmt" [ "SBlock"; "SVar"; "SIf"; "SForIn"; "SSwitch"; "SReturnVoid"; "SReturn"; "SExpr" ];
  HxType.register_enum_ctors "HxSwitchPattern" [ "PNull"; "PWildcard"; "PString"; "PInt"; "PEnumValue"; "PBind"; "POr" ];
  HxType.register_enum_ctors "HxTokenKind" [ "TEof"; "TIdent"; "TString"; "TInt"; "TFloat"; "TKeyword"; "TLBrace"; "TRBrace"; "TLParen"; "TRParen"; "TSemicolon"; "TColon"; "TDot"; "TComma"; "TOther" ];
  HxType.register_enum_ctors "HxVisibility" [ "Public"; "Private" ];
  HxType.register_enum_ctors "_HxConditionalCompilation.Token" [ "TIdent"; "TString"; "TNot"; "TAnd"; "TOr"; "TLParen"; "TRParen"; "TEq"; "TNeq"; "TEof" ];
  HxType.register_enum_ctor "HxDefaultValue" "NoDefault" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxDefaultValue.NoDefault)
  );
  HxType.register_enum_ctor "HxDefaultValue" "Default" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxDefaultValue.Default" in
    Obj.repr (HxDefaultValue.Default a0)
  );
  HxType.register_enum_ctor "HxExpr" "ENull" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxExpr.ENull)
  );
  HxType.register_enum_ctor "HxExpr" "EBool" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxExpr.EBool" in
    Obj.repr (HxExpr.EBool a0)
  );
  HxType.register_enum_ctor "HxExpr" "EString" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxExpr.EString" in
    Obj.repr (HxExpr.EString a0)
  );
  HxType.register_enum_ctor "HxExpr" "EInt" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxExpr.EInt" in
    Obj.repr (HxExpr.EInt a0)
  );
  HxType.register_enum_ctor "HxExpr" "EFloat" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxExpr.EFloat" in
    Obj.repr (HxExpr.EFloat a0)
  );
  HxType.register_enum_ctor "HxExpr" "EEnumValue" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxExpr.EEnumValue" in
    Obj.repr (HxExpr.EEnumValue a0)
  );
  HxType.register_enum_ctor "HxExpr" "EThis" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxExpr.EThis)
  );
  HxType.register_enum_ctor "HxExpr" "ESuper" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxExpr.ESuper)
  );
  HxType.register_enum_ctor "HxExpr" "EIdent" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxExpr.EIdent" in
    Obj.repr (HxExpr.EIdent a0)
  );
  HxType.register_enum_ctor "HxExpr" "EField" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'obj' for HxExpr.EField" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'field' for HxExpr.EField" in
    Obj.repr (HxExpr.EField (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ECall" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'callee' for HxExpr.ECall" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'args' for HxExpr.ECall" in
    Obj.repr (HxExpr.ECall (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ELambda" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'args' for HxExpr.ELambda" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'body' for HxExpr.ELambda" in
    Obj.repr (HxExpr.ELambda (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ETryCatchRaw" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'raw' for HxExpr.ETryCatchRaw" in
    Obj.repr (HxExpr.ETryCatchRaw a0)
  );
  HxType.register_enum_ctor "HxExpr" "ESwitchRaw" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'raw' for HxExpr.ESwitchRaw" in
    Obj.repr (HxExpr.ESwitchRaw a0)
  );
  HxType.register_enum_ctor "HxExpr" "ESwitch" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'scrutinee' for HxExpr.ESwitch" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'cases' for HxExpr.ESwitch" in
    Obj.repr (HxExpr.ESwitch (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ENew" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'typePath' for HxExpr.ENew" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'args' for HxExpr.ENew" in
    Obj.repr (HxExpr.ENew (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "EUnop" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'op' for HxExpr.EUnop" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxExpr.EUnop" in
    Obj.repr (HxExpr.EUnop (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "EBinop" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'op' for HxExpr.EBinop" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'left' for HxExpr.EBinop" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createEnum: missing ctor arg 'right' for HxExpr.EBinop" in
    Obj.repr (HxExpr.EBinop (a0, a1, a2))
  );
  HxType.register_enum_ctor "HxExpr" "ETernary" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'cond' for HxExpr.ETernary" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'thenExpr' for HxExpr.ETernary" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createEnum: missing ctor arg 'elseExpr' for HxExpr.ETernary" in
    Obj.repr (HxExpr.ETernary (a0, a1, a2))
  );
  HxType.register_enum_ctor "HxExpr" "EAnon" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'fieldNames' for HxExpr.EAnon" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'fieldValues' for HxExpr.EAnon" in
    Obj.repr (HxExpr.EAnon (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "EArrayComprehension" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxExpr.EArrayComprehension" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'iterable' for HxExpr.EArrayComprehension" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createEnum: missing ctor arg 'yieldExpr' for HxExpr.EArrayComprehension" in
    Obj.repr (HxExpr.EArrayComprehension (a0, a1, a2))
  );
  HxType.register_enum_ctor "HxExpr" "EArrayDecl" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'values' for HxExpr.EArrayDecl" in
    Obj.repr (HxExpr.EArrayDecl a0)
  );
  HxType.register_enum_ctor "HxExpr" "EArrayAccess" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'array' for HxExpr.EArrayAccess" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'index' for HxExpr.EArrayAccess" in
    Obj.repr (HxExpr.EArrayAccess (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ERange" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'start' for HxExpr.ERange" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'end' for HxExpr.ERange" in
    Obj.repr (HxExpr.ERange (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "ECast" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxExpr.ECast" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'typeHint' for HxExpr.ECast" in
    Obj.repr (HxExpr.ECast (a0, a1))
  );
  HxType.register_enum_ctor "HxExpr" "EUntyped" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxExpr.EUntyped" in
    Obj.repr (HxExpr.EUntyped a0)
  );
  HxType.register_enum_ctor "HxExpr" "EUnsupported" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'raw' for HxExpr.EUnsupported" in
    Obj.repr (HxExpr.EUnsupported a0)
  );
  HxType.register_enum_ctor "HxKeyword" "KPackage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KPackage)
  );
  HxType.register_enum_ctor "HxKeyword" "KImport" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KImport)
  );
  HxType.register_enum_ctor "HxKeyword" "KUsing" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KUsing)
  );
  HxType.register_enum_ctor "HxKeyword" "KAs" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KAs)
  );
  HxType.register_enum_ctor "HxKeyword" "KClass" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KClass)
  );
  HxType.register_enum_ctor "HxKeyword" "KPublic" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KPublic)
  );
  HxType.register_enum_ctor "HxKeyword" "KPrivate" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KPrivate)
  );
  HxType.register_enum_ctor "HxKeyword" "KStatic" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KStatic)
  );
  HxType.register_enum_ctor "HxKeyword" "KInline" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KInline)
  );
  HxType.register_enum_ctor "HxKeyword" "KFunction" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KFunction)
  );
  HxType.register_enum_ctor "HxKeyword" "KReturn" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KReturn)
  );
  HxType.register_enum_ctor "HxKeyword" "KIf" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KIf)
  );
  HxType.register_enum_ctor "HxKeyword" "KElse" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KElse)
  );
  HxType.register_enum_ctor "HxKeyword" "KSwitch" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KSwitch)
  );
  HxType.register_enum_ctor "HxKeyword" "KCase" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KCase)
  );
  HxType.register_enum_ctor "HxKeyword" "KDefault" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KDefault)
  );
  HxType.register_enum_ctor "HxKeyword" "KTry" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KTry)
  );
  HxType.register_enum_ctor "HxKeyword" "KCatch" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KCatch)
  );
  HxType.register_enum_ctor "HxKeyword" "KThrow" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KThrow)
  );
  HxType.register_enum_ctor "HxKeyword" "KWhile" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KWhile)
  );
  HxType.register_enum_ctor "HxKeyword" "KDo" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KDo)
  );
  HxType.register_enum_ctor "HxKeyword" "KFor" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KFor)
  );
  HxType.register_enum_ctor "HxKeyword" "KIn" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KIn)
  );
  HxType.register_enum_ctor "HxKeyword" "KBreak" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KBreak)
  );
  HxType.register_enum_ctor "HxKeyword" "KContinue" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KContinue)
  );
  HxType.register_enum_ctor "HxKeyword" "KUntyped" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KUntyped)
  );
  HxType.register_enum_ctor "HxKeyword" "KCast" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KCast)
  );
  HxType.register_enum_ctor "HxKeyword" "KVar" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KVar)
  );
  HxType.register_enum_ctor "HxKeyword" "KFinal" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KFinal)
  );
  HxType.register_enum_ctor "HxKeyword" "KNew" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KNew)
  );
  HxType.register_enum_ctor "HxKeyword" "KThis" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KThis)
  );
  HxType.register_enum_ctor "HxKeyword" "KSuper" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KSuper)
  );
  HxType.register_enum_ctor "HxKeyword" "KTrue" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KTrue)
  );
  HxType.register_enum_ctor "HxKeyword" "KFalse" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KFalse)
  );
  HxType.register_enum_ctor "HxKeyword" "KNull" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxKeyword.KNull)
  );
  HxType.register_enum_ctor "HxStmt" "SBlock" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'stmts' for HxStmt.SBlock" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SBlock" in
    Obj.repr (HxStmt.SBlock (a0, a1))
  );
  HxType.register_enum_ctor "HxStmt" "SVar" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxStmt.SVar" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'typeHint' for HxStmt.SVar" in
    let a2 = if len > 2 then (HxArray.get args 2) else failwith "Type.createEnum: missing ctor arg 'init' for HxStmt.SVar" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SVar" in
    Obj.repr (HxStmt.SVar (a0, a1, a2, a3))
  );
  HxType.register_enum_ctor "HxStmt" "SIf" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'cond' for HxStmt.SIf" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'thenBranch' for HxStmt.SIf" in
    let a2 = if len > 2 then (HxArray.get args 2) else failwith "Type.createEnum: missing ctor arg 'elseBranch' for HxStmt.SIf" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SIf" in
    Obj.repr (HxStmt.SIf (a0, a1, a2, a3))
  );
  HxType.register_enum_ctor "HxStmt" "SForIn" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxStmt.SForIn" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'iterable' for HxStmt.SForIn" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createEnum: missing ctor arg 'body' for HxStmt.SForIn" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SForIn" in
    Obj.repr (HxStmt.SForIn (a0, a1, a2, a3))
  );
  HxType.register_enum_ctor "HxStmt" "SSwitch" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'scrutinee' for HxStmt.SSwitch" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'cases' for HxStmt.SSwitch" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SSwitch" in
    Obj.repr (HxStmt.SSwitch (a0, a1, a2))
  );
  HxType.register_enum_ctor "HxStmt" "SReturnVoid" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SReturnVoid" in
    Obj.repr (HxStmt.SReturnVoid a0)
  );
  HxType.register_enum_ctor "HxStmt" "SReturn" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxStmt.SReturn" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SReturn" in
    Obj.repr (HxStmt.SReturn (a0, a1))
  );
  HxType.register_enum_ctor "HxStmt" "SExpr" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'expr' for HxStmt.SExpr" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createEnum: missing ctor arg 'pos' for HxStmt.SExpr" in
    Obj.repr (HxStmt.SExpr (a0, a1))
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PNull" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxSwitchPattern.PNull)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PWildcard" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxSwitchPattern.PWildcard)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PString" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxSwitchPattern.PString" in
    Obj.repr (HxSwitchPattern.PString a0)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PInt" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxSwitchPattern.PInt" in
    Obj.repr (HxSwitchPattern.PInt a0)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PEnumValue" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxSwitchPattern.PEnumValue" in
    Obj.repr (HxSwitchPattern.PEnumValue a0)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "PBind" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxSwitchPattern.PBind" in
    Obj.repr (HxSwitchPattern.PBind a0)
  );
  HxType.register_enum_ctor "HxSwitchPattern" "POr" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'patterns' for HxSwitchPattern.POr" in
    Obj.repr (HxSwitchPattern.POr a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TEof" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TEof)
  );
  HxType.register_enum_ctor "HxTokenKind" "TIdent" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for HxTokenKind.TIdent" in
    Obj.repr (HxTokenKind.TIdent a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TString" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxTokenKind.TString" in
    Obj.repr (HxTokenKind.TString a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TInt" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxTokenKind.TInt" in
    Obj.repr (HxTokenKind.TInt a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TFloat" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for HxTokenKind.TFloat" in
    Obj.repr (HxTokenKind.TFloat a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TKeyword" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'k' for HxTokenKind.TKeyword" in
    Obj.repr (HxTokenKind.TKeyword a0)
  );
  HxType.register_enum_ctor "HxTokenKind" "TLBrace" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TLBrace)
  );
  HxType.register_enum_ctor "HxTokenKind" "TRBrace" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TRBrace)
  );
  HxType.register_enum_ctor "HxTokenKind" "TLParen" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TLParen)
  );
  HxType.register_enum_ctor "HxTokenKind" "TRParen" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TRParen)
  );
  HxType.register_enum_ctor "HxTokenKind" "TSemicolon" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TSemicolon)
  );
  HxType.register_enum_ctor "HxTokenKind" "TColon" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TColon)
  );
  HxType.register_enum_ctor "HxTokenKind" "TDot" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TDot)
  );
  HxType.register_enum_ctor "HxTokenKind" "TComma" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxTokenKind.TComma)
  );
  HxType.register_enum_ctor "HxTokenKind" "TOther" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'code' for HxTokenKind.TOther" in
    Obj.repr (HxTokenKind.TOther a0)
  );
  HxType.register_enum_ctor "HxVisibility" "Public" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxVisibility.Public)
  );
  HxType.register_enum_ctor "HxVisibility" "Private" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxVisibility.Private)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TIdent" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'name' for _HxConditionalCompilation.Token.TIdent" in
    Obj.repr (HxConditionalCompilation.TIdent a0)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TString" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createEnum: missing ctor arg 'value' for _HxConditionalCompilation.Token.TString" in
    Obj.repr (HxConditionalCompilation.TString a0)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TNot" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TNot)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TAnd" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TAnd)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TOr" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TOr)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TLParen" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TLParen)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TRParen" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TRParen)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TEq" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TEq)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TNeq" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TNeq)
  );
  HxType.register_enum_ctor "_HxConditionalCompilation.Token" "TEof" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.TEof)
  );
  HxType.register_class_ctor "CompilerDriver" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (CompilerDriver.create ())
  );
  HxType.register_class_ctor "EmitterStage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (EmitterStage.create ())
  );
  HxType.register_class_ctor "FrontendFixture" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'label' for FrontendFixture" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'source' for FrontendFixture" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'expectPackagePath' for FrontendFixture" in
    let a3 = if len > 3 then Obj.obj ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'expectMainClassName' for FrontendFixture" in
    let a4 = if len > 4 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'expectHasStaticMain' for FrontendFixture" in
    Obj.repr (FrontendFixture.create a0 a1 a2 a3 a4)
  );
  HxType.register_class_ctor "HxClassDecl" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for HxClassDecl" in
    let a1 = if len > 1 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'hasStaticMain' for HxClassDecl" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else Obj.magic HxRuntime.hx_null in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else Obj.magic HxRuntime.hx_null in
    Obj.repr (HxClassDecl.create a0 a1 a2 a3)
  );
  HxType.register_class_ctor "HxConditionalCompilation" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxConditionalCompilation.create ())
  );
  HxType.register_class_ctor "HxDefineMap" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (HxDefineMap.create ())
  );
  HxType.register_class_ctor "HxFieldDecl" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for HxFieldDecl" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'visibility' for HxFieldDecl" in
    let a2 = if len > 2 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'isStatic' for HxFieldDecl" in
    let a3 = if len > 3 then Obj.obj ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'typeHint' for HxFieldDecl" in
    let a4 = if len > 4 then (HxArray.get args 4) else failwith "Type.createInstance: missing ctor arg 'init' for HxFieldDecl" in
    Obj.repr (HxFieldDecl.create a0 a1 a2 a3 a4)
  );
  HxType.register_class_ctor "HxFunctionArg" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for HxFunctionArg" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'typeHint' for HxFunctionArg" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'defaultValue' for HxFunctionArg" in
    let a3 = if len > 3 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 3)) else Obj.magic HxRuntime.hx_null in
    let a4 = if len > 4 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 4)) else Obj.magic HxRuntime.hx_null in
    Obj.repr (HxFunctionArg.create a0 a1 a2 a3 a4)
  );
  HxType.register_class_ctor "HxFunctionDecl" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for HxFunctionDecl" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'visibility' for HxFunctionDecl" in
    let a2 = if len > 2 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'isStatic' for HxFunctionDecl" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'args' for HxFunctionDecl" in
    let a4 = if len > 4 then Obj.obj ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'returnTypeHint' for HxFunctionDecl" in
    let a5 = if len > 5 then Obj.magic ((HxArray.get args 5)) else failwith "Type.createInstance: missing ctor arg 'body' for HxFunctionDecl" in
    let a6 = if len > 6 then Obj.obj ((HxArray.get args 6)) else failwith "Type.createInstance: missing ctor arg 'returnStringLiteral' for HxFunctionDecl" in
    Obj.repr (HxFunctionDecl.create a0 a1 a2 a3 a4 a5 a6)
  );
  HxType.register_class_ctor "HxLexer" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'src' for HxLexer" in
    Obj.repr (HxLexer.create a0)
  );
  HxType.register_class_ctor "HxModuleDecl" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'packagePath' for HxModuleDecl" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'imports' for HxModuleDecl" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'mainClass' for HxModuleDecl" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'classes' for HxModuleDecl" in
    let a4 = if len > 4 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'headerOnly' for HxModuleDecl" in
    let a5 = if len > 5 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 5)) else failwith "Type.createInstance: missing ctor arg 'hasToplevelMain' for HxModuleDecl" in
    Obj.repr (HxModuleDecl.create a0 a1 a2 a3 a4 a5)
  );
  HxType.register_class_ctor "HxParseError" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'message' for HxParseError" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'pos' for HxParseError" in
    Obj.repr (HxParseError.create a0 a1)
  );
  HxType.register_class_ctor "HxParser" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'source' for HxParser" in
    Obj.repr (HxParser.create a0)
  );
  HxType.register_class_ctor "HxPos" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'index' for HxPos" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'line' for HxPos" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'column' for HxPos" in
    Obj.repr (HxPos.create a0 a1 a2)
  );
  HxType.register_class_ctor "HxToken" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'kind' for HxToken" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'pos' for HxToken" in
    Obj.repr (HxToken.create a0 a1)
  );
  HxType.register_class_ctor "LazyTypeLoader" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (LazyTypeLoader.create ())
  );
  HxType.register_class_ctor "MacroExpandedModule" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'typed' for MacroExpandedModule" in
    let a1 = if len > 1 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'macroMode' for MacroExpandedModule" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else Obj.magic HxRuntime.hx_null in
    Obj.repr (MacroExpandedModule.create a0 a1 a2)
  );
  HxType.register_class_ctor "MacroExpandedProgram" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'typedModules' for MacroExpandedProgram" in
    let a1 = if len > 1 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'macroMode' for MacroExpandedProgram" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else Obj.magic HxRuntime.hx_null in
    Obj.repr (MacroExpandedProgram.create a0 a1 a2)
  );
  HxType.register_class_ctor "MacroStage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (MacroStage.create ())
  );
  HxType.register_class_ctor "ModuleLoader" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'classPaths' for ModuleLoader" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'defines' for ModuleLoader" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'index' for ModuleLoader" in
    Obj.repr (ModuleLoader.create a0 a1 a2)
  );
  HxType.register_class_ctor "ParsedModule" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'source' for ParsedModule" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'decl' for ParsedModule" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'filePath' for ParsedModule" in
    Obj.repr (ParsedModule.create a0 a1 a2)
  );
  HxType.register_class_ctor "ParserStage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (ParserStage.create ())
  );
  HxType.register_class_ctor "ResolvedModule" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'modulePath' for ResolvedModule" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'filePath' for ResolvedModule" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'parsed' for ResolvedModule" in
    Obj.repr (ResolvedModule.create a0 a1 a2)
  );
  HxType.register_class_ctor "ResolverStage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (ResolverStage.create ())
  );
  HxType.register_class_ctor "StringBuf" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (StringBuf.create ())
  );
  HxType.register_class_ctor "TyClassEnv" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for TyClassEnv" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'functions' for TyClassEnv" in
    Obj.repr (TyClassEnv.create a0 a1)
  );
  HxType.register_class_ctor "TyClassInfo" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'fullName' for TyClassInfo" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'shortName' for TyClassInfo" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'modulePath' for TyClassInfo" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'fields' for TyClassInfo" in
    let a4 = if len > 4 then Obj.magic ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'staticMethods' for TyClassInfo" in
    let a5 = if len > 5 then Obj.magic ((HxArray.get args 5)) else failwith "Type.createInstance: missing ctor arg 'instanceMethods' for TyClassInfo" in
    Obj.repr (TyClassInfo.create a0 a1 a2 a3 a4 a5)
  );
  HxType.register_class_ctor "TyFunSig" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for TyFunSig" in
    let a1 = if len > 1 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'isStatic' for TyFunSig" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'args' for TyFunSig" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'returnType' for TyFunSig" in
    Obj.repr (TyFunSig.create a0 a1 a2 a3)
  );
  HxType.register_class_ctor "TyFunctionEnv" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for TyFunctionEnv" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'params' for TyFunctionEnv" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'locals' for TyFunctionEnv" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'returnType' for TyFunctionEnv" in
    let a4 = if len > 4 then Obj.magic ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'returnExprType' for TyFunctionEnv" in
    Obj.repr (TyFunctionEnv.create a0 a1 a2 a3 a4)
  );
  HxType.register_class_ctor "TyModuleEnv" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'packagePath' for TyModuleEnv" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'imports' for TyModuleEnv" in
    let a2 = if len > 2 then Obj.magic ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'mainClass' for TyModuleEnv" in
    Obj.repr (TyModuleEnv.create a0 a1 a2)
  );
  HxType.register_class_ctor "TySymbol" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'name' for TySymbol" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'ty' for TySymbol" in
    Obj.repr (TySymbol.create a0 a1)
  );
  HxType.register_class_ctor "TyType" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'display' for TyType" in
    Obj.repr (TyType.create a0)
  );
  HxType.register_class_ctor "TypedModule" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'parsed' for TypedModule" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'env' for TypedModule" in
    Obj.repr (TypedModule.create a0 a1)
  );
  HxType.register_class_ctor "TyperContext" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'index' for TyperContext" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'filePath' for TyperContext" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'modulePath' for TyperContext" in
    let a3 = if len > 3 then Obj.obj ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'packagePath' for TyperContext" in
    let a4 = if len > 4 then Obj.magic ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'imports' for TyperContext" in
    let a5 = if len > 5 then Obj.obj ((HxArray.get args 5)) else failwith "Type.createInstance: missing ctor arg 'classFullName' for TyperContext" in
    let a6 = if len > 6 then Obj.magic ((HxArray.get args 6)) else Obj.magic HxRuntime.hx_null in
    Obj.repr (TyperContext.create a0 a1 a2 a3 a4 a5 a6)
  );
  HxType.register_class_ctor "TyperError" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'filePath' for TyperError" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'pos' for TyperError" in
    let a2 = if len > 2 then Obj.obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'message' for TyperError" in
    Obj.repr (TyperError.create a0 a1 a2)
  );
  HxType.register_class_ctor "TyperIndex" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (TyperIndex.create ())
  );
  HxType.register_class_ctor "TyperIndexBuild" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (ModuleLoader.typerindexbuild_create ())
  );
  HxType.register_class_ctor "TyperStage" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (TyperStage.create ())
  );
  HxType.register_class_ctor "_EmitterStage._EmitterStageDebug" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (EmitterStage._emitterstagedebug_create ())
  );
  HxType.register_class_ctor "_HxConditionalCompilation.ExprLexer" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 's' for _HxConditionalCompilation.ExprLexer" in
    Obj.repr (HxConditionalCompilation.exprlexer_create a0)
  );
  HxType.register_class_ctor "_HxConditionalCompilation.ExprParser" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'expr' for _HxConditionalCompilation.ExprParser" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'defines' for _HxConditionalCompilation.ExprParser" in
    Obj.repr (HxConditionalCompilation.exprparser_create a0 a1)
  );
  HxType.register_class_ctor "haxe.Exception" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'message' for haxe.Exception" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else Obj.magic HxRuntime.hx_null in
    let a2 = if len > 2 then (HxArray.get args 2) else HxRuntime.hx_null in
    Obj.repr (Haxe_Exception.create a0 a1 a2)
  );
  HxType.register_class_ctor "haxe.NativeStackTrace" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Haxe_NativeStackTrace.create ())
  );
  HxType.register_class_ctor "haxe.io.BytesBuffer" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Haxe_io_BytesBuffer.create ())
  );
  HxType.register_class_ctor "haxe.io.FPHelper" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Haxe_io_FPHelper.create ())
  );
  HxType.register_class_ctor "haxe.io.Input" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Haxe_io_Input.create ())
  );
  HxType.register_class_ctor "haxe.io.Output" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Haxe_io_Output.create ())
  );
  HxType.register_class_ctor "hxhx.ExprMacroExpander" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_ExprMacroExpander.create ())
  );
  HxType.register_class_ctor "hxhx.Hxml" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_Hxml.create ())
  );
  HxType.register_class_ctor "hxhx.Main" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_Main.create ())
  );
  HxType.register_class_ctor "hxhx.Stage1Args" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'classPaths' for hxhx.Stage1Args" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'main' for hxhx.Stage1Args" in
    let a2 = if len > 2 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 2)) else failwith "Type.createInstance: missing ctor arg 'noOutput' for hxhx.Stage1Args" in
    let a3 = if len > 3 then Obj.magic ((HxArray.get args 3)) else failwith "Type.createInstance: missing ctor arg 'roots' for hxhx.Stage1Args" in
    let a4 = if len > 4 then Obj.magic ((HxArray.get args 4)) else failwith "Type.createInstance: missing ctor arg 'defines' for hxhx.Stage1Args" in
    let a5 = if len > 5 then Obj.magic ((HxArray.get args 5)) else failwith "Type.createInstance: missing ctor arg 'libs' for hxhx.Stage1Args" in
    let a6 = if len > 6 then Obj.magic ((HxArray.get args 6)) else failwith "Type.createInstance: missing ctor arg 'macros' for hxhx.Stage1Args" in
    let a7 = if len > 7 then Obj.obj ((HxArray.get args 7)) else failwith "Type.createInstance: missing ctor arg 'displayRequest' for hxhx.Stage1Args" in
    let a8 = if len > 8 then Obj.obj ((HxArray.get args 8)) else failwith "Type.createInstance: missing ctor arg 'cwd' for hxhx.Stage1Args" in
    let a9 = if len > 9 then HxRuntime.unbox_bool_or_obj ((HxArray.get args 9)) else failwith "Type.createInstance: missing ctor arg 'hadCmd' for hxhx.Stage1Args" in
    Obj.repr (Hxhx_Stage1Compiler.stage1args_create a0 a1 a2 a3 a4 a5 a6 a7 a8 a9)
  );
  HxType.register_class_ctor "hxhx.Stage1Compiler" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_Stage1Compiler.create ())
  );
  HxType.register_class_ctor "hxhx.Stage1Resolver" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_Stage1Compiler.stage1resolver_create ())
  );
  HxType.register_class_ctor "hxhx.Stage3Compiler" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_Stage3Compiler.create ())
  );
  HxType.register_class_ctor "hxhx.TargetPresets" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_TargetPresets.create ())
  );
  HxType.register_class_ctor "hxhx._TargetPresets.ArgScan" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_TargetPresets.argscan_create ())
  );
  HxType.register_class_ctor "hxhx.macro.MacroHostClient" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_macro_MacroHostClient.create ())
  );
  HxType.register_class_ctor "hxhx.macro.MacroHostSession" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'client' for hxhx.macro.MacroHostSession" in
    Obj.repr (Hxhx_macro_MacroHostClient.macrohostsession_create a0)
  );
  HxType.register_class_ctor "hxhx.macro.MacroProtocol" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_macro_MacroProtocol.create ())
  );
  HxType.register_class_ctor "hxhx.macro.MacroState" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Hxhx_macro_MacroState.create ())
  );
  HxType.register_class_ctor "hxhx.macro._MacroHostClient.MacroClient" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.magic ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'proc' for hxhx.macro._MacroHostClient.MacroClient" in
    Obj.repr (Hxhx_macro_MacroHostClient.macroclient_create a0)
  );
  HxType.register_class_ctor "sys.io.File" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Sys_io_File.create ())
  );
  HxType.register_class_ctor "sys.io.FileInput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then (HxArray.get args 0) else failwith "Type.createInstance: missing ctor arg 'h' for sys.io.FileInput" in
    Obj.repr (Sys_io_FileInput.create a0)
  );
  HxType.register_class_ctor "sys.io.FileOutput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then (HxArray.get args 0) else failwith "Type.createInstance: missing ctor arg 'h' for sys.io.FileOutput" in
    Obj.repr (Sys_io_FileOutput.create a0)
  );
  HxType.register_class_ctor "sys.io.Process" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'cmd' for sys.io.Process" in
    let a1 = if len > 1 then Obj.magic ((HxArray.get args 1)) else Obj.magic HxRuntime.hx_null in
    let a2 = if len > 2 then (HxArray.get args 2) else HxRuntime.hx_null in
    Obj.repr (Sys_io_Process.create a0 a1 a2)
  );
  HxType.register_class_ctor "sys.io.Stdio" (fun (_args : Obj.t HxArray.t) ->
    Obj.repr (Sys_io_Stdio.create ())
  );
  HxType.register_class_ctor "sys.io._Process.OcamlProcessInput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'handle' for sys.io._Process.OcamlProcessInput" in
    let a1 = if len > 1 then Obj.obj ((HxArray.get args 1)) else failwith "Type.createInstance: missing ctor arg 'stream' for sys.io._Process.OcamlProcessInput" in
    Obj.repr (Sys_io_Process.ocamlprocessinput_create a0 a1)
  );
  HxType.register_class_ctor "sys.io._Process.OcamlProcessOutput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'handle' for sys.io._Process.OcamlProcessOutput" in
    Obj.repr (Sys_io_Process.ocamlprocessoutput_create a0)
  );
  HxType.register_class_ctor "sys.io._Stdio.OcamlStdioInput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'stream' for sys.io._Stdio.OcamlStdioInput" in
    Obj.repr (Sys_io_Stdio.ocamlstdioinput_create a0)
  );
  HxType.register_class_ctor "sys.io._Stdio.OcamlStdioOutput" (fun (args : Obj.t HxArray.t) ->
    let len = HxArray.length args in
    let a0 = if len > 0 then Obj.obj ((HxArray.get args 0)) else failwith "Type.createInstance: missing ctor arg 'stream' for sys.io._Stdio.OcamlStdioOutput" in
    Obj.repr (Sys_io_Stdio.ocamlstdiooutput_create a0)
  );
  HxType.register_class_empty_ctor "CompilerDriver" (fun () -> Obj.repr (CompilerDriver.__empty ()));
  HxType.register_class_empty_ctor "EmitterStage" (fun () -> Obj.repr (EmitterStage.__empty ()));
  HxType.register_class_empty_ctor "FrontendFixture" (fun () -> Obj.repr (FrontendFixture.__empty ()));
  HxType.register_class_empty_ctor "HxClassDecl" (fun () -> Obj.repr (HxClassDecl.__empty ()));
  HxType.register_class_empty_ctor "HxConditionalCompilation" (fun () -> Obj.repr (HxConditionalCompilation.__empty ()));
  HxType.register_class_empty_ctor "HxDefineMap" (fun () -> Obj.repr (HxDefineMap.__empty ()));
  HxType.register_class_empty_ctor "HxFieldDecl" (fun () -> Obj.repr (HxFieldDecl.__empty ()));
  HxType.register_class_empty_ctor "HxFunctionArg" (fun () -> Obj.repr (HxFunctionArg.__empty ()));
  HxType.register_class_empty_ctor "HxFunctionDecl" (fun () -> Obj.repr (HxFunctionDecl.__empty ()));
  HxType.register_class_empty_ctor "HxLexer" (fun () -> Obj.repr (HxLexer.__empty ()));
  HxType.register_class_empty_ctor "HxModuleDecl" (fun () -> Obj.repr (HxModuleDecl.__empty ()));
  HxType.register_class_empty_ctor "HxParseError" (fun () -> Obj.repr (HxParseError.__empty ()));
  HxType.register_class_empty_ctor "HxParser" (fun () -> Obj.repr (HxParser.__empty ()));
  HxType.register_class_empty_ctor "HxPos" (fun () -> Obj.repr (HxPos.__empty ()));
  HxType.register_class_empty_ctor "HxToken" (fun () -> Obj.repr (HxToken.__empty ()));
  HxType.register_class_empty_ctor "LazyTypeLoader" (fun () -> Obj.repr (LazyTypeLoader.__empty ()));
  HxType.register_class_empty_ctor "MacroExpandedModule" (fun () -> Obj.repr (MacroExpandedModule.__empty ()));
  HxType.register_class_empty_ctor "MacroExpandedProgram" (fun () -> Obj.repr (MacroExpandedProgram.__empty ()));
  HxType.register_class_empty_ctor "MacroStage" (fun () -> Obj.repr (MacroStage.__empty ()));
  HxType.register_class_empty_ctor "ModuleLoader" (fun () -> Obj.repr (ModuleLoader.__empty ()));
  HxType.register_class_empty_ctor "ParsedModule" (fun () -> Obj.repr (ParsedModule.__empty ()));
  HxType.register_class_empty_ctor "ParserStage" (fun () -> Obj.repr (ParserStage.__empty ()));
  HxType.register_class_empty_ctor "ResolvedModule" (fun () -> Obj.repr (ResolvedModule.__empty ()));
  HxType.register_class_empty_ctor "ResolverStage" (fun () -> Obj.repr (ResolverStage.__empty ()));
  HxType.register_class_empty_ctor "StringBuf" (fun () -> Obj.repr (StringBuf.__empty ()));
  HxType.register_class_empty_ctor "TyClassEnv" (fun () -> Obj.repr (TyClassEnv.__empty ()));
  HxType.register_class_empty_ctor "TyClassInfo" (fun () -> Obj.repr (TyClassInfo.__empty ()));
  HxType.register_class_empty_ctor "TyFunSig" (fun () -> Obj.repr (TyFunSig.__empty ()));
  HxType.register_class_empty_ctor "TyFunctionEnv" (fun () -> Obj.repr (TyFunctionEnv.__empty ()));
  HxType.register_class_empty_ctor "TyModuleEnv" (fun () -> Obj.repr (TyModuleEnv.__empty ()));
  HxType.register_class_empty_ctor "TySymbol" (fun () -> Obj.repr (TySymbol.__empty ()));
  HxType.register_class_empty_ctor "TyType" (fun () -> Obj.repr (TyType.__empty ()));
  HxType.register_class_empty_ctor "TypedModule" (fun () -> Obj.repr (TypedModule.__empty ()));
  HxType.register_class_empty_ctor "TyperContext" (fun () -> Obj.repr (TyperContext.__empty ()));
  HxType.register_class_empty_ctor "TyperError" (fun () -> Obj.repr (TyperError.__empty ()));
  HxType.register_class_empty_ctor "TyperIndex" (fun () -> Obj.repr (TyperIndex.__empty ()));
  HxType.register_class_empty_ctor "TyperIndexBuild" (fun () -> Obj.repr (ModuleLoader.typerindexbuild___empty ()));
  HxType.register_class_empty_ctor "TyperStage" (fun () -> Obj.repr (TyperStage.__empty ()));
  HxType.register_class_empty_ctor "_EmitterStage._EmitterStageDebug" (fun () -> Obj.repr (EmitterStage._emitterstagedebug___empty ()));
  HxType.register_class_empty_ctor "_HxConditionalCompilation.ExprLexer" (fun () -> Obj.repr (HxConditionalCompilation.exprlexer___empty ()));
  HxType.register_class_empty_ctor "_HxConditionalCompilation.ExprParser" (fun () -> Obj.repr (HxConditionalCompilation.exprparser___empty ()));
  HxType.register_class_empty_ctor "haxe.Exception" (fun () -> Obj.repr (Haxe_Exception.__empty ()));
  HxType.register_class_empty_ctor "haxe.NativeStackTrace" (fun () -> Obj.repr (Haxe_NativeStackTrace.__empty ()));
  HxType.register_class_empty_ctor "haxe.io.BytesBuffer" (fun () -> Obj.repr (Haxe_io_BytesBuffer.__empty ()));
  HxType.register_class_empty_ctor "haxe.io.FPHelper" (fun () -> Obj.repr (Haxe_io_FPHelper.__empty ()));
  HxType.register_class_empty_ctor "haxe.io.Input" (fun () -> Obj.repr (Haxe_io_Input.__empty ()));
  HxType.register_class_empty_ctor "haxe.io.Output" (fun () -> Obj.repr (Haxe_io_Output.__empty ()));
  HxType.register_class_empty_ctor "hxhx.ExprMacroExpander" (fun () -> Obj.repr (Hxhx_ExprMacroExpander.__empty ()));
  HxType.register_class_empty_ctor "hxhx.Hxml" (fun () -> Obj.repr (Hxhx_Hxml.__empty ()));
  HxType.register_class_empty_ctor "hxhx.Main" (fun () -> Obj.repr (Hxhx_Main.__empty ()));
  HxType.register_class_empty_ctor "hxhx.Stage1Args" (fun () -> Obj.repr (Hxhx_Stage1Compiler.stage1args___empty ()));
  HxType.register_class_empty_ctor "hxhx.Stage1Compiler" (fun () -> Obj.repr (Hxhx_Stage1Compiler.__empty ()));
  HxType.register_class_empty_ctor "hxhx.Stage1Resolver" (fun () -> Obj.repr (Hxhx_Stage1Compiler.stage1resolver___empty ()));
  HxType.register_class_empty_ctor "hxhx.Stage3Compiler" (fun () -> Obj.repr (Hxhx_Stage3Compiler.__empty ()));
  HxType.register_class_empty_ctor "hxhx.TargetPresets" (fun () -> Obj.repr (Hxhx_TargetPresets.__empty ()));
  HxType.register_class_empty_ctor "hxhx._TargetPresets.ArgScan" (fun () -> Obj.repr (Hxhx_TargetPresets.argscan___empty ()));
  HxType.register_class_empty_ctor "hxhx.macro.MacroHostClient" (fun () -> Obj.repr (Hxhx_macro_MacroHostClient.__empty ()));
  HxType.register_class_empty_ctor "hxhx.macro.MacroHostSession" (fun () -> Obj.repr (Hxhx_macro_MacroHostClient.macrohostsession___empty ()));
  HxType.register_class_empty_ctor "hxhx.macro.MacroProtocol" (fun () -> Obj.repr (Hxhx_macro_MacroProtocol.__empty ()));
  HxType.register_class_empty_ctor "hxhx.macro.MacroState" (fun () -> Obj.repr (Hxhx_macro_MacroState.__empty ()));
  HxType.register_class_empty_ctor "hxhx.macro._MacroHostClient.MacroClient" (fun () -> Obj.repr (Hxhx_macro_MacroHostClient.macroclient___empty ()));
  HxType.register_class_empty_ctor "sys.io.File" (fun () -> Obj.repr (Sys_io_File.__empty ()));
  HxType.register_class_empty_ctor "sys.io.FileInput" (fun () -> Obj.repr (Sys_io_FileInput.__empty ()));
  HxType.register_class_empty_ctor "sys.io.FileOutput" (fun () -> Obj.repr (Sys_io_FileOutput.__empty ()));
  HxType.register_class_empty_ctor "sys.io.Process" (fun () -> Obj.repr (Sys_io_Process.__empty ()));
  HxType.register_class_empty_ctor "sys.io.Stdio" (fun () -> Obj.repr (Sys_io_Stdio.__empty ()));
  HxType.register_class_empty_ctor "sys.io._Process.OcamlProcessInput" (fun () -> Obj.repr (Sys_io_Process.ocamlprocessinput___empty ()));
  HxType.register_class_empty_ctor "sys.io._Process.OcamlProcessOutput" (fun () -> Obj.repr (Sys_io_Process.ocamlprocessoutput___empty ()));
  HxType.register_class_empty_ctor "sys.io._Stdio.OcamlStdioInput" (fun () -> Obj.repr (Sys_io_Stdio.ocamlstdioinput___empty ()));
  HxType.register_class_empty_ctor "sys.io._Stdio.OcamlStdioOutput" (fun () -> Obj.repr (Sys_io_Stdio.ocamlstdiooutput___empty ()));
  HxType.register_class_instance_fields "CompilerDriver" [];
  HxType.register_class_static_fields "CompilerDriver" [ "run" ];
  HxType.register_class_instance_fields "EmitterStage" [];
  HxType.register_class_static_fields "EmitterStage" [ "constFoldString"; "currentImportInt64"; "currentOcamlModuleName"; "emit"; "emitToDir"; "escapeOcamlIdentPart"; "escapeOcamlString"; "exprToOcaml"; "exprToOcamlString"; "isOcamlKeyword"; "isUpperStart"; "lowerFirst"; "ocamlModuleNameFromTypePath"; "ocamlModuleNameFromTypePathParts"; "ocamlTypeFromTy"; "ocamlValueIdent"; "returnExprToOcaml"; "stmtListToOcaml"; "tryExtractTypePathPartsFromExpr"; "upperFirst" ];
  HxType.register_class_instance_fields "FrontendFixture" [ "expectHasStaticMain"; "expectMainClassName"; "expectPackagePath"; "getExpectHasStaticMain"; "getExpectMainClassName"; "getExpectPackagePath"; "getLabel"; "getSource"; "label"; "source" ];
  HxType.register_class_static_fields "FrontendFixture" [];
  HxType.register_class_instance_fields "HxClassDecl" [ "fields"; "functions"; "hasStaticMain"; "name" ];
  HxType.register_class_static_fields "HxClassDecl" [ "getFields"; "getFunctions"; "getHasStaticMain"; "getName" ];
  HxType.register_class_instance_fields "HxConditionalCompilation" [];
  HxType.register_class_static_fields "HxConditionalCompilation" [ "evalExpr"; "filterInlineConditionals"; "filterSource"; "findTokenOutsideStrings"; "isLineWs"; "isSpace"; "makeBlankLineLike"; "parseDirectiveLine"; "parseInlineCondEnd"; "skipStringLiteral"; "splitLinesPreserveNewlines"; "stripLineCommentOutsideStrings" ];
  HxType.register_class_instance_fields "HxDefineMap" [];
  HxType.register_class_static_fields "HxDefineMap" [ "addRawDefine"; "fromRawDefines"; "mergeInto" ];
  HxType.register_class_instance_fields "HxFieldDecl" [ "init"; "isStatic"; "name"; "typeHint"; "visibility" ];
  HxType.register_class_static_fields "HxFieldDecl" [ "getInit"; "getIsStatic"; "getName"; "getTypeHint"; "getVisibility" ];
  HxType.register_class_instance_fields "HxFunctionArg" [ "defaultValue"; "isOptional"; "isRest"; "name"; "typeHint" ];
  HxType.register_class_static_fields "HxFunctionArg" [ "getDefaultValue"; "getIsOptional"; "getIsRest"; "getName"; "getTypeHint" ];
  HxType.register_class_instance_fields "HxFunctionDecl" [ "args"; "body"; "getFirstReturnExpr"; "isStatic"; "name"; "returnStringLiteral"; "returnTypeHint"; "visibility" ];
  HxType.register_class_static_fields "HxFunctionDecl" [ "getArgs"; "getBody"; "getIsStatic"; "getName"; "getReturnStringLiteral"; "getReturnTypeHint"; "getVisibility" ];
  HxType.register_class_instance_fields "HxLexer" [ "bump"; "column"; "eof"; "index"; "line"; "next"; "peek"; "pos"; "readIdent"; "readNumber"; "readSingleQuotedString"; "readString"; "skipWhitespaceAndComments"; "src" ];
  HxType.register_class_static_fields "HxLexer" [ "isDigit"; "isIdentCont"; "isIdentStart"; "isSpace" ];
  HxType.register_class_instance_fields "HxModuleDecl" [ "classes"; "hasToplevelMain"; "headerOnly"; "imports"; "mainClass"; "packagePath" ];
  HxType.register_class_static_fields "HxModuleDecl" [ "getClasses"; "getHasToplevelMain"; "getHeaderOnly"; "getImports"; "getMainClass"; "getPackagePath" ];
  HxType.register_class_instance_fields "HxParseError" [ "message"; "pos"; "toString" ];
  HxType.register_class_static_fields "HxParseError" [];
  HxType.register_class_instance_fields "HxParser" [ "acceptKeyword"; "acceptOtherChar"; "bump"; "capturedReturnStringLiteral"; "consumeBinop"; "cur"; "expect"; "fail"; "isOtherChar"; "lex"; "parseAnonExpr"; "parseArrayDeclExpr"; "parseBinaryExpr"; "parseClassMembers"; "parseExpr"; "parseFunctionBodyStatements"; "parseFunctionBodyStatementsBestEffort"; "parseFunctionDecl"; "parseInterpolatedStringExpr"; "parseModule"; "parsePostfixExpr"; "parsePrimaryExpr"; "parseReturnStmt"; "parseStmt"; "parseSwitchExpr"; "parseSwitchPattern"; "parseTryCatchExpr"; "parseUnaryExpr"; "parseVarStmt"; "peek"; "peek2"; "peekBinop"; "peekKind"; "peekKind2"; "peeked1"; "peeked2"; "readDottedPath"; "readIdent"; "readImportPath"; "readTypeHintText"; "skipBalancedBraces"; "skipBalancedParens"; "syncToStmtEnd" ];
  HxType.register_class_static_fields "HxParser" [ "binopPrec"; "debugBodyLabel"; "isRightAssoc"; "isUpperStart"; "keywordText"; "parseExprText"; "parseFunctionBodyText" ];
  HxType.register_class_instance_fields "HxPos" [ "column"; "getColumn"; "getIndex"; "getLine"; "index"; "line"; "toString" ];
  HxType.register_class_static_fields "HxPos" [ "unknown" ];
  HxType.register_class_instance_fields "HxToken" [ "kind"; "pos" ];
  HxType.register_class_static_fields "HxToken" [];
  HxType.register_class_instance_fields "LazyTypeLoader" [ "ensureTypeAvailable" ];
  HxType.register_class_static_fields "LazyTypeLoader" [];
  HxType.register_class_instance_fields "MacroExpandedModule" [ "generatedOcamlModules"; "getGeneratedOcamlModules"; "getTyped"; "macroMode"; "typed" ];
  HxType.register_class_static_fields "MacroExpandedModule" [];
  HxType.register_class_instance_fields "MacroExpandedProgram" [ "generatedOcamlModules"; "getGeneratedOcamlModules"; "getTypedModules"; "macroMode"; "typedModules" ];
  HxType.register_class_static_fields "MacroExpandedProgram" [];
  HxType.register_class_instance_fields "MacroStage" [];
  HxType.register_class_static_fields "MacroStage" [ "expand"; "expandProgram" ];
  HxType.register_class_instance_fields "ModuleLoader" [ "classPaths"; "defines"; "depsForParsedModule"; "dirEntryCache"; "drainNewModules"; "ensureTypeAvailable"; "index"; "loadModuleByPath"; "markResolvedAlready"; "pending"; "resolveModuleFile"; "visited" ];
  HxType.register_class_static_fields "ModuleLoader" [ "candidateModulePaths"; "implicitQualifiedTypeDeps"; "normalizeImport" ];
  HxType.register_class_instance_fields "ParsedModule" [ "decl"; "filePath"; "getDecl"; "getFilePath"; "getSource"; "source" ];
  HxType.register_class_static_fields "ParsedModule" [];
  HxType.register_class_instance_fields "ParserStage" [];
  HxType.register_class_static_fields "ParserStage" [ "decodeLenPayload"; "decodeMethodPayload"; "decodeNativeProtocol"; "decodeStaticFinalPayload"; "expectedMainClassFromFile"; "parse"; "parseDecInt"; "parseReturnExprText"; "parseViaNativeHooks"; "scanClassBodyForStatics"; "scanEnumAbstractBodyForValues"; "scanEnumBodyForCtors"; "scanModuleLocalHelperAbstracts"; "scanModuleLocalHelperClasses"; "scanModuleLocalHelperEnums"; "scanModuleLocalHelperTypedefs"; "scanNextToken"; "splitN"; "throwFromErrLine"; "unescapePayload" ];
  HxType.register_class_instance_fields "ResolvedModule" [ "filePath"; "modulePath"; "parsed" ];
  HxType.register_class_static_fields "ResolvedModule" [ "getFilePath"; "getModulePath"; "getParsed" ];
  HxType.register_class_instance_fields "ResolverStage" [];
  HxType.register_class_static_fields "ResolverStage" [ "implicitQualifiedTypeDeps"; "implicitSamePackageDeps"; "normalizeImport"; "parseProject"; "parseProjectRoots"; "resolveImplicitSamePackageTypesEnabled"; "resolveModuleFile"; "traceResolverDepsEnabled" ];
  HxType.register_class_instance_fields "StringBuf" [ "add"; "addChar"; "addSub"; "buf"; "get_length"; "toString" ];
  HxType.register_class_static_fields "StringBuf" [];
  HxType.register_class_instance_fields "TyClassEnv" [ "functions"; "getFunctions"; "getName"; "name" ];
  HxType.register_class_static_fields "TyClassEnv" [];
  HxType.register_class_instance_fields "TyClassInfo" [ "fieldType"; "fields"; "fullName"; "getFullName"; "getModulePath"; "getShortName"; "hasField"; "instanceMethod"; "instanceMethods"; "modulePath"; "shortName"; "staticMethod"; "staticMethods" ];
  HxType.register_class_static_fields "TyClassInfo" [];
  HxType.register_class_instance_fields "TyFunSig" [ "args"; "getArgs"; "getIsStatic"; "getName"; "getReturnType"; "isStatic"; "name"; "returnType" ];
  HxType.register_class_static_fields "TyFunSig" [];
  HxType.register_class_instance_fields "TyFunctionEnv" [ "declareLocal"; "getLocals"; "getName"; "getParams"; "getReturnExprType"; "getReturnType"; "locals"; "name"; "params"; "resolveLocal"; "resolveSymbol"; "returnExprType"; "returnType" ];
  HxType.register_class_static_fields "TyFunctionEnv" [];
  HxType.register_class_instance_fields "TyModuleEnv" [ "getImports"; "getMainClass"; "getPackagePath"; "imports"; "mainClass"; "packagePath" ];
  HxType.register_class_static_fields "TyModuleEnv" [];
  HxType.register_class_instance_fields "TySymbol" [ "getName"; "getType"; "name"; "setType"; "ty" ];
  HxType.register_class_static_fields "TySymbol" [];
  HxType.register_class_instance_fields "TyType" [ "display"; "getDisplay"; "isNumeric"; "isUnknown"; "isVoid"; "toString" ];
  HxType.register_class_static_fields "TyType" [ "fromHintText"; "unify"; "unknown" ];
  HxType.register_class_instance_fields "TypedModule" [ "env"; "getEnv"; "getParsed"; "parsed" ];
  HxType.register_class_static_fields "TypedModule" [];
  HxType.register_class_instance_fields "TyperContext" [ "classFullName"; "currentClass"; "filePath"; "getClassFullName"; "getFilePath"; "getImports"; "getIndex"; "getModulePath"; "getPackagePath"; "imports"; "index"; "loader"; "modulePath"; "packagePath"; "resolveType" ];
  HxType.register_class_static_fields "TyperContext" [];
  HxType.register_class_instance_fields "TyperError" [ "filePath"; "getFilePath"; "getMessage"; "getPos"; "message"; "pos"; "toString" ];
  HxType.register_class_static_fields "TyperError" [];
  HxType.register_class_instance_fields "TyperIndex" [ "addClass"; "byFullName"; "byShortName"; "getByFullName"; "getByShortName"; "resolveTypePath" ];
  HxType.register_class_static_fields "TyperIndex" [ "build"; "classFullName"; "classFullNameInModule"; "expectedModuleNameFromFile" ];
  HxType.register_class_instance_fields "TyperIndexBuild" [];
  HxType.register_class_static_fields "TyperIndexBuild" [ "classFullName"; "classFullNameInModule"; "expectedModuleNameFromFile"; "fromResolvedModule" ];
  HxType.register_class_instance_fields "TyperStage" [];
  HxType.register_class_static_fields "TyperStage" [ "arrayElementType"; "inferExprType"; "inferReturnType"; "isStrict"; "typeFromHintInContext"; "typeFunction"; "typeModule"; "typeResolvedModule" ];
  HxType.register_class_instance_fields "_EmitterStage._EmitterStageDebug" [];
  HxType.register_class_static_fields "_EmitterStage._EmitterStageDebug" [ "traceCallSig" ];
  HxType.register_class_instance_fields "_HxConditionalCompilation.ExprLexer" [ "bump"; "eof"; "i"; "isIdentCont"; "isIdentStart"; "isWs"; "next"; "peek"; "readIdent"; "readString"; "s"; "skipWs" ];
  HxType.register_class_static_fields "_HxConditionalCompilation.ExprLexer" [];
  HxType.register_class_instance_fields "_HxConditionalCompilation.ExprParser" [ "bump"; "cur"; "definedValue"; "defines"; "lex"; "parse"; "parseAnd"; "parseIdentTail"; "parseOr"; "parsePrimary"; "parseStringLit"; "parseUnary" ];
  HxType.register_class_static_fields "_HxConditionalCompilation.ExprParser" [];
  HxType.register_class_instance_fields "haxe.Exception" [ "__exceptionMessage"; "__exceptionStack"; "__nativeException"; "__nativeStack"; "__previousException"; "__shiftStack"; "__skipStack"; "__unshiftStack"; "details"; "get_message"; "get_native"; "get_previous"; "get_stack"; "toString"; "unwrap" ];
  HxType.register_class_static_fields "haxe.Exception" [ "caught"; "thrown" ];
  HxType.register_class_instance_fields "haxe.NativeStackTrace" [];
  HxType.register_class_static_fields "haxe.NativeStackTrace" [ "callStack"; "exceptionStack"; "parseFileLine"; "saveStack"; "toHaxe" ];
  HxType.register_class_instance_fields "haxe.io.BytesBuffer" [ "add"; "addByte"; "addBytes"; "addDouble"; "addFloat"; "addInt32"; "addInt64"; "addString"; "b"; "getBytes"; "get_length" ];
  HxType.register_class_static_fields "haxe.io.BytesBuffer" [];
  HxType.register_class_instance_fields "haxe.io.FPHelper" [];
  HxType.register_class_static_fields "haxe.io.FPHelper" [ "doubleToI64"; "floatToI32"; "i32ToFloat"; "i64ToDouble" ];
  HxType.register_class_instance_fields "haxe.io.Input" [ "bigEndian"; "close"; "read"; "readAll"; "readByte"; "readBytes"; "readDouble"; "readFloat"; "readFullBytes"; "readInt16"; "readInt24"; "readInt32"; "readInt8"; "readLine"; "readString"; "readUInt16"; "readUInt24"; "readUntil"; "set_bigEndian" ];
  HxType.register_class_static_fields "haxe.io.Input" [];
  HxType.register_class_instance_fields "haxe.io.Output" [ "bigEndian"; "close"; "flush"; "prepare"; "set_bigEndian"; "write"; "writeByte"; "writeBytes"; "writeDouble"; "writeFloat"; "writeFullBytes"; "writeInput"; "writeInt16"; "writeInt24"; "writeInt32"; "writeInt8"; "writeString"; "writeUInt16"; "writeUInt24"; "writeUInt8" ];
  HxType.register_class_static_fields "haxe.io.Output" [];
  HxType.register_class_instance_fields "hxhx.ExprMacroExpander" [];
  HxType.register_class_static_fields "hxhx.ExprMacroExpander" [ "buildImportMap"; "escapeStringLiteral"; "expandResolvedModules"; "exprKind"; "isTrueEnv"; "matchAllowlistedCall"; "renderCalleePath"; "renderSimpleCall"; "rewriteExpr"; "rewriteExprOrNull"; "rewriteStmt"; "shortenCall" ];
  HxType.register_class_instance_fields "hxhx.Hxml" [];
  HxType.register_class_static_fields "hxhx.Hxml" [ "expandArgsToUnits"; "isSpace"; "parseFile"; "parseFileRec"; "parseFileUnits"; "splitIntoUnits"; "tokenizeLine" ];
  HxType.register_class_instance_fields "hxhx.Main" [];
  HxType.register_class_static_fields "hxhx.Main" [ "absPath"; "addDefineIfMissing"; "defaultExeName"; "fatal"; "getDefineValue"; "hasAnyTarget"; "hasDefine"; "main"; "rmrf"; "runOcamlInterpLike"; "sanitizeName"; "stripAll" ];
  HxType.register_class_instance_fields "hxhx.Stage1Args" [ "classPaths"; "cwd"; "defines"; "displayRequest"; "hadCmd"; "libs"; "macros"; "main"; "noOutput"; "roots" ];
  HxType.register_class_static_fields "hxhx.Stage1Args" [ "expandHxmlArgs"; "getClassPaths"; "getCwd"; "getDefines"; "getDisplayRequest"; "getHadCmd"; "getLibs"; "getMacros"; "getMain"; "getNoOutput"; "getRoots"; "inferStdRoot"; "parse" ];
  HxType.register_class_instance_fields "hxhx.Stage1Compiler" [];
  HxType.register_class_static_fields "hxhx.Stage1Compiler" [ "error"; "formatParseError"; "haxelibBin"; "resolveHaxelibPaths"; "run" ];
  HxType.register_class_instance_fields "hxhx.Stage1Resolver" [];
  HxType.register_class_static_fields "hxhx.Stage1Resolver" [ "normalizeSep"; "resolveClassPath"; "resolveMain"; "resolveModule" ];
  HxType.register_class_instance_fields "hxhx.Stage3Compiler" [];
  HxType.register_class_static_fields "hxhx.Stage3Compiler" [ "absFromCwd"; "anyNonBuiltinMacro"; "bool01"; "buildFieldsPayloadForParsed"; "buildMacroHostExe"; "collectUnsupportedExprRawInExpr"; "collectUnsupportedExprRawInModule"; "collectUnsupportedExprRawInStmt"; "countUnsupportedExprsInExpr"; "countUnsupportedExprsInFunction"; "countUnsupportedExprsInModule"; "countUnsupportedExprsInStmt"; "decodeWaitStdioRequest"; "encodeConnectRequest"; "error"; "escapeOneLine"; "findBuildMacroExprs"; "findFlagValue"; "findHaxeLibrariesHxml"; "findManyFlagValues"; "findSingleFlagValue"; "formatException"; "hasDefineFlag"; "hasFlag"; "haxelibBin"; "inferMainFromDisplayRequest"; "inferRepoRootForScripts"; "isBuiltinMacroExpr"; "isTrueEnv"; "parseConnectMode"; "parseDelimitedList"; "parseGeneratedMembers"; "parseGlobalStage3Flags"; "parseWaitMode"; "processConnectResponse"; "readConnectDisplayStdin"; "resolveHaxelibSpec"; "resolveHaxelibSpecFromHxml"; "resolveHaxelibSpecViaProcess"; "run"; "runConnect"; "runOne"; "runWaitSocket"; "runWaitStdio"; "runWaitStdioRequest"; "shouldAutoBuildMacroHost"; "summarizeArgs"; "synthesizeDisplayResponse"; "trim"; "writeWaitStdioReply" ];
  HxType.register_class_instance_fields "hxhx.TargetPresets" [];
  HxType.register_class_static_fields "hxhx.TargetPresets" [ "apply"; "applyOcaml"; "findBundledLibRoot"; "listTargets" ];
  HxType.register_class_instance_fields "hxhx._TargetPresets.ArgScan" [];
  HxType.register_class_static_fields "hxhx._TargetPresets.ArgScan" [ "addCpIfExists"; "addDefineIfMissing"; "addMacroIfMissing"; "getDefineValue"; "hasDefine"; "hasLib"; "hasMacro" ];
  HxType.register_class_instance_fields "hxhx.macro.MacroHostClient" [];
  HxType.register_class_static_fields "hxhx.macro.MacroHostClient" [ "connect"; "getType"; "openSession"; "resolveMacroHostExe"; "resolveMacroHostExePath"; "run"; "runAll"; "selftest" ];
  HxType.register_class_instance_fields "hxhx.macro.MacroHostSession" [ "client"; "close"; "expandExpr"; "run"; "runHook" ];
  HxType.register_class_static_fields "hxhx.macro.MacroHostSession" [];
  HxType.register_class_instance_fields "hxhx.macro.MacroProtocol" [];
  HxType.register_class_static_fields "hxhx.macro.MacroProtocol" [ "decodeLenValue"; "encodeLen"; "escapePayload"; "kvGet"; "kvParse"; "splitN"; "unescapePayload" ];
  HxType.register_class_instance_fields "hxhx.macro.MacroState" [];
  HxType.register_class_static_fields "hxhx.macro.MacroState" [ "addClassPath"; "afterGenerateHookIds"; "afterTypingHookIds"; "buildFieldsByModule"; "buildFieldsPayload"; "classPaths"; "clearBuildFields"; "defined"; "definedValue"; "defines"; "emitBuildFields"; "emitHxModule"; "emitOcamlModule"; "generatedHxDir"; "generatedHxModules"; "getBuildFieldsPayload"; "getGeneratedHxDir"; "getOcamlModuleSource"; "hasGeneratedHxModules"; "includeModule"; "includedModules"; "listAfterGenerateHookIds"; "listAfterTypingHookIds"; "listBuildFields"; "listClassPaths"; "listDefineNames"; "listDefinesPairsSorted"; "listIncludedModules"; "listOcamlModuleNames"; "listOnGenerateHookIds"; "ocamlModules"; "onGenerateHookIds"; "registerHook"; "reset"; "seedFromCliDefines"; "setBuildFieldsPayload"; "setDefine"; "setGeneratedHxDir"; "sortStringsInPlace" ];
  HxType.register_class_instance_fields "hxhx.macro._MacroHostClient.MacroClient" [ "call"; "close"; "drainStderr"; "handleInboundReq"; "nextId"; "proc"; "replyErr"; "replyOk" ];
  HxType.register_class_static_fields "hxhx.macro._MacroHostClient.MacroClient" [ "TRACE"; "TRACE_HOST"; "connect" ];
  HxType.register_class_instance_fields "ocaml._Buffer.Buffer_Impl_" [];
  HxType.register_class_static_fields "ocaml._Buffer.Buffer_Impl_" [ "_new"; "addString"; "contents"; "create"; "length" ];
  HxType.register_class_instance_fields "sys.io.File" [];
  HxType.register_class_static_fields "sys.io.File" [ "append"; "copy"; "getBytes"; "getContent"; "read"; "saveBytes"; "saveContent"; "update"; "write" ];
  HxType.register_class_instance_fields "sys.io.FileInput" [ "bigEndian"; "close"; "eof"; "h"; "read"; "readAll"; "readByte"; "readBytes"; "readDouble"; "readFloat"; "readFullBytes"; "readInt16"; "readInt24"; "readInt32"; "readInt8"; "readLine"; "readString"; "readUInt16"; "readUInt24"; "readUntil"; "seek"; "set_bigEndian"; "tell" ];
  HxType.register_class_static_fields "sys.io.FileInput" [ "seekKind" ];
  HxType.register_class_instance_fields "sys.io.FileOutput" [ "bigEndian"; "close"; "flush"; "h"; "prepare"; "seek"; "set_bigEndian"; "tell"; "write"; "writeByte"; "writeBytes"; "writeDouble"; "writeFloat"; "writeFullBytes"; "writeInput"; "writeInt16"; "writeInt24"; "writeInt32"; "writeInt8"; "writeString"; "writeUInt16"; "writeUInt24"; "writeUInt8" ];
  HxType.register_class_static_fields "sys.io.FileOutput" [ "seekKind" ];
  HxType.register_class_instance_fields "sys.io.Process" [ "cachedExitCode"; "close"; "closed"; "exitCode"; "getPid"; "handle"; "kill"; "stderr"; "stdin"; "stdout" ];
  HxType.register_class_static_fields "sys.io.Process" [];
  HxType.register_class_instance_fields "sys.io.Stdio" [];
  HxType.register_class_static_fields "sys.io.Stdio" [ "stderr"; "stdin"; "stdout" ];
  HxType.register_class_instance_fields "sys.io._Process.OcamlProcessInput" [ "bigEndian"; "close"; "handle"; "read"; "readAll"; "readByte"; "readBytes"; "readDouble"; "readFloat"; "readFullBytes"; "readInt16"; "readInt24"; "readInt32"; "readInt8"; "readLine"; "readString"; "readUInt16"; "readUInt24"; "readUntil"; "set_bigEndian"; "stream" ];
  HxType.register_class_static_fields "sys.io._Process.OcamlProcessInput" [];
  HxType.register_class_instance_fields "sys.io._Process.OcamlProcessOutput" [ "bigEndian"; "close"; "flush"; "handle"; "prepare"; "set_bigEndian"; "write"; "writeByte"; "writeBytes"; "writeDouble"; "writeFloat"; "writeFullBytes"; "writeInput"; "writeInt16"; "writeInt24"; "writeInt32"; "writeInt8"; "writeString"; "writeUInt16"; "writeUInt24"; "writeUInt8" ];
  HxType.register_class_static_fields "sys.io._Process.OcamlProcessOutput" [];
  HxType.register_class_instance_fields "sys.io._Stdio.OcamlStdioInput" [ "bigEndian"; "close"; "read"; "readAll"; "readByte"; "readBytes"; "readDouble"; "readFloat"; "readFullBytes"; "readInt16"; "readInt24"; "readInt32"; "readInt8"; "readLine"; "readString"; "readUInt16"; "readUInt24"; "readUntil"; "set_bigEndian"; "stream" ];
  HxType.register_class_static_fields "sys.io._Stdio.OcamlStdioInput" [];
  HxType.register_class_instance_fields "sys.io._Stdio.OcamlStdioOutput" [ "bigEndian"; "close"; "flush"; "prepare"; "set_bigEndian"; "stream"; "write"; "writeByte"; "writeBytes"; "writeDouble"; "writeFloat"; "writeFullBytes"; "writeInput"; "writeInt16"; "writeInt24"; "writeInt32"; "writeInt8"; "writeString"; "writeUInt16"; "writeUInt24"; "writeUInt8" ];
  HxType.register_class_static_fields "sys.io._Stdio.OcamlStdioOutput" [];
  HxType.register_class_super "ModuleLoader" (HxType.class_ "LazyTypeLoader");
  HxType.register_class_super "sys.io.FileInput" (HxType.class_ "haxe.io.Input");
  HxType.register_class_super "sys.io.FileOutput" (HxType.class_ "haxe.io.Output");
  HxType.register_class_super "sys.io._Process.OcamlProcessInput" (HxType.class_ "haxe.io.Input");
  HxType.register_class_super "sys.io._Process.OcamlProcessOutput" (HxType.class_ "haxe.io.Output");
  HxType.register_class_super "sys.io._Stdio.OcamlStdioInput" (HxType.class_ "haxe.io.Input");
  HxType.register_class_super "sys.io._Stdio.OcamlStdioOutput" (HxType.class_ "haxe.io.Output");
  HxType.register_class_tags "CompilerDriver" [ "CompilerDriver" ];
  HxType.register_class_tags "EmitterStage" [ "EmitterStage" ];
  HxType.register_class_tags "FrontendFixture" [ "FrontendFixture" ];
  HxType.register_class_tags "HxClassDecl" [ "HxClassDecl" ];
  HxType.register_class_tags "HxConditionalCompilation" [ "HxConditionalCompilation" ];
  HxType.register_class_tags "HxDefineMap" [ "HxDefineMap" ];
  HxType.register_class_tags "HxFieldDecl" [ "HxFieldDecl" ];
  HxType.register_class_tags "HxFunctionArg" [ "HxFunctionArg" ];
  HxType.register_class_tags "HxFunctionDecl" [ "HxFunctionDecl" ];
  HxType.register_class_tags "HxLexer" [ "HxLexer" ];
  HxType.register_class_tags "HxModuleDecl" [ "HxModuleDecl" ];
  HxType.register_class_tags "HxParseError" [ "HxParseError" ];
  HxType.register_class_tags "HxParser" [ "HxParser" ];
  HxType.register_class_tags "HxPos" [ "HxPos" ];
  HxType.register_class_tags "HxToken" [ "HxToken" ];
  HxType.register_class_tags "IntIterator" [ "IntIterator" ];
  HxType.register_class_tags "LazyTypeLoader" [ "LazyTypeLoader" ];
  HxType.register_class_tags "MacroExpandedModule" [ "MacroExpandedModule" ];
  HxType.register_class_tags "MacroExpandedProgram" [ "MacroExpandedProgram" ];
  HxType.register_class_tags "MacroStage" [ "MacroStage" ];
  HxType.register_class_tags "ModuleLoader" [ "LazyTypeLoader"; "ModuleLoader" ];
  HxType.register_class_tags "ParsedModule" [ "ParsedModule" ];
  HxType.register_class_tags "ParserStage" [ "ParserStage" ];
  HxType.register_class_tags "ResolvedModule" [ "ResolvedModule" ];
  HxType.register_class_tags "ResolverStage" [ "ResolverStage" ];
  HxType.register_class_tags "StringBuf" [ "StringBuf" ];
  HxType.register_class_tags "StringTools" [ "StringTools" ];
  HxType.register_class_tags "TyClassEnv" [ "TyClassEnv" ];
  HxType.register_class_tags "TyClassInfo" [ "TyClassInfo" ];
  HxType.register_class_tags "TyFunSig" [ "TyFunSig" ];
  HxType.register_class_tags "TyFunctionEnv" [ "TyFunctionEnv" ];
  HxType.register_class_tags "TyModuleEnv" [ "TyModuleEnv" ];
  HxType.register_class_tags "TySymbol" [ "TySymbol" ];
  HxType.register_class_tags "TyType" [ "TyType" ];
  HxType.register_class_tags "TypedModule" [ "TypedModule" ];
  HxType.register_class_tags "TyperContext" [ "TyperContext" ];
  HxType.register_class_tags "TyperError" [ "TyperError" ];
  HxType.register_class_tags "TyperIndex" [ "TyperIndex" ];
  HxType.register_class_tags "TyperIndexBuild" [ "TyperIndexBuild" ];
  HxType.register_class_tags "TyperStage" [ "TyperStage" ];
  HxType.register_class_tags "_Any.Any_Impl_" [ "_Any.Any_Impl_" ];
  HxType.register_class_tags "_EmitterStage._EmitterStageDebug" [ "_EmitterStage._EmitterStageDebug" ];
  HxType.register_class_tags "_EnumValue.EnumValue_Impl_" [ "_EnumValue.EnumValue_Impl_" ];
  HxType.register_class_tags "_HxConditionalCompilation.ExprLexer" [ "_HxConditionalCompilation.ExprLexer" ];
  HxType.register_class_tags "_HxConditionalCompilation.ExprParser" [ "_HxConditionalCompilation.ExprParser" ];
  HxType.register_class_tags "haxe.Exception" [ "haxe.Exception" ];
  HxType.register_class_tags "haxe.IMap" [ "haxe.IMap" ];
  HxType.register_class_tags "haxe.Int64Helper" [ "haxe.Int64Helper" ];
  HxType.register_class_tags "haxe.NativeStackTrace" [ "haxe.NativeStackTrace" ];
  HxType.register_class_tags "haxe.SysTools" [ "haxe.SysTools" ];
  HxType.register_class_tags "haxe._CallStack.CallStack_Impl_" [ "haxe._CallStack.CallStack_Impl_" ];
  HxType.register_class_tags "haxe._Constraints.Constructible_Impl_" [ "haxe._Constraints.Constructible_Impl_" ];
  HxType.register_class_tags "haxe._Constraints.FlatEnum_Impl_" [ "haxe._Constraints.FlatEnum_Impl_" ];
  HxType.register_class_tags "haxe._Constraints.Function_Impl_" [ "haxe._Constraints.Function_Impl_" ];
  HxType.register_class_tags "haxe._Constraints.NotVoid_Impl_" [ "haxe._Constraints.NotVoid_Impl_" ];
  HxType.register_class_tags "haxe._Int32.Int32_Impl_" [ "haxe._Int32.Int32_Impl_" ];
  HxType.register_class_tags "haxe._Int64.Int64_Impl_" [ "haxe._Int64.Int64_Impl_" ];
  HxType.register_class_tags "haxe._Int64.___Int64" [ "haxe._Int64.___Int64" ];
  HxType.register_class_tags "haxe.ds.BalancedTree" [ "haxe.IMap"; "haxe.ds.BalancedTree" ];
  HxType.register_class_tags "haxe.ds.EnumValueMap" [ "haxe.IMap"; "haxe.ds.BalancedTree"; "haxe.ds.EnumValueMap" ];
  HxType.register_class_tags "haxe.ds.TreeNode" [ "haxe.ds.TreeNode" ];
  HxType.register_class_tags "haxe.ds._Map.Map_Impl_" [ "haxe.ds._Map.Map_Impl_" ];
  HxType.register_class_tags "haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" [ "haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" ];
  HxType.register_class_tags "haxe.exceptions.NotImplementedException" [ "haxe.Exception"; "haxe.exceptions.NotImplementedException"; "haxe.exceptions.PosException" ];
  HxType.register_class_tags "haxe.exceptions.PosException" [ "haxe.Exception"; "haxe.exceptions.PosException" ];
  HxType.register_class_tags "haxe.io.BytesBuffer" [ "haxe.io.BytesBuffer" ];
  HxType.register_class_tags "haxe.io.Eof" [ "haxe.io.Eof" ];
  HxType.register_class_tags "haxe.io.FPHelper" [ "haxe.io.FPHelper" ];
  HxType.register_class_tags "haxe.io.Input" [ "haxe.io.Input" ];
  HxType.register_class_tags "haxe.io.Output" [ "haxe.io.Output" ];
  HxType.register_class_tags "haxe.io.Path" [ "haxe.io.Path" ];
  HxType.register_class_tags "haxe.iterators.ArrayIterator" [ "haxe.iterators.ArrayIterator" ];
  HxType.register_class_tags "haxe.iterators.ArrayKeyValueIterator" [ "haxe.iterators.ArrayKeyValueIterator" ];
  HxType.register_class_tags "haxe.iterators.MapKeyValueIterator" [ "haxe.iterators.MapKeyValueIterator" ];
  HxType.register_class_tags "haxe.iterators.StringIterator" [ "haxe.iterators.StringIterator" ];
  HxType.register_class_tags "haxe.iterators.StringIteratorUnicode" [ "haxe.iterators.StringIteratorUnicode" ];
  HxType.register_class_tags "haxe.iterators.StringKeyValueIterator" [ "haxe.iterators.StringKeyValueIterator" ];
  HxType.register_class_tags "hxhx.ExprMacroExpander" [ "hxhx.ExprMacroExpander" ];
  HxType.register_class_tags "hxhx.Hxml" [ "hxhx.Hxml" ];
  HxType.register_class_tags "hxhx.Main" [ "hxhx.Main" ];
  HxType.register_class_tags "hxhx.Stage1Args" [ "hxhx.Stage1Args" ];
  HxType.register_class_tags "hxhx.Stage1Compiler" [ "hxhx.Stage1Compiler" ];
  HxType.register_class_tags "hxhx.Stage1Resolver" [ "hxhx.Stage1Resolver" ];
  HxType.register_class_tags "hxhx.Stage3Compiler" [ "hxhx.Stage3Compiler" ];
  HxType.register_class_tags "hxhx.TargetPresets" [ "hxhx.TargetPresets" ];
  HxType.register_class_tags "hxhx._TargetPresets.ArgScan" [ "hxhx._TargetPresets.ArgScan" ];
  HxType.register_class_tags "hxhx.macro.MacroHostClient" [ "hxhx.macro.MacroHostClient" ];
  HxType.register_class_tags "hxhx.macro.MacroHostSession" [ "hxhx.macro.MacroHostSession" ];
  HxType.register_class_tags "hxhx.macro.MacroProtocol" [ "hxhx.macro.MacroProtocol" ];
  HxType.register_class_tags "hxhx.macro.MacroState" [ "hxhx.macro.MacroState" ];
  HxType.register_class_tags "hxhx.macro._MacroHostClient.MacroClient" [ "hxhx.macro._MacroHostClient.MacroClient" ];
  HxType.register_class_tags "ocaml._Buffer.Buffer_Impl_" [ "ocaml._Buffer.Buffer_Impl_" ];
  HxType.register_class_tags "sys.io.File" [ "sys.io.File" ];
  HxType.register_class_tags "sys.io.FileInput" [ "haxe.io.Input"; "sys.io.FileInput" ];
  HxType.register_class_tags "sys.io.FileOutput" [ "haxe.io.Output"; "sys.io.FileOutput" ];
  HxType.register_class_tags "sys.io.Process" [ "sys.io.Process" ];
  HxType.register_class_tags "sys.io.Stdio" [ "sys.io.Stdio" ];
  HxType.register_class_tags "sys.io._Process.OcamlProcessInput" [ "haxe.io.Input"; "sys.io._Process.OcamlProcessInput" ];
  HxType.register_class_tags "sys.io._Process.OcamlProcessOutput" [ "haxe.io.Output"; "sys.io._Process.OcamlProcessOutput" ];
  HxType.register_class_tags "sys.io._Stdio.OcamlStdioInput" [ "haxe.io.Input"; "sys.io._Stdio.OcamlStdioInput" ];
  HxType.register_class_tags "sys.io._Stdio.OcamlStdioOutput" [ "haxe.io.Output"; "sys.io._Stdio.OcamlStdioOutput" ];
  ()

# 1 "sys_io_Stdio.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io._Stdio.OcamlStdioInput *)

let __reflaxe_ocaml__ = ()

type ocamlstdioinput_t = { __hx_type : Obj.t; mutable bigEndian : bool; set_bigEndian : Obj.t -> bool -> bool; readByte : Obj.t -> unit -> int; readBytes : Obj.t -> HxBytes.t -> int -> int -> int; close : Obj.t -> unit -> unit; readAll : Obj.t -> Obj.t -> HxBytes.t; readFullBytes : Obj.t -> HxBytes.t -> int -> int -> unit; readLine : Obj.t -> unit -> string; mutable stream : int }

let ocamlstdioinput___ctor = fun (self : ocamlstdioinput_t) stream2 -> ignore ((
  ignore (Haxe_io_Input.__ctor (Obj.magic self) ());
  let __assign_1 = stream2 in (
    self.stream <- __assign_1;
    __assign_1
  )
))

let ocamlstdioinput_readByte__impl = fun (self : ocamlstdioinput_t) () -> let b = HxStdio.read_byte (self.stream) in (
  ignore (if b < 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ());
  b
)

let ocamlstdioinput_readBytes__impl = fun (self : ocamlstdioinput_t) buf pos len -> try (
  ignore (if len <= 0 then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let i = ref 0 in (
    ignore (try while !i < len do ignore ((
      ignore (HxBytes.set buf (HxInt.add pos (!i)) (self.readByte (Obj.magic self) ()));
      let __old_2 = !i in let __new_3 = HxInt.add __old_2 1 in (
        ignore (i := __new_3);
        __old_2
      )
    )) done with
      | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
      | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
      | HxRuntime.Hx_return __ret_4 -> raise (HxRuntime.Hx_return __ret_4)
      | HxRuntime.Hx_exception (__exn_v_5, __exn_tags_6) -> if HxRuntime.tags_has __exn_tags_6 "haxe.io.Eof" then let _hx = (Obj.obj __exn_v_5 : Haxe_io_Eof.t) in (
        ignore _hx;
        if !i = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ()
      ) else HxRuntime.hx_throw_typed __exn_v_5 __exn_tags_6
      | __exn_7 -> if HxRuntime.tags_has ["OcamlExn"] "haxe.io.Eof" then let _hx = (Obj.obj (Obj.repr __exn_7) : Haxe_io_Eof.t) in (
        ignore _hx;
        if !i = 0 then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ()
      ) else raise (__exn_7));
    !i
  )
) with
  | HxRuntime.Hx_return __ret_8 -> Obj.obj __ret_8

let ocamlstdioinput_readLine__impl = fun (self : ocamlstdioinput_t) () -> let s = HxStdio.read_line (self.stream) in (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then ignore (HxType.hx_throw_typed_rtti (Obj.repr (Haxe_io_Eof.create ())) ["Dynamic"; "haxe.io.Eof"]) else ());
  s
)

let ocamlstdioinput_create = fun stream2 -> let self = ({ __hx_type = HxType.class_ "sys.io._Stdio.OcamlStdioInput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Input.set_bigEndian__impl (Obj.magic o) a0); readByte = (fun o () -> ocamlstdioinput_readByte__impl (Obj.magic o) ()); readBytes = (fun o a0 a1 a2 -> ocamlstdioinput_readBytes__impl (Obj.magic o) a0 a1 a2); close = (fun o () -> Haxe_io_Input.close__impl (Obj.magic o) ()); readAll = (fun o a0 -> Haxe_io_Input.readAll__impl (Obj.magic o) a0); readFullBytes = (fun o a0 a1 a2 -> Haxe_io_Input.readFullBytes__impl (Obj.magic o) a0 a1 a2); readLine = (fun o () -> ocamlstdioinput_readLine__impl (Obj.magic o) ()); stream = 0 } : ocamlstdioinput_t) in (
  ignore ((
    ignore (Haxe_io_Input.__ctor (Obj.magic self) ());
    let __assign_1 = stream2 in (
      self.stream <- __assign_1;
      __assign_1
    )
  ));
  self
)

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io._Stdio.OcamlStdioOutput *)

let __reflaxe_ocaml__ = ()

type ocamlstdiooutput_t = { __hx_type : Obj.t; mutable bigEndian : bool; set_bigEndian : Obj.t -> bool -> bool; writeByte : Obj.t -> int -> unit; writeBytes : Obj.t -> HxBytes.t -> int -> int -> int; flush : Obj.t -> unit -> unit; close : Obj.t -> unit -> unit; write : Obj.t -> HxBytes.t -> unit; writeFullBytes : Obj.t -> HxBytes.t -> int -> int -> unit; prepare : Obj.t -> int -> unit; writeInput : Obj.t -> Haxe_io_Input.t -> Obj.t -> unit; writeString : Obj.t -> string -> Obj.t -> unit; writeInt8 : Obj.t -> int -> unit; writeUInt8 : Obj.t -> int -> unit; writeInt16 : Obj.t -> int -> unit; writeUInt16 : Obj.t -> int -> unit; writeInt24 : Obj.t -> int -> unit; writeUInt24 : Obj.t -> int -> unit; writeInt32 : Obj.t -> int -> unit; mutable stream : int }

let ocamlstdiooutput___ctor = fun (self : ocamlstdiooutput_t) stream2 -> ignore ((
  ignore (Haxe_io_Output.__ctor (Obj.magic self) ());
  let __assign_1 = stream2 in (
    self.stream <- __assign_1;
    __assign_1
  )
))

let ocamlstdiooutput_writeByte__impl = fun (self : ocamlstdiooutput_t) c -> ignore (HxStdio.write_byte (self.stream) c)

let ocamlstdiooutput_writeBytes__impl = fun (self : ocamlstdiooutput_t) buf pos len -> try (
  ignore (if len <= 0 then raise (HxRuntime.Hx_return (Obj.repr 0)) else ());
  let _g = ref 0 in let _g1 = len in (
    ignore (while !_g < _g1 do ignore (let i = let __old_2 = !_g in let __new_3 = HxInt.add __old_2 1 in (
      ignore (_g := __new_3);
      __old_2
    ) in self.writeByte (Obj.magic self) (HxBytes.get buf (HxInt.add pos i))) done);
    len
  )
) with
  | HxRuntime.Hx_return __ret_4 -> Obj.obj __ret_4

let ocamlstdiooutput_writeString__impl = fun (self : ocamlstdiooutput_t) s encoding -> ignore (try (
  ignore (if encoding != Obj.magic (HxRuntime.hx_null) then ignore () else ());
  ignore (if s == Obj.magic (HxRuntime.hx_null) || HxString.length s = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  HxStdio.write_string (self.stream) s
) with
  | HxRuntime.Hx_return __ret_5 -> Obj.obj __ret_5)

let ocamlstdiooutput_flush__impl = fun (self : ocamlstdiooutput_t) () -> ignore (HxStdio.flush (self.stream))

let ocamlstdiooutput_create = fun stream2 -> let self = ({ __hx_type = HxType.class_ "sys.io._Stdio.OcamlStdioOutput"; bigEndian = false; set_bigEndian = (fun o a0 -> Haxe_io_Output.set_bigEndian__impl (Obj.magic o) a0); writeByte = (fun o a0 -> ocamlstdiooutput_writeByte__impl (Obj.magic o) a0); writeBytes = (fun o a0 a1 a2 -> ocamlstdiooutput_writeBytes__impl (Obj.magic o) a0 a1 a2); flush = (fun o () -> ocamlstdiooutput_flush__impl (Obj.magic o) ()); close = (fun o () -> Haxe_io_Output.close__impl (Obj.magic o) ()); write = (fun o a0 -> Haxe_io_Output.write__impl (Obj.magic o) a0); writeFullBytes = (fun o a0 a1 a2 -> Haxe_io_Output.writeFullBytes__impl (Obj.magic o) a0 a1 a2); prepare = (fun o a0 -> Haxe_io_Output.prepare__impl (Obj.magic o) a0); writeInput = (fun o a0 a1 -> Haxe_io_Output.writeInput__impl (Obj.magic o) a0 a1); writeString = (fun o a0 a1 -> ocamlstdiooutput_writeString__impl (Obj.magic o) a0 a1); writeInt8 = (fun o a0 -> Haxe_io_Output.writeInt8__impl (Obj.magic o) a0); writeUInt8 = (fun o a0 -> Haxe_io_Output.writeUInt8__impl (Obj.magic o) a0); writeInt16 = (fun o a0 -> Haxe_io_Output.writeInt16__impl (Obj.magic o) a0); writeUInt16 = (fun o a0 -> Haxe_io_Output.writeUInt16__impl (Obj.magic o) a0); writeInt24 = (fun o a0 -> Haxe_io_Output.writeInt24__impl (Obj.magic o) a0); writeUInt24 = (fun o a0 -> Haxe_io_Output.writeUInt24__impl (Obj.magic o) a0); writeInt32 = (fun o a0 -> Haxe_io_Output.writeInt32__impl (Obj.magic o) a0); stream = 0 } : ocamlstdiooutput_t) in (
  ignore ((
    ignore (Haxe_io_Output.__ctor (Obj.magic self) ());
    let __assign_1 = stream2 in (
      self.stream <- __assign_1;
      __assign_1
    )
  ));
  self
)

(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: sys.io.Stdio *)

let __reflaxe_ocaml__ = ()

let stdin = fun () -> ocamlstdioinput_create 0

let stdout = fun () -> ocamlstdiooutput_create 1

let stderr = fun () -> ocamlstdiooutput_create 2
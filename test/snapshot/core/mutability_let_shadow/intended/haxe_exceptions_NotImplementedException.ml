# 1 "haxe_exceptions_NotImplementedException.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: haxe.exceptions.NotImplementedException *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable message : string; mutable stack : Haxe_CallStack.stackitem HxArray.t; mutable previous : Haxe_Exception.t; mutable native : Obj.t; mutable __exceptionMessage : string; mutable __exceptionStack : Haxe_CallStack.stackitem HxArray.t; mutable __nativeStack : Obj.t; mutable __skipStack : int; mutable __nativeException : Obj.t; mutable __previousException : Haxe_Exception.t; unwrap : Obj.t -> unit -> Obj.t; toString : Obj.t -> unit -> string; details : Obj.t -> unit -> string; __shiftStack : Obj.t -> unit -> unit; __unshiftStack : Obj.t -> unit -> unit; get_message : Obj.t -> unit -> string; get_previous : Obj.t -> unit -> Haxe_Exception.t; get_native : Obj.t -> unit -> Obj.t; get_stack : Obj.t -> unit -> Haxe_CallStack.stackitem HxArray.t; mutable posInfos : Obj.t }

let create = fun message previous pos -> let self = ({ __hx_type = HxType.class_ "haxe.exceptions.NotImplementedException"; message = ""; stack = Obj.magic (); previous = Obj.magic (); native = Obj.magic (); __exceptionMessage = ""; __exceptionStack = Obj.magic (); __nativeStack = Obj.magic (); __skipStack = 0; __nativeException = Obj.magic (); __previousException = Obj.magic (); unwrap = (fun o () -> Haxe_Exception.unwrap__impl (Obj.magic o) ()); toString = (fun o () -> Haxe_exceptions_PosException.toString__impl (Obj.magic o) ()); details = (fun o () -> Haxe_Exception.details__impl (Obj.magic o) ()); __shiftStack = (fun o () -> Haxe_Exception.__shiftStack__impl (Obj.magic o) ()); __unshiftStack = (fun o () -> Haxe_Exception.__unshiftStack__impl (Obj.magic o) ()); get_message = (fun o () -> Haxe_Exception.get_message__impl (Obj.magic o) ()); get_previous = (fun o () -> Haxe_Exception.get_previous__impl (Obj.magic o) ()); get_native = (fun o () -> Haxe_Exception.get_native__impl (Obj.magic o) ()); get_stack = (fun o () -> Haxe_Exception.get_stack__impl (Obj.magic o) ()); posInfos = Obj.magic () } : t) in (
  ignore ((
    ignore (Haxe_exceptions_PosException.__ctor (Obj.magic self) message previous pos);
    let __obj_1 = self in let __old_2 = __obj_1.__skipStack in let __new_3 = HxInt.add __old_2 1 in (
      ignore (__obj_1.__skipStack <- __new_3);
      __old_2
    )
  ));
  self
)

let __ctor = fun (self : t) message previous pos -> ignore ((
  ignore (Haxe_exceptions_PosException.__ctor (Obj.magic self) message previous pos);
  let __obj_1 = self in let __old_2 = __obj_1.__skipStack in let __new_3 = HxInt.add __old_2 1 in (
    ignore (__obj_1.__skipStack <- __new_3);
    __old_2
  )
))
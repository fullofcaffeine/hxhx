(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: haxe.NativeStackTrace *)

let __reflaxe_ocaml__ = ()

let saveStack = fun _exception -> ()

let callStack = fun () -> let __anon_1 = HxAnon.create () in (
  ignore (HxAnon.set __anon_1 "skip" (Obj.repr 1));
  ignore (HxAnon.set __anon_1 "stack" (Obj.repr (HxBacktrace.callstack_lines 64)));
  __anon_1
)

let exceptionStack = fun () -> let __anon_2 = HxAnon.create () in (
  ignore (HxAnon.set __anon_2 "skip" (Obj.repr 0));
  ignore (HxAnon.set __anon_2 "stack" (Obj.repr (HxBacktrace.exceptionstack_lines ())));
  __anon_2
)

let parseFileLine = fun line -> try let fileNeedle = "file \"" in let fileStart0 = HxString.indexOf line fileNeedle 0 in (
  ignore (if fileStart0 < 0 then ignore (raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))) else ());
  let fileStart = fileStart0 + HxString.length fileNeedle in let fileEnd = HxString.indexOf line "\"" fileStart in (
    ignore (if fileEnd < 0 then ignore (raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))) else ());
    let file = HxString.substr line fileStart (fileEnd - fileStart) in let lineNeedle = "line " in let lineStart0 = HxString.indexOf line lineNeedle fileEnd in (
      ignore (if lineStart0 < 0 then ignore (raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))) else ());
      let i = lineStart0 + HxString.length lineNeedle in let j = ref i in (
        ignore (try while !j < HxString.length line do try ignore (let c = HxString.charCodeAt line (!j) in (
          ignore (if (let __nullable_3 = c in let __nullable_4 = 48 in if __nullable_3 == HxRuntime.hx_null then false else Obj.obj __nullable_3 < __nullable_4) || (let __nullable_5 = c in let __nullable_6 = 57 in if __nullable_5 == HxRuntime.hx_null then false else Obj.obj __nullable_5 > __nullable_6) then ignore (raise (HxRuntime.Hx_break)) else ());
          let __old_7 = !j in let __new_8 = __old_7 + 1 in (
            ignore (j := __new_8);
            __old_7
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        ignore (if !j = i then ignore (raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null))))) else ());
        let ln = ref 0 in let _g = ref i in let _g1 = !j in (
          ignore (while !_g < _g1 do ignore (let k = let __old_9 = !_g in let __new_10 = __old_9 + 1 in (
            ignore (_g := __new_10);
            __old_9
          ) in let __assign_11 = !ln * 10 + ((let __nullable_int_12 = HxString.charCodeAt line k in if __nullable_int_12 == HxRuntime.hx_null then 0 else Obj.obj __nullable_int_12) - 48) in (
            ln := __assign_11;
            __assign_11
          )) done);
          let __anon_13 = HxAnon.create () in (
            ignore (HxAnon.set __anon_13 "file" (Obj.repr file));
            ignore (HxAnon.set __anon_13 "line" (Obj.repr (!ln)));
            __anon_13
          )
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

let toHaxe = fun nativeStackTrace skip -> let native = nativeStackTrace in let toSkip = ref (skip + Obj.obj (HxAnon.get native "skip")) in let out = HxArray.create () in let _g = ref 0 in let _g1 = Obj.obj (HxAnon.get native "stack") in (
  ignore (try while !_g < HxArray.length _g1 do try ignore (let line = HxArray.get _g1 (!_g) in (
    ignore (let __old_15 = !_g in let __new_16 = __old_15 + 1 in (
      ignore (_g := __new_16);
      __new_16
    ));
    ignore (if !toSkip > 0 then ignore ((
      ignore (let __old_17 = !toSkip in let __new_18 = __old_17 + -1 in (
        ignore (toSkip := __new_18);
        __old_17
      ));
      raise (HxRuntime.Hx_continue)
    )) else ());
    let loc = parseFileLine line in if loc != Obj.magic (HxRuntime.hx_null) then ignore (HxArray.push out (Haxe_CallStack.FilePos (Obj.magic (HxRuntime.hx_null), Obj.obj (HxAnon.get loc "file"), Obj.obj (HxAnon.get loc "line"), HxRuntime.hx_null))) else ignore (HxArray.push out (Haxe_CallStack.Module line))
  )) with
    | HxRuntime.Hx_continue -> () done with
    | HxRuntime.Hx_break -> ());
  out
)
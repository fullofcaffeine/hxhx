# 1 "haxe_Exception.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: haxe.Exception *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t; mutable __exceptionMessage : string; mutable __exceptionStack : Haxe_CallStack.stackitem HxArray.t; mutable __nativeStack : Obj.t; mutable __skipStack : int; mutable __nativeException : Obj.t; mutable __previousException : t }

let create = fun message2 previous2 native2 -> let self = ({ __hx_type = HxType.class_ "haxe.Exception"; __exceptionMessage = ""; __exceptionStack = Obj.magic (); __nativeStack = Obj.magic (); __skipStack = 0; __nativeException = Obj.magic (); __previousException = Obj.magic () } : t) in (
  ignore ((
    ignore (let __assign_1 = 0 in (
      self.__skipStack <- __assign_1;
      __assign_1
    ));
    ignore (let __assign_2 = message2 in (
      self.__exceptionMessage <- __assign_2;
      __assign_2
    ));
    ignore (let __assign_3 = previous2 in (
      self.__previousException <- __assign_3;
      __assign_3
    ));
    if native2 != Obj.magic (HxRuntime.hx_null) then ignore ((
      ignore (let __assign_4 = let __anon_5 = HxAnon.create () in (
        ignore (HxAnon.set __anon_5 "skip" (Obj.repr 0));
        ignore (HxAnon.set __anon_5 "stack" (Obj.repr (HxBacktrace.exceptionstack_lines ())));
        __anon_5
      ) in (
        self.__nativeStack <- __assign_4;
        __assign_4
      ));
      let __assign_6 = Obj.repr native2 in (
        self.__nativeException <- __assign_6;
        __assign_6
      )
    )) else ignore ((
      ignore (let __assign_7 = let __anon_8 = HxAnon.create () in (
        ignore (HxAnon.set __anon_8 "skip" (Obj.repr 1));
        ignore (HxAnon.set __anon_8 "stack" (Obj.repr (HxBacktrace.callstack_lines 64)));
        __anon_8
      ) in (
        self.__nativeStack <- __assign_7;
        __assign_7
      ));
      ignore (let __obj_9 = self in let __old_10 = __obj_9.__skipStack in let __new_11 = HxInt.add __old_10 1 in (
        ignore (__obj_9.__skipStack <- __new_11);
        __old_10
      ));
      let __assign_12 = Obj.repr self in (
        self.__nativeException <- __assign_12;
        __assign_12
      )
    ))
  ));
  self
)

let unwrap = fun self () -> self.__nativeException

let __shiftStack = fun self () -> ignore (let __obj_25 = self in let __old_26 = __obj_25.__skipStack in let __new_27 = HxInt.add __old_26 1 in (
  ignore (__obj_25.__skipStack <- __new_27);
  __old_26
))

let __unshiftStack = fun self () -> ignore (let __obj_28 = self in let __old_29 = __obj_28.__skipStack in let __new_30 = HxInt.add __old_29 (-1) in (
  ignore (__obj_28.__skipStack <- __new_30);
  __old_29
))

let get_message = fun self () -> self.__exceptionMessage

let toString = fun self () -> get_message self ()

let get_previous = fun self () -> self.__previousException

let get_native = fun self () -> self.__nativeException

let get_stack = fun self () -> let tempResult = ref (Obj.magic ()) in (
  ignore (let _g = self.__exceptionStack in if _g == Obj.magic (HxRuntime.hx_null) then let __assign_31 = let __assign_32 = Haxe_NativeStackTrace.toHaxe (self.__nativeStack) (self.__skipStack) in (
    self.__exceptionStack <- __assign_32;
    __assign_32
  ) in (
    tempResult := __assign_31;
    __assign_31
  ) else let s = _g in let __assign_33 = s in (
    tempResult := __assign_33;
    __assign_33
  ));
  !tempResult
)

let details = fun self () -> let tempResult = ref "" in (
  ignore (if get_previous self () == Obj.magic (HxRuntime.hx_null) then let tempRight = ref "" in (
    ignore (let tmp = get_stack self () in if tmp == Obj.magic (HxRuntime.hx_null) then let __assign_13 = "null" in (
      tempRight := __assign_13;
      __assign_13
    ) else let __assign_14 = Haxe_CallStack.toString tmp in (
      tempRight := __assign_14;
      __assign_14
    ));
    let __assign_15 = ("Exception: " ^ HxString.toStdString (toString self ())) ^ HxString.toStdString (!tempRight) in (
      tempResult := __assign_15;
      __assign_15
    )
  ) else let result = ref "" in let e = ref self in let prev = ref (Obj.magic (HxRuntime.hx_null)) in (
    ignore (while !e != Obj.magic (HxRuntime.hx_null) do ignore ((
      ignore (if !prev == Obj.magic (HxRuntime.hx_null) then ignore (let tempRight1 = ref "" in (
        ignore (let tmp = get_stack (!e) () in if tmp == Obj.magic (HxRuntime.hx_null) then let __assign_16 = "null" in (
          tempRight1 := __assign_16;
          __assign_16
        ) else let __assign_17 = Haxe_CallStack.toString tmp in (
          tempRight1 := __assign_17;
          __assign_17
        ));
        let __assign_18 = (("Exception: " ^ HxString.toStdString (get_message (!e) ())) ^ HxString.toStdString (!tempRight1)) ^ HxString.toStdString (!result) in (
          result := __assign_18;
          __assign_18
        )
      )) else ignore (let prevStack = Haxe_CallStack.subtract (get_stack (!e) ()) (get_stack (!prev) ()) in let tempString = ref "" in (
        ignore (if prevStack == Obj.magic (HxRuntime.hx_null) then let __assign_19 = "null" in (
          tempString := __assign_19;
          __assign_19
        ) else let __assign_20 = Haxe_CallStack.toString prevStack in (
          tempString := __assign_20;
          __assign_20
        ));
        let __assign_21 = ((("Exception: " ^ HxString.toStdString (get_message (!e) ())) ^ HxString.toStdString (!tempString)) ^ "\n\nNext ") ^ HxString.toStdString (!result) in (
          result := __assign_21;
          __assign_21
        )
      )));
      ignore (let __assign_22 = !e in (
        prev := __assign_22;
        __assign_22
      ));
      let __assign_23 = get_previous (!e) () in (
        e := __assign_23;
        __assign_23
      )
    )) done);
    let __assign_24 = !result in (
      tempResult := __assign_24;
      __assign_24
    )
  ));
  !tempResult
)

let caught = fun value -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxType.isOfType value (HxType.class_ "haxe.Exception") then let __assign_34 = Obj.obj value in (
    tempResult := __assign_34;
    __assign_34
  ) else let tempString = ref "" in (
    ignore (if value == Obj.magic (HxRuntime.hx_null) then let __assign_35 = "null" in (
      tempString := __assign_35;
      __assign_35
    ) else let __assign_36 = HxRuntime.dynamic_toStdString value in (
      tempString := __assign_36;
      __assign_36
    ));
    let __assign_37 = create (!tempString) (Obj.magic (HxRuntime.hx_null)) value in (
      tempResult := __assign_37;
      __assign_37
    )
  ));
  !tempResult
)

let thrown = fun value -> let tempResult = ref (Obj.magic ()) in (
  ignore (if HxType.isOfType value (HxType.class_ "haxe.Exception") then let __assign_38 = get_native (Obj.obj value) () in (
    tempResult := __assign_38;
    __assign_38
  ) else let __assign_39 = value in (
    tempResult := __assign_39;
    __assign_39
  ));
  !tempResult
)
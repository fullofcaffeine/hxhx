package reflaxe.ocaml;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Type.TConstant;
import haxe.macro.Type.TypedExpr;

import reflaxe.DirectToStringCompiler;
import reflaxe.data.ClassFuncData;
import reflaxe.data.ClassVarData;
import reflaxe.data.EnumOptionData;

using StringTools;

/**
 * Minimal OCaml compiler scaffold.
 *
 * Milestone 0 goal: register with Reflaxe and emit at least one `.ml` file.
 * Later milestones replace string stubs with a real OCaml IR pipeline.
 */
class OcamlCompiler extends DirectToStringCompiler {
	public static var instance:OcamlCompiler;

	public function new() {
		super();
		instance = this;
	}

	public function compileClassImpl(
		classType:ClassType,
		varFields:Array<ClassVarData>,
		funcFields:Array<ClassFuncData>
	):Null<String> {
		final fullName = (classType.pack ?? []).concat([classType.name]).join(".");
		final lines:Array<String> = [];
		lines.push("(* Generated by reflaxe.ocaml (WIP) *)");
		lines.push("(* Haxe type: " + fullName + " *)");
		lines.push("");
		lines.push("let __reflaxe_ocaml__ = ()");
		return lines.join("\n");
	}

	public function compileEnumImpl(enumType:EnumType, options:Array<EnumOptionData>):Null<String> {
		final fullName = (enumType.pack ?? []).concat([enumType.name]).join(".");
		return "(* Enum (WIP): " + fullName + " *)";
	}

	public function compileExpressionImpl(expr:TypedExpr, topLevel:Bool):Null<String> {
		return switch (expr.expr) {
			case TConst(c):
				compileConstant(c);
			case _:
				// Not implemented yet (M2+).
				null;
		}
	}

	function compileConstant(c:TConstant):Null<String> {
		return switch (c) {
			case TInt(i): Std.string(i);
			case TFloat(f): Std.string(f);
			case TString(s): "\"" + escapeOcamlString(s) + "\"";
			case TBool(b): b ? "true" : "false";
			case TNull: "()"; // placeholder
			case TThis: "self"; // placeholder
			case TSuper: "super"; // placeholder
		}
	}

	static function escapeOcamlString(s:String):String {
		// Minimal escaping for scaffold output; printer milestone will replace.
		return s
			.replace("\\", "\\\\")
			.replace("\"", "\\\"")
			.replace("\n", "\\n")
			.replace("\r", "\\r")
			.replace("\t", "\\t");
	}
}

#end

package reflaxe.ocaml;

#if (macro || reflaxe_runtime)

import haxe.macro.Type;
import haxe.macro.Type.TConstant;
import haxe.macro.Type.TypedExpr;

import reflaxe.DirectToStringCompiler;
import reflaxe.data.ClassFuncData;
import reflaxe.data.ClassVarData;
import reflaxe.data.EnumOptionData;
import reflaxe.ocaml.CompilationContext;
import reflaxe.ocaml.ast.OcamlASTPrinter;
import reflaxe.ocaml.ast.OcamlBuilder;
import reflaxe.ocaml.ast.OcamlExpr;
import reflaxe.ocaml.ast.OcamlModuleItem;
import reflaxe.ocaml.ast.OcamlLetBinding;
import reflaxe.ocaml.ast.OcamlConst;
import reflaxe.ocaml.ast.OcamlPat;
import reflaxe.ocaml.runtimegen.DuneProjectEmitter;
import reflaxe.ocaml.runtimegen.OcamlBuildRunner;

using StringTools;

/**
 * Minimal OCaml compiler scaffold.
 *
 * Milestone 0 goal: register with Reflaxe and emit at least one `.ml` file.
 * Later milestones replace string stubs with a real OCaml IR pipeline.
 */
class OcamlCompiler extends DirectToStringCompiler {
	public static var instance:OcamlCompiler;
	final ctx:CompilationContext = new CompilationContext();
	final printer:OcamlASTPrinter = new OcamlASTPrinter();
	var mainModuleId:Null<String> = null;

	public function new() {
		super();
		instance = this;
	}

	public function compileClassImpl(
		classType:ClassType,
		varFields:Array<ClassVarData>,
		funcFields:Array<ClassFuncData>
	):Null<String> {
		ctx.currentModuleId = classType.module;
		ctx.variableRenameMap.clear();
		ctx.assignedVars.clear();

		final mainModule = getMainModule();
		final isMain = switch (mainModule) {
			case TClassDecl(clsRef):
				final m = clsRef.get();
				(m.module == classType.module) && (m.name == classType.name);
			case _: false;
		}
		if (isMain) {
			mainModuleId = StringTools.replace(classType.module, ".", "_");
		}

		final fullName = (classType.pack ?? []).concat([classType.name]).join(".");
		final items:Array<OcamlModuleItem> = [];
		final builder = new OcamlBuilder(ctx);

		// Header marker as a no-op binding to keep output non-empty and debuggable.
		items.push(OcamlModuleItem.ILet([{
			name: "__reflaxe_ocaml__",
			expr: OcamlExpr.EConst(OcamlConst.CUnit)
		}], false));

		// Only attempt to compile function bodies for now (M2); everything else is stubbed.
		final lets:Array<OcamlLetBinding> = [];
		for (f in funcFields) {
			if (f.expr == null) continue;
			if (!f.isStatic) continue;

			final name = f.field.name;
			final body = builder.buildExpr(f.expr);

			// Usually `f.expr` is a `TFunction(...)` and the builder returns `EFun(...)`.
			// Fallback: wrap non-function bodies as `fun () -> body` so we can still call `name ()`.
			final compiled = switch (body) {
				case OcamlExpr.EFun(_, _): body;
				case _:
					OcamlExpr.EFun([OcamlPat.PConst(OcamlConst.CUnit)], body);
			}

			lets.push({ name: name, expr: compiled });
		}
		if (lets.length > 0) {
			items.push(OcamlModuleItem.ILet(lets, false));
		}

		var out = "(* Generated by reflaxe.ocaml (WIP) *)\n(* Haxe type: " + fullName + " *)\n\n";
		out += printer.printModule(items);

		return out;
	}

	public override function onOutputComplete() {
		#if eval
		if (output == null || output.outputDir == null) return;
		final outDir = output.outputDir;

		final noDune = haxe.macro.Context.defined("ocaml_no_dune");
		if (!noDune) {
			DuneProjectEmitter.emit(output, {
				projectName: DuneProjectEmitter.defaultProjectName(outDir),
				exeName: DuneProjectEmitter.defaultExeName(outDir),
				mainModuleId: mainModuleId
			});
		}

		final buildMode = haxe.macro.Context.definedValue("ocaml_build");
		final shouldRun = haxe.macro.Context.defined("ocaml_run");
		final noBuild = haxe.macro.Context.defined("ocaml_no_build");
		final emitOnly = haxe.macro.Context.defined("ocaml_emit_only");

		final shouldBuild = !noBuild && !emitOnly;
		final strictBuild = buildMode != null;

		if (!shouldBuild && !shouldRun && buildMode == null) return;

		final exeName = DuneProjectEmitter.defaultExeName(outDir);
		final mode = buildMode != null ? buildMode : "native";

		final result = OcamlBuildRunner.tryBuildAndMaybeRun({
			outDir: outDir,
			exeName: exeName,
			mode: mode,
			run: shouldRun,
			strict: strictBuild
		});

		switch (result) {
			case Ok(msg):
				if (msg != null) haxe.macro.Context.warning(msg, haxe.macro.Context.currentPos());
			case Err(msg):
				// Strict mode (ocaml_build=...) should stop compilation if build fails.
				haxe.macro.Context.error(msg, haxe.macro.Context.currentPos());
		}
		#end
	}

	public function compileEnumImpl(enumType:EnumType, options:Array<EnumOptionData>):Null<String> {
		final fullName = (enumType.pack ?? []).concat([enumType.name]).join(".");
		return "(* Enum (WIP): " + fullName + " *)";
	}

	public function compileExpressionImpl(expr:TypedExpr, topLevel:Bool):Null<String> {
		final builder = new OcamlBuilder(ctx);
		final e = builder.buildExpr(expr);
		return printer.printExpr(e);
	}

	function compileConstant(c:TConstant):Null<String> {
		return switch (c) {
			case TInt(i): Std.string(i);
			case TFloat(f): Std.string(f);
			case TString(s): "\"" + escapeOcamlString(s) + "\"";
			case TBool(b): b ? "true" : "false";
			case TNull: "()"; // placeholder
			case TThis: "self"; // placeholder
			case TSuper: "super"; // placeholder
		}
	}

	static function escapeOcamlString(s:String):String {
		// Minimal escaping for scaffold output; printer milestone will replace.
		return s
			.replace("\\", "\\\\")
			.replace("\"", "\\\"")
			.replace("\n", "\\n")
			.replace("\r", "\\r")
			.replace("\t", "\\t");
	}
}

#end

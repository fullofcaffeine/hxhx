package reflaxe.ocaml.runtimegen;

#if (macro || reflaxe_runtime)

import haxe.io.Path;

import reflaxe.output.OutputManager;

typedef DuneProjectConfig = {
	final projectName:String;
	final exeName:String;
	final mainModuleId:Null<String>;
	final duneLibraries:Array<String>;
}

class DuneProjectEmitter {
	static inline final RUNTIME_LIB_NAME = "hx_runtime";

	public static function ocamlModuleNameFromHaxeModuleId(id:String):String {
		if (id == null || id.length == 0) return "Main";
		// OCaml module name is derived from filename; ensure leading uppercase.
		final first = id.charCodeAt(0);
		final isLower = first >= 97 && first <= 122;
		return isLower ? (String.fromCharCode(first - 32) + id.substr(1)) : id;
	}

	public static function defaultProjectName(outDir:String):String {
		final base = Path.withoutDirectory(Path.normalize(outDir));
		return sanitizeName(base.length > 0 ? base : "ocaml_app");
	}

	public static function defaultExeName(outDir:String):String {
		// Keep executable name lowercase to match dune conventions.
		return sanitizeName(defaultProjectName(outDir)).toLowerCase();
	}

	static function sanitizeName(name:String):String {
		final out = new StringBuf();
		for (i in 0...name.length) {
			final c = name.charCodeAt(i);
			final isAlphaNum = (c >= 97 && c <= 122) // a-z
				|| (c >= 65 && c <= 90) // A-Z
				|| (c >= 48 && c <= 57); // 0-9
			out.add(isAlphaNum ? String.fromCharCode(c) : "_");
		}
		var s = out.toString();
		if (s.length == 0) s = "ocaml_app";
		if (s.charCodeAt(0) >= 48 && s.charCodeAt(0) <= 57) {
			s = "_" + s;
		}
		return s;
	}

	public static function emit(output:OutputManager, cfg:DuneProjectConfig):Void {
		final projectName = cfg.projectName;
		final exeName = cfg.exeName;
		final duneLibs = cfg.duneLibraries != null ? cfg.duneLibraries.filter(s -> s != null && StringTools.trim(s).length > 0) : [];
		final duneLibLine = duneLibs.length > 0 ? (" (libraries " + duneLibs.join(" ") + ")") : null;

		output.saveFile(".gitignore", "_build/\n*.install\n");

		output.saveFile("dune-project", [
			// Keep language version conservative for distro-provided dune (e.g. Debian bookworm ships 2.9.x).
			"(lang dune 2.9)",
			"(name " + projectName + ")",
			"",
			"; Generated by reflaxe.ocaml"
		].join("\n"));

		// Runtime library (M6): built from sources copied into `runtime/`.
		final runtimeDuneLines = [
			"(library",
			" (name " + RUNTIME_LIB_NAME + ")",
			" (wrapped false)",
			" (modules :standard)"
		];
		if (duneLibLine != null) runtimeDuneLines.push(duneLibLine);
		runtimeDuneLines.push(")");
		runtimeDuneLines.push("");
		runtimeDuneLines.push("; Generated by reflaxe.ocaml");
		output.saveFile("runtime/dune", runtimeDuneLines.join("\n"));

		final exeLibs = [RUNTIME_LIB_NAME].concat(duneLibs);
		output.saveFile("dune", [
			"(executable",
			" (name " + exeName + ")",
			" (modules :standard)",
			" (libraries " + exeLibs.join(" ") + ")",
			" (modes (native exe) (byte exe)))",
			"",
			"; Generated by reflaxe.ocaml"
		].join("\n"));

		// Entry module: dune expects `<name>.ml` to exist for `(name ...)`.
		final mainModuleName = cfg.mainModuleId != null ? ocamlModuleNameFromHaxeModuleId(cfg.mainModuleId) : null;
		final entryBody = if (mainModuleName != null) {
			[
				"let () =",
				"  HxTypeRegistry.init ();",
				"  " + mainModuleName + ".main ()",
				""
			].join("\n");
		} else {
			"let () = ()\n";
		}
		output.saveFile(exeName + ".ml", entryBody);
	}
}

#end

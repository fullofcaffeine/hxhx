package reflaxe.ocaml.runtimegen;

#if (macro || reflaxe_runtime)

import reflaxe.output.OutputManager;

/**
 * Emits small, pre-instantiated OCaml modules for functorized Stdlib APIs.
 *
 * Today this focuses on `Stdlib.Map`/`Stdlib.Set`, which are only accessible through functors
 * (`Map.Make` / `Set.Make`). Haxe cannot express OCaml functor application directly, so we
 * generate a few "defunctorized" modules that downstream Haxe code can target via externs.
 *
 * The intent is to provide an OCaml-native surface that can interop with libraries expecting
 * concrete `XMap.t` / `XSet.t` types, without forcing users into `untyped __ocaml__` blocks.
 */
class OcamlNativeFunctorEmitter {
	static inline final HEADER = "(* Generated by reflaxe.ocaml (OCaml-native functor instantiations) *)";

	public static function emitMapSet(output:OutputManager):Void {
		emitMap(output, "OcamlNativeStringMap", "string");
		emitMap(output, "OcamlNativeIntMap", "int");

		emitSet(output, "OcamlNativeStringSet", "string");
		emitSet(output, "OcamlNativeIntSet", "int");
	}

	static function emitMap(output:OutputManager, moduleName:String, keyType:String):Void {
		// Use Stdlib.compare to avoid relying on `Stdlib.Int` / `Stdlib.String` module availability
		// across OCaml versions, while still producing a lawful ordering for `int`/`string`.
		final lines = [
			HEADER,
			"",
			"module Key = struct",
			"  type t = " + keyType,
			"  let compare = Stdlib.compare",
			"end",
			"",
			"include Stdlib.Map.Make(Key)",
			""
		];
		output.saveFile(moduleName + ".ml", lines.join("\n"));
	}

	static function emitSet(output:OutputManager, moduleName:String, keyType:String):Void {
		final lines = [
			HEADER,
			"",
			"module Key = struct",
			"  type t = " + keyType,
			"  let compare = Stdlib.compare",
			"end",
			"",
			"include Stdlib.Set.Make(Key)",
			""
		];
		output.saveFile(moduleName + ".ml", lines.join("\n"));
	}
}

#end


package reflaxe.ocaml.runtimegen;

#if (macro || reflaxe_runtime)

import reflaxe.output.OutputManager;

/**
 * Emits “package alias” modules to provide dot-path access in OCaml, while keeping
 * a collision-free flat module namespace for real output files.
 *
 * Why:
 * - Haxe modules are naturally hierarchical (`haxe.io.Path`).
 * - OCaml modules are file-based and not inherently hierarchical.
 * - We want both:
 *   - unique flat module files: `Haxe_io_Path.ml` (real compiled code)
 *   - ergonomic dot access: `Haxe.Io.Path` (alias modules)
 *
 * What:
 * For each compiled Haxe module dot-path, we:
 * - keep the real generated module as a flat name (already emitted by Reflaxe)
 * - generate alias modules for package prefixes, e.g.:
 *   - `Haxe.ml` contains `module Io = Haxe_io`
 *   - `Haxe_io.ml` contains `module Path = Haxe_io_Path`
 *
 * How:
 * - Build a package tree from dot-paths.
 * - Emit one `.ml` file per package node.
 * - Avoid collisions with existing real modules by suffixing `_` as needed.
 */
class PackageAliasEmitter {
	static function moduleIdToOcamlModuleName(moduleId:String):String {
		if (moduleId == null || moduleId.length == 0) return "Main";
		final flat = moduleId.split(".").join("_");
		return flat.substr(0, 1).toUpperCase() + flat.substr(1);
	}

	static function sanitizeModuleSegment(seg:String):String {
		final out = new StringBuf();
		for (i in 0...seg.length) {
			final c = seg.charCodeAt(i);
			final isAlphaNum = (c >= 97 && c <= 122) || (c >= 65 && c <= 90) || (c >= 48 && c <= 57);
			out.add(isAlphaNum ? String.fromCharCode(c) : "_");
		}
		var s = out.toString();
		if (s.length == 0) s = "X";
		final first = s.charCodeAt(0);
		final isUpper = first >= 65 && first <= 90;
		final isLower = first >= 97 && first <= 122;
		if (isLower) s = String.fromCharCode(first - 32) + s.substr(1);
		else if (!isUpper) s = "M" + s;
		return s;
	}

	static function uniqueAliasModuleName(proposed:String, used:Map<String, Bool>):String {
		var name = proposed;
		while (used.exists(name)) {
			name = name + "_";
		}
		used.set(name, true);
		return name;
	}

	public static function emit(output:OutputManager, haxeModules:Array<String>):Void {
		if (output == null || output.outputDir == null) return;

		final leafOcamlModules:Map<String, String> = [];
		final used:Map<String, Bool> = [];

		// Track “real” modules that already exist (compiled output units).
		for (m in haxeModules) {
			if (m == null || m.length == 0) continue;
			final ocaml = moduleIdToOcamlModuleName(m);
			leafOcamlModules.set(m, ocaml);
			used.set(ocaml, true);
		}

		// Tree node: package prefix -> child packages + leaf modules.
		final childPackages:Map<String, Map<String, Bool>> = [];
		final childLeaves:Map<String, Map<String, String>> = [];

		function ensurePkg(prefix:String):Void {
			if (!childPackages.exists(prefix)) childPackages.set(prefix, []);
			if (!childLeaves.exists(prefix)) childLeaves.set(prefix, []);
		}

		// Build a tree from dot paths.
		for (m in haxeModules) {
			if (m == null || m.length == 0) continue;
			final parts = m.split(".");
			if (parts.length < 2) continue; // no package path to alias

			for (i in 0...(parts.length - 1)) {
				final prefix = parts.slice(0, i + 1).join(".");
				final next = parts[i + 1];
				ensurePkg(prefix);

				if (i + 1 == parts.length - 1) {
					// Leaf module under this package.
					final leaves = childLeaves.get(prefix);
					if (leaves != null) leaves.set(next, m);
				} else {
					// Another package prefix.
					final pkgs = childPackages.get(prefix);
					if (pkgs != null) pkgs.set(next, true);
				}
			}
		}

		// Assign module names for each package prefix (file name = module name).
		final pkgOcamlModule:Map<String, String> = [];
		for (prefix => _ in childPackages) {
			final proposed = moduleIdToOcamlModuleName(prefix);
			pkgOcamlModule.set(prefix, uniqueAliasModuleName(proposed, used));
		}

		// Emit files in a stable order.
		final prefixes:Array<String> = [];
		for (p => _ in childPackages) prefixes.push(p);
		prefixes.sort((a, b) -> a < b ? -1 : (a > b ? 1 : 0));

		for (prefix in prefixes) {
			final ocamlName = pkgOcamlModule.get(prefix);
			if (ocamlName == null) continue;

			final lines:Array<String> = [];
			lines.push("(* Generated by reflaxe.ocaml: package alias module *)");

			final pkgs = childPackages.get(prefix);
			if (pkgs != null) {
				final segs:Array<String> = [];
				for (s => _ in pkgs) segs.push(s);
				segs.sort((a, b) -> a < b ? -1 : (a > b ? 1 : 0));
				for (seg in segs) {
					final childPrefix = prefix + "." + seg;
					final target = pkgOcamlModule.get(childPrefix);
					if (target == null) continue;
					lines.push("module " + sanitizeModuleSegment(seg) + " = " + target);
				}
			}

			final leaves = childLeaves.get(prefix);
			if (leaves != null) {
				final segs:Array<String> = [];
				for (s => _ in leaves) segs.push(s);
				segs.sort((a, b) -> a < b ? -1 : (a > b ? 1 : 0));
				for (seg in segs) {
					final leafModulePath = leaves.get(seg);
					if (leafModulePath == null) continue;
					final leafOcaml = leafOcamlModules.get(leafModulePath);
					if (leafOcaml == null) continue;
					lines.push("module " + sanitizeModuleSegment(seg) + " = " + leafOcaml);
				}
			}

			lines.push("");
			output.saveFile(ocamlName + ".ml", lines.join("\n"));
		}
	}
}

#end


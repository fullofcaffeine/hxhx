# 1 "hxhxmacrohost_api_Compiler.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhxmacrohost.api.Compiler *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhxmacrohost.api.Compiler" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhxmacrohost.api.Compiler" } : t)

let getDefine = fun key -> try (
  ignore (if key == Obj.magic (HxRuntime.hx_null) || HxString.length key = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let payload = Hxhxmacrohost_HostToCompilerRpc.call "compiler.getDefine" (Hxhxmacrohost_Protocol.encodeLen "n" key) in (
    ignore (if payload == Obj.magic (HxRuntime.hx_null) || HxString.length payload = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
    let m = Hxhxmacrohost_Protocol.kvParse payload in let defined = HxMap.exists_string m "d" && HxString.equals (HxMap.get_string m "d") "1" in (
      ignore (if not (defined) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
      let tempResult = ref (Obj.magic ()) in (
        ignore (if HxMap.exists_string m "v" then let __assign_1 = HxMap.get_string m "v" in (
          tempResult := __assign_1;
          __assign_1
        ) else let __assign_2 = "" in (
          tempResult := __assign_2;
          __assign_2
        ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_3 -> Obj.obj __ret_3

let define = fun name value -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tempString = ref "" in (
    ignore (if value == Obj.magic (HxRuntime.hx_null) then let __assign_4 = "" in (
      tempString := __assign_4;
      __assign_4
    ) else let __assign_5 = value in (
      tempString := __assign_5;
      __assign_5
    ));
    let tail = (HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "n" name) ^ " ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "v" (!tempString)) in Hxhxmacrohost_HostToCompilerRpc.call "compiler.define" tail
  )
) with
  | HxRuntime.Hx_return __ret_6 -> Obj.obj __ret_6

let emitOcamlModule = fun name source -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tempString = ref "" in (
    ignore (if source == Obj.magic (HxRuntime.hx_null) then let __assign_7 = "" in (
      tempString := __assign_7;
      __assign_7
    ) else let __assign_8 = source in (
      tempString := __assign_8;
      __assign_8
    ));
    let tail = (HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "n" name) ^ " ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "s" (!tempString)) in Hxhxmacrohost_HostToCompilerRpc.call "compiler.emitOcamlModule" tail
  )
) with
  | HxRuntime.Hx_return __ret_9 -> Obj.obj __ret_9

let addClassPath = fun path -> try (
  ignore (if path == Obj.magic (HxRuntime.hx_null) || HxString.length path = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tail = Hxhxmacrohost_Protocol.encodeLen "cp" path in Hxhxmacrohost_HostToCompilerRpc.call "compiler.addClassPath" tail
) with
  | HxRuntime.Hx_return __ret_10 -> Obj.obj __ret_10

let includeModule = fun modulePath -> try (
  ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tail = Hxhxmacrohost_Protocol.encodeLen "m" modulePath in Hxhxmacrohost_HostToCompilerRpc.call "compiler.includeModule" tail
) with
  | HxRuntime.Hx_return __ret_11 -> Obj.obj __ret_11

let emitHxModule = fun name source -> try (
  ignore (if name == Obj.magic (HxRuntime.hx_null) || HxString.length name = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tempString = ref "" in (
    ignore (if source == Obj.magic (HxRuntime.hx_null) then let __assign_12 = "" in (
      tempString := __assign_12;
      __assign_12
    ) else let __assign_13 = source in (
      tempString := __assign_13;
      __assign_13
    ));
    let tail = (HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "n" name) ^ " ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "s" (!tempString)) in Hxhxmacrohost_HostToCompilerRpc.call "compiler.emitHxModule" tail
  )
) with
  | HxRuntime.Hx_return __ret_14 -> Obj.obj __ret_14

let emitBuildFields = fun modulePath membersSource -> try (
  ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then raise (HxRuntime.Hx_return (Obj.repr ())) else ());
  let tempString = ref "" in (
    ignore (if membersSource == Obj.magic (HxRuntime.hx_null) then let __assign_15 = "" in (
      tempString := __assign_15;
      __assign_15
    ) else let __assign_16 = membersSource in (
      tempString := __assign_16;
      __assign_16
    ));
    let tail = (HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "m" modulePath) ^ " ") ^ HxString.toStdString (Hxhxmacrohost_Protocol.encodeLen "s" (!tempString)) in Hxhxmacrohost_HostToCompilerRpc.call "compiler.emitBuildFields" tail
  )
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17
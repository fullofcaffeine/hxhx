# 1 "hxhxmacrohost_BuildMacroSupport.ml"
(* Generated by reflaxe.ocaml (WIP) *)
(* Haxe type: hxhxmacrohost.BuildMacroSupport *)

let __reflaxe_ocaml__ = ()

type t = { __hx_type : Obj.t }

let create = fun () -> let self = ({ __hx_type = HxType.class_ "hxhxmacrohost.BuildMacroSupport" } : t) in (
  ignore ();
  self
)

let __empty = fun () -> ({ __hx_type = HxType.class_ "hxhxmacrohost.BuildMacroSupport" } : t)

let escapeHaxeString = fun s -> try (
  ignore (if s == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr "")) else ());
  HxArray.join (HxString.split (HxArray.join (HxString.split (HxArray.join (HxString.split (HxArray.join (HxString.split (HxArray.join (HxString.split s "\\") "\\\\" (fun x -> x)) "\"") "\\\"" (fun x -> x)) "\n") "\\n" (fun x -> x)) "\r") "\\r" (fun x -> x)) "\t") "\\t" (fun x -> x)
) with
  | HxRuntime.Hx_return __ret_1 -> Obj.obj __ret_1

let rec tryExtractTraceString = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let _g = Obj.obj (HxAnon.get e "expr") in match _g with
      | Haxe_macro_Expr.ECall (_p0, _p1) -> let _g1 = _p0 in let _g2 = _p1 in let target = _g1 in let params = _g2 in let _g3 = Obj.obj (HxAnon.get target "expr") in if (match _g3 with
        | Haxe_macro_Expr.EConst _ -> 0
        | Haxe_macro_Expr.EArray (_, _) -> 1
        | Haxe_macro_Expr.EBinop (_, _, _) -> 2
        | Haxe_macro_Expr.EField (_, _, _) -> 3
        | Haxe_macro_Expr.EParenthesis _ -> 4
        | Haxe_macro_Expr.EObjectDecl _ -> 5
        | Haxe_macro_Expr.EArrayDecl _ -> 6
        | Haxe_macro_Expr.ECall (_, _) -> 7
        | Haxe_macro_Expr.ENew (_, _) -> 8
        | Haxe_macro_Expr.EUnop (_, _, _) -> 9
        | Haxe_macro_Expr.EVars _ -> 10
        | Haxe_macro_Expr.EFunction (_, _) -> 11
        | Haxe_macro_Expr.EBlock _ -> 12
        | Haxe_macro_Expr.EFor (_, _) -> 13
        | Haxe_macro_Expr.EIf (_, _, _) -> 14
        | Haxe_macro_Expr.EWhile (_, _, _) -> 15
        | Haxe_macro_Expr.ESwitch (_, _, _) -> 16
        | Haxe_macro_Expr.ETry (_, _) -> 17
        | Haxe_macro_Expr.EReturn _ -> 18
        | Haxe_macro_Expr.EBreak -> 19
        | Haxe_macro_Expr.EContinue -> 20
        | Haxe_macro_Expr.EUntyped _ -> 21
        | Haxe_macro_Expr.EThrow _ -> 22
        | Haxe_macro_Expr.ECast (_, _) -> 23
        | Haxe_macro_Expr.EDisplay (_, _) -> 24
        | Haxe_macro_Expr.ETernary (_, _, _) -> 25
        | Haxe_macro_Expr.ECheckType (_, _) -> 26
        | Haxe_macro_Expr.EMeta (_, _) -> 27
        | Haxe_macro_Expr.EIs (_, _) -> 28) = 0 then let _g4 = match _g3 with
        | Haxe_macro_Expr.EConst __enum_param_3 -> __enum_param_3
        | _ -> failwith "Unexpected enum parameter" in if (match _g4 with
        | Haxe_macro_Expr.CInt (_, _) -> 0
        | Haxe_macro_Expr.CFloat (_, _) -> 1
        | Haxe_macro_Expr.CString (_, _) -> 2
        | Haxe_macro_Expr.CIdent _ -> 3
        | Haxe_macro_Expr.CRegexp (_, _) -> 4) = 3 then let _g5 = match _g4 with
        | Haxe_macro_Expr.CIdent __enum_param_4 -> __enum_param_4
        | _ -> failwith "Unexpected enum parameter" in if HxString.equals _g5 "trace" then if params != Obj.magic (HxRuntime.hx_null) && HxArray.length params = 1 then let _g6 = Obj.obj (HxAnon.get (HxArray.get params 0) "expr") in if (match _g6 with
        | Haxe_macro_Expr.EConst _ -> 0
        | Haxe_macro_Expr.EArray (_, _) -> 1
        | Haxe_macro_Expr.EBinop (_, _, _) -> 2
        | Haxe_macro_Expr.EField (_, _, _) -> 3
        | Haxe_macro_Expr.EParenthesis _ -> 4
        | Haxe_macro_Expr.EObjectDecl _ -> 5
        | Haxe_macro_Expr.EArrayDecl _ -> 6
        | Haxe_macro_Expr.ECall (_, _) -> 7
        | Haxe_macro_Expr.ENew (_, _) -> 8
        | Haxe_macro_Expr.EUnop (_, _, _) -> 9
        | Haxe_macro_Expr.EVars _ -> 10
        | Haxe_macro_Expr.EFunction (_, _) -> 11
        | Haxe_macro_Expr.EBlock _ -> 12
        | Haxe_macro_Expr.EFor (_, _) -> 13
        | Haxe_macro_Expr.EIf (_, _, _) -> 14
        | Haxe_macro_Expr.EWhile (_, _, _) -> 15
        | Haxe_macro_Expr.ESwitch (_, _, _) -> 16
        | Haxe_macro_Expr.ETry (_, _) -> 17
        | Haxe_macro_Expr.EReturn _ -> 18
        | Haxe_macro_Expr.EBreak -> 19
        | Haxe_macro_Expr.EContinue -> 20
        | Haxe_macro_Expr.EUntyped _ -> 21
        | Haxe_macro_Expr.EThrow _ -> 22
        | Haxe_macro_Expr.ECast (_, _) -> 23
        | Haxe_macro_Expr.EDisplay (_, _) -> 24
        | Haxe_macro_Expr.ETernary (_, _, _) -> 25
        | Haxe_macro_Expr.ECheckType (_, _) -> 26
        | Haxe_macro_Expr.EMeta (_, _) -> 27
        | Haxe_macro_Expr.EIs (_, _) -> 28) = 0 then let _g7 = match _g6 with
        | Haxe_macro_Expr.EConst __enum_param_5 -> __enum_param_5
        | _ -> failwith "Unexpected enum parameter" in if (match _g7 with
        | Haxe_macro_Expr.CInt (_, _) -> 0
        | Haxe_macro_Expr.CFloat (_, _) -> 1
        | Haxe_macro_Expr.CString (_, _) -> 2
        | Haxe_macro_Expr.CIdent _ -> 3
        | Haxe_macro_Expr.CRegexp (_, _) -> 4) = 2 then let _g8 = match _g7 with
        | Haxe_macro_Expr.CString (__enum_param_6, _) -> __enum_param_6
        | _ -> failwith "Unexpected enum parameter" in (
        ignore (match _g7 with
          | Haxe_macro_Expr.CString (_, __enum_param_7) -> __enum_param_7
          | _ -> failwith "Unexpected enum parameter");
        let s = _g8 in let __assign_8 = s in (
          tempResult := __assign_8;
          __assign_8
        )
      ) else let __assign_9 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_9;
        __assign_9
      ) else let __assign_10 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_10;
        __assign_10
      ) else let __assign_11 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_11;
        __assign_11
      ) else let __assign_12 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_12;
        __assign_12
      ) else let __assign_13 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_13;
        __assign_13
      ) else let __assign_14 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_14;
        __assign_14
      )
      | Haxe_macro_Expr.EBlock _p0 -> let _g2 = _p0 in let stmts = _g2 in if stmts != Obj.magic (HxRuntime.hx_null) && HxArray.length stmts = 1 then let __assign_15 = tryExtractTraceString (HxArray.get stmts 0) in (
        tempResult := __assign_15;
        __assign_15
      ) else let __assign_16 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_16;
        __assign_16
      )
      | _ -> let __assign_2 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_2;
        __assign_2
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_17 -> Obj.obj __ret_17

let rec tryExtractReturnString = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let _g = Obj.obj (HxAnon.get e "expr") in match _g with
      | Haxe_macro_Expr.EBlock _p0 -> let _g2 = _p0 in let stmts = _g2 in if stmts != Obj.magic (HxRuntime.hx_null) && HxArray.length stmts = 1 then let __assign_19 = tryExtractReturnString (HxArray.get stmts 0) in (
        tempResult := __assign_19;
        __assign_19
      ) else let __assign_20 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_20;
        __assign_20
      )
      | Haxe_macro_Expr.EReturn _p0 -> let _g2 = _p0 in let v = _g2 in if v == Obj.magic (HxRuntime.hx_null) then let __assign_21 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_21;
        __assign_21
      ) else let _g3 = Obj.obj (HxAnon.get v "expr") in if (match _g3 with
        | Haxe_macro_Expr.EConst _ -> 0
        | Haxe_macro_Expr.EArray (_, _) -> 1
        | Haxe_macro_Expr.EBinop (_, _, _) -> 2
        | Haxe_macro_Expr.EField (_, _, _) -> 3
        | Haxe_macro_Expr.EParenthesis _ -> 4
        | Haxe_macro_Expr.EObjectDecl _ -> 5
        | Haxe_macro_Expr.EArrayDecl _ -> 6
        | Haxe_macro_Expr.ECall (_, _) -> 7
        | Haxe_macro_Expr.ENew (_, _) -> 8
        | Haxe_macro_Expr.EUnop (_, _, _) -> 9
        | Haxe_macro_Expr.EVars _ -> 10
        | Haxe_macro_Expr.EFunction (_, _) -> 11
        | Haxe_macro_Expr.EBlock _ -> 12
        | Haxe_macro_Expr.EFor (_, _) -> 13
        | Haxe_macro_Expr.EIf (_, _, _) -> 14
        | Haxe_macro_Expr.EWhile (_, _, _) -> 15
        | Haxe_macro_Expr.ESwitch (_, _, _) -> 16
        | Haxe_macro_Expr.ETry (_, _) -> 17
        | Haxe_macro_Expr.EReturn _ -> 18
        | Haxe_macro_Expr.EBreak -> 19
        | Haxe_macro_Expr.EContinue -> 20
        | Haxe_macro_Expr.EUntyped _ -> 21
        | Haxe_macro_Expr.EThrow _ -> 22
        | Haxe_macro_Expr.ECast (_, _) -> 23
        | Haxe_macro_Expr.EDisplay (_, _) -> 24
        | Haxe_macro_Expr.ETernary (_, _, _) -> 25
        | Haxe_macro_Expr.ECheckType (_, _) -> 26
        | Haxe_macro_Expr.EMeta (_, _) -> 27
        | Haxe_macro_Expr.EIs (_, _) -> 28) = 0 then let _g4 = match _g3 with
        | Haxe_macro_Expr.EConst __enum_param_22 -> __enum_param_22
        | _ -> failwith "Unexpected enum parameter" in if (match _g4 with
        | Haxe_macro_Expr.CInt (_, _) -> 0
        | Haxe_macro_Expr.CFloat (_, _) -> 1
        | Haxe_macro_Expr.CString (_, _) -> 2
        | Haxe_macro_Expr.CIdent _ -> 3
        | Haxe_macro_Expr.CRegexp (_, _) -> 4) = 2 then let _g1 = match _g4 with
        | Haxe_macro_Expr.CString (__enum_param_23, _) -> __enum_param_23
        | _ -> failwith "Unexpected enum parameter" in (
        ignore (match _g4 with
          | Haxe_macro_Expr.CString (_, __enum_param_24) -> __enum_param_24
          | _ -> failwith "Unexpected enum parameter");
        let s = _g1 in let __assign_25 = s in (
          tempResult := __assign_25;
          __assign_25
        )
      ) else let __assign_26 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_26;
        __assign_26
      ) else let __assign_27 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_27;
        __assign_27
      )
      | _ -> let __assign_18 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_18;
        __assign_18
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_28 -> Obj.obj __ret_28

let rec tryExtractReturnInt = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (HxRuntime.hx_null))) else ());
  let tempResult = ref (HxRuntime.hx_null) in (
    ignore (let _g = Obj.obj (HxAnon.get e "expr") in match _g with
      | Haxe_macro_Expr.EBlock _p0 -> let _g2 = _p0 in let stmts = _g2 in if stmts != Obj.magic (HxRuntime.hx_null) && HxArray.length stmts = 1 then let __assign_30 = tryExtractReturnInt (HxArray.get stmts 0) in (
        tempResult := __assign_30;
        __assign_30
      ) else let __assign_31 = HxRuntime.hx_null in (
        tempResult := __assign_31;
        __assign_31
      )
      | Haxe_macro_Expr.EReturn _p0 -> let _g2 = _p0 in let v = _g2 in if v == Obj.magic (HxRuntime.hx_null) then let __assign_32 = HxRuntime.hx_null in (
        tempResult := __assign_32;
        __assign_32
      ) else let _g3 = Obj.obj (HxAnon.get v "expr") in if (match _g3 with
        | Haxe_macro_Expr.EConst _ -> 0
        | Haxe_macro_Expr.EArray (_, _) -> 1
        | Haxe_macro_Expr.EBinop (_, _, _) -> 2
        | Haxe_macro_Expr.EField (_, _, _) -> 3
        | Haxe_macro_Expr.EParenthesis _ -> 4
        | Haxe_macro_Expr.EObjectDecl _ -> 5
        | Haxe_macro_Expr.EArrayDecl _ -> 6
        | Haxe_macro_Expr.ECall (_, _) -> 7
        | Haxe_macro_Expr.ENew (_, _) -> 8
        | Haxe_macro_Expr.EUnop (_, _, _) -> 9
        | Haxe_macro_Expr.EVars _ -> 10
        | Haxe_macro_Expr.EFunction (_, _) -> 11
        | Haxe_macro_Expr.EBlock _ -> 12
        | Haxe_macro_Expr.EFor (_, _) -> 13
        | Haxe_macro_Expr.EIf (_, _, _) -> 14
        | Haxe_macro_Expr.EWhile (_, _, _) -> 15
        | Haxe_macro_Expr.ESwitch (_, _, _) -> 16
        | Haxe_macro_Expr.ETry (_, _) -> 17
        | Haxe_macro_Expr.EReturn _ -> 18
        | Haxe_macro_Expr.EBreak -> 19
        | Haxe_macro_Expr.EContinue -> 20
        | Haxe_macro_Expr.EUntyped _ -> 21
        | Haxe_macro_Expr.EThrow _ -> 22
        | Haxe_macro_Expr.ECast (_, _) -> 23
        | Haxe_macro_Expr.EDisplay (_, _) -> 24
        | Haxe_macro_Expr.ETernary (_, _, _) -> 25
        | Haxe_macro_Expr.ECheckType (_, _) -> 26
        | Haxe_macro_Expr.EMeta (_, _) -> 27
        | Haxe_macro_Expr.EIs (_, _) -> 28) = 0 then let _g4 = match _g3 with
        | Haxe_macro_Expr.EConst __enum_param_33 -> __enum_param_33
        | _ -> failwith "Unexpected enum parameter" in if (match _g4 with
        | Haxe_macro_Expr.CInt (_, _) -> 0
        | Haxe_macro_Expr.CFloat (_, _) -> 1
        | Haxe_macro_Expr.CString (_, _) -> 2
        | Haxe_macro_Expr.CIdent _ -> 3
        | Haxe_macro_Expr.CRegexp (_, _) -> 4) = 0 then let _g1 = match _g4 with
        | Haxe_macro_Expr.CInt (__enum_param_34, _) -> __enum_param_34
        | _ -> failwith "Unexpected enum parameter" in (
        ignore (match _g4 with
          | Haxe_macro_Expr.CInt (_, __enum_param_35) -> __enum_param_35
          | _ -> failwith "Unexpected enum parameter");
        let s = _g1 in let __assign_36 = Std.parseInt s in (
          tempResult := __assign_36;
          __assign_36
        )
      ) else let __assign_37 = HxRuntime.hx_null in (
        tempResult := __assign_37;
        __assign_37
      ) else let __assign_38 = HxRuntime.hx_null in (
        tempResult := __assign_38;
        __assign_38
      )
      | _ -> let __assign_29 = HxRuntime.hx_null in (
        tempResult := __assign_29;
        __assign_29
      ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_39 -> Obj.obj __ret_39

let tryConstToHaxe = fun e -> try (
  ignore (if e == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let tempResult = ref (Obj.magic ()) in (
    ignore (let _g = Obj.obj (HxAnon.get e "expr") in if (match _g with
      | Haxe_macro_Expr.EConst _ -> 0
      | Haxe_macro_Expr.EArray (_, _) -> 1
      | Haxe_macro_Expr.EBinop (_, _, _) -> 2
      | Haxe_macro_Expr.EField (_, _, _) -> 3
      | Haxe_macro_Expr.EParenthesis _ -> 4
      | Haxe_macro_Expr.EObjectDecl _ -> 5
      | Haxe_macro_Expr.EArrayDecl _ -> 6
      | Haxe_macro_Expr.ECall (_, _) -> 7
      | Haxe_macro_Expr.ENew (_, _) -> 8
      | Haxe_macro_Expr.EUnop (_, _, _) -> 9
      | Haxe_macro_Expr.EVars _ -> 10
      | Haxe_macro_Expr.EFunction (_, _) -> 11
      | Haxe_macro_Expr.EBlock _ -> 12
      | Haxe_macro_Expr.EFor (_, _) -> 13
      | Haxe_macro_Expr.EIf (_, _, _) -> 14
      | Haxe_macro_Expr.EWhile (_, _, _) -> 15
      | Haxe_macro_Expr.ESwitch (_, _, _) -> 16
      | Haxe_macro_Expr.ETry (_, _) -> 17
      | Haxe_macro_Expr.EReturn _ -> 18
      | Haxe_macro_Expr.EBreak -> 19
      | Haxe_macro_Expr.EContinue -> 20
      | Haxe_macro_Expr.EUntyped _ -> 21
      | Haxe_macro_Expr.EThrow _ -> 22
      | Haxe_macro_Expr.ECast (_, _) -> 23
      | Haxe_macro_Expr.EDisplay (_, _) -> 24
      | Haxe_macro_Expr.ETernary (_, _, _) -> 25
      | Haxe_macro_Expr.ECheckType (_, _) -> 26
      | Haxe_macro_Expr.EMeta (_, _) -> 27
      | Haxe_macro_Expr.EIs (_, _) -> 28) = 0 then let _g2 = match _g with
      | Haxe_macro_Expr.EConst __enum_param_40 -> __enum_param_40
      | _ -> failwith "Unexpected enum parameter" in match _g2 with
      | Haxe_macro_Expr.CInt (_p0, _p1) -> let _g1 = _p0 in (
        ignore _p1;
        let s = _g1 in let __assign_42 = s in (
          tempResult := __assign_42;
          __assign_42
        )
      )
      | Haxe_macro_Expr.CFloat (_p0, _p1) -> let _g1 = _p0 in (
        ignore _p1;
        let s = _g1 in let __assign_43 = s in (
          tempResult := __assign_43;
          __assign_43
        )
      )
      | Haxe_macro_Expr.CString (_p0, _p1) -> let _g1 = _p0 in (
        ignore _p1;
        let s = _g1 in let __assign_44 = ("\"" ^ HxString.toStdString (escapeHaxeString s)) ^ "\"" in (
          tempResult := __assign_44;
          __assign_44
        )
      )
      | Haxe_macro_Expr.CIdent _p0 -> (let _g3 = _p0 in match _g3 with
        | "false" -> let __assign_46 = "false" in (
          tempResult := __assign_46;
          __assign_46
        )
        | "null" -> let __assign_47 = "null" in (
          tempResult := __assign_47;
          __assign_47
        )
        | "true" -> let __assign_48 = "true" in (
          tempResult := __assign_48;
          __assign_48
        )
        | _ -> let __assign_45 = Obj.magic (HxRuntime.hx_null) in (
          tempResult := __assign_45;
          __assign_45
        ))
      | _ -> let __assign_41 = Obj.magic (HxRuntime.hx_null) in (
        tempResult := __assign_41;
        __assign_41
      ) else let __assign_49 = Obj.magic (HxRuntime.hx_null) in (
      tempResult := __assign_49;
      __assign_49
    ));
    !tempResult
  )
) with
  | HxRuntime.Hx_return __ret_50 -> Obj.obj __ret_50

let printFieldMinimal = fun f -> try (
  ignore (if f == Obj.magic (HxRuntime.hx_null) || Obj.obj (HxAnon.get f "name") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get f "name")) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
  let isStatic = Obj.obj (HxAnon.get f "access") != Obj.magic (HxRuntime.hx_null) && HxArray.indexOf (Obj.obj (HxAnon.get f "access")) (Haxe_macro_Expr.AStatic) 0 <> -1 in let isPublic = Obj.obj (HxAnon.get f "access") != Obj.magic (HxRuntime.hx_null) && HxArray.indexOf (Obj.obj (HxAnon.get f "access")) (Haxe_macro_Expr.APublic) 0 <> -1 in let tempString = ref "" in (
    ignore (if isPublic then let __assign_51 = "public" in (
      tempString := __assign_51;
      __assign_51
    ) else let __assign_52 = "private" in (
      tempString := __assign_52;
      __assign_52
    ));
    let tempString1 = ref "" in (
      ignore (if isStatic then let __assign_53 = " static" in (
        tempString1 := __assign_53;
        __assign_53
      ) else let __assign_54 = "" in (
        tempString1 := __assign_54;
        __assign_54
      ));
      let tempResult = ref (Obj.magic ()) in (
        ignore (let _g = Obj.obj (HxAnon.get f "kind") in match _g with
          | Haxe_macro_Expr.FVar (_p0, _p1) -> let _g1 = Obj.obj (HxEnum.unbox_or_obj "haxe.macro.ComplexType" _p0) in let _g2 = _p1 in (
            ignore _g1;
            let e = _g2 in let init = tryConstToHaxe e in if init != Obj.magic (HxRuntime.hx_null) then let __assign_56 = (((((HxString.toStdString (!tempString) ^ HxString.toStdString (!tempString1)) ^ " var ") ^ HxString.toStdString (Obj.obj (HxAnon.get f "name"))) ^ " = ") ^ HxString.toStdString init) ^ ";" in (
              tempResult := __assign_56;
              __assign_56
            ) else let __assign_57 = (((HxString.toStdString (!tempString) ^ HxString.toStdString (!tempString1)) ^ " var ") ^ HxString.toStdString (Obj.obj (HxAnon.get f "name"))) ^ ":Dynamic;" in (
              tempResult := __assign_57;
              __assign_57
            )
          )
          | Haxe_macro_Expr.FFun _p0 -> let _g2 = _p0 in let fn = _g2 in (
            ignore (if fn == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
            let argNames = HxArray.create () in (
              ignore (if Obj.obj (HxAnon.get fn "args") != Obj.magic (HxRuntime.hx_null) then ignore (let _g3 = ref 0 in let _g1 = Obj.obj (HxAnon.get fn "args") in while !_g3 < HxArray.length _g1 do ignore (let a = HxArray.get _g1 (!_g3) in (
                ignore (let __old_58 = !_g3 in let __new_59 = HxInt.add __old_58 1 in (
                  ignore (_g3 := __new_59);
                  __new_59
                ));
                ignore (if a == Obj.magic (HxRuntime.hx_null) || Obj.obj (HxAnon.get a "name") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get a "name")) = 0 then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
                ignore (if let __nullable_60 = Obj.obj (HxAnon.get a "opt") in if __nullable_60 == HxRuntime.hx_null then false else Obj.obj __nullable_60 = true then raise (HxRuntime.Hx_return (Obj.repr (Obj.magic (HxRuntime.hx_null)))) else ());
                HxArray.push argNames (Obj.obj (HxAnon.get a "name"))
              )) done) else ());
              let msg = tryExtractTraceString (Obj.obj (HxAnon.get fn "expr")) in (
                ignore (if msg != Obj.magic (HxRuntime.hx_null) then ignore (let body = ("{ trace(\"" ^ HxString.toStdString (escapeHaxeString msg)) ^ "\"); }" in raise (HxRuntime.Hx_return (Obj.repr (((((((HxString.toStdString (!tempString) ^ HxString.toStdString (!tempString1)) ^ " function ") ^ HxString.toStdString (Obj.obj (HxAnon.get f "name"))) ^ "(") ^ HxString.toStdString (HxArray.join argNames ", " (fun x -> x))) ^ ") ") ^ HxString.toStdString body)))) else ());
                let retStr = tryExtractReturnString (Obj.obj (HxAnon.get fn "expr")) in (
                  ignore (if retStr != Obj.magic (HxRuntime.hx_null) then ignore (let body = ("{ return \"" ^ HxString.toStdString (escapeHaxeString retStr)) ^ "\"; }" in raise (HxRuntime.Hx_return (Obj.repr (((((((HxString.toStdString (!tempString) ^ HxString.toStdString (!tempString1)) ^ " function ") ^ HxString.toStdString (Obj.obj (HxAnon.get f "name"))) ^ "(") ^ HxString.toStdString (HxArray.join argNames ", " (fun x -> x))) ^ ") ") ^ HxString.toStdString body)))) else ());
                  let retInt = tryExtractReturnInt (Obj.obj (HxAnon.get fn "expr")) in (
                    ignore (if retInt != HxRuntime.hx_null then ignore (let body = ("{ return " ^ HxString.toStdString (HxRuntime.nullable_int_toStdString retInt)) ^ "; }" in raise (HxRuntime.Hx_return (Obj.repr (((((((HxString.toStdString (!tempString) ^ HxString.toStdString (!tempString1)) ^ " function ") ^ HxString.toStdString (Obj.obj (HxAnon.get f "name"))) ^ "(") ^ HxString.toStdString (HxArray.join argNames ", " (fun x -> x))) ^ ") ") ^ HxString.toStdString body)))) else ());
                    let __assign_61 = Obj.magic (HxRuntime.hx_null) in (
                      tempResult := __assign_61;
                      __assign_61
                    )
                  )
                )
              )
            )
          )
          | _ -> let __assign_55 = Obj.magic (HxRuntime.hx_null) in (
            tempResult := __assign_55;
            __assign_55
          ));
        !tempResult
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_62 -> Obj.obj __ret_62

let afterEntrypoint = fun ret -> try (
  ignore (if ret == Obj.magic (HxRuntime.hx_null) then ignore ((
    ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
    raise (HxRuntime.Hx_return (Obj.repr ()))
  )) else ());
  ignore (if not (Hxhxmacrohost_MacroRuntime.hasCurrentBuildFieldSnapshot ()) then ignore ((
    ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
    raise (HxRuntime.Hx_return (Obj.repr ()))
  )) else ());
  let modulePath = Hxhxmacrohost_api_Compiler.getDefine "HXHX_BUILD_MODULE" in (
    ignore (if modulePath == Obj.magic (HxRuntime.hx_null) || HxString.length modulePath = 0 then ignore ((
      ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
      raise (HxRuntime.Hx_return (Obj.repr ()))
    )) else ());
    let arr = ref (Obj.magic (HxRuntime.hx_null)) in (
      ignore (try let __assign_63 = Obj.obj ret in (
        arr := __assign_63;
        __assign_63
      ) with
        | HxRuntime.Hx_break -> raise (HxRuntime.Hx_break)
        | HxRuntime.Hx_continue -> raise (HxRuntime.Hx_continue)
        | HxRuntime.Hx_return __ret_64 -> raise (HxRuntime.Hx_return __ret_64)
        | HxRuntime.Hx_exception (__exn_v_65, __exn_tags_66) -> if true then let _hx = (__exn_v_65 : Obj.t) in (
          ignore _hx;
          (
            ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
            raise (HxRuntime.Hx_return (Obj.repr ()))
          )
        ) else HxRuntime.hx_throw_typed __exn_v_65 __exn_tags_66
        | __exn_67 -> if true then let _hx = (Obj.repr __exn_67 : Obj.t) in (
          ignore _hx;
          (
            ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
            raise (HxRuntime.Hx_return (Obj.repr ()))
          )
        ) else raise (__exn_67));
      ignore (if !arr == Obj.magic (HxRuntime.hx_null) then ignore ((
        ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
        raise (HxRuntime.Hx_return (Obj.repr ()))
      )) else ());
      let emittedFields = HxArray.create () in let seenByName = HxMap.create_string () in (
        ignore (let _g = ref 0 in try while !_g < HxArray.length (!arr) do try ignore (let raw = HxArray.get (!arr) (!_g) in (
          ignore (let __old_68 = !_g in let __new_69 = HxInt.add __old_68 1 in (
            ignore (_g := __new_69);
            __new_69
          ));
          ignore (if raw == Obj.magic (HxRuntime.hx_null) then raise (HxRuntime.Hx_continue) else ());
          ignore (if not (HxAnon.has raw "name") || not (HxAnon.has raw "kind") then raise (HxRuntime.Hx_continue) else ());
          let f = raw in (
            ignore (if f == Obj.magic (HxRuntime.hx_null) || Obj.obj (HxAnon.get f "name") == Obj.magic (HxRuntime.hx_null) || HxString.length (Obj.obj (HxAnon.get f "name")) = 0 then raise (HxRuntime.Hx_continue) else ());
            let tempBool = ref false in (
              ignore (let key = Obj.obj (HxAnon.get f "name") in let __assign_70 = HxMap.exists_string seenByName key in (
                tempBool := __assign_70;
                __assign_70
              ));
              ignore (if !tempBool then raise (HxRuntime.Hx_continue) else ());
              ignore (let key = Obj.obj (HxAnon.get f "name") in HxMap.set_string seenByName key true);
              HxArray.push emittedFields f
            )
          )
        )) with
          | HxRuntime.Hx_continue -> () done with
          | HxRuntime.Hx_break -> ());
        ignore (if HxArray.length emittedFields = 0 then ignore ((
          ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
          raise (HxRuntime.Hx_return (Obj.repr ()))
        )) else ());
        let lines = HxArray.create () in (
          ignore (let _g = ref 0 in while !_g < HxArray.length emittedFields do ignore (let f = HxArray.get emittedFields (!_g) in (
            ignore (let __old_71 = !_g in let __new_72 = HxInt.add __old_71 1 in (
              ignore (_g := __new_72);
              __new_72
            ));
            let text = printFieldMinimal f in if text != Obj.magic (HxRuntime.hx_null) && HxString.length text > 0 then ignore (HxArray.push lines text) else ()
          )) done);
          ignore (if HxArray.length lines = 0 then ignore ((
            ignore (Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ());
            raise (HxRuntime.Hx_return (Obj.repr ()))
          )) else ());
          ignore (Hxhxmacrohost_api_Compiler.emitBuildFields modulePath (HxArray.join lines "\n" (fun x -> x)));
          Hxhxmacrohost_MacroRuntime.clearCurrentBuildFieldSnapshot ()
        )
      )
    )
  )
) with
  | HxRuntime.Hx_return __ret_73 -> Obj.obj __ret_73